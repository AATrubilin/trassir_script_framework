# -*- coding: utf-8 -*-
"""
<parameters>
    <company>AATrubilin</company>
    <title>trassir_script_framework</title>
    <version>0.62</version>
</parameters>
"""

# _SERVICE_VERSION = 0.63
tbot_service = """
    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
"""

import re
import os
import sys
import ssl
import time
import host
import json

import pickle
import base64
import ftplib
import urllib
import urllib2
import httplib
import logging
import threading
import subprocess

from Queue import Queue
from functools import wraps
from collections import deque
from xml.etree import ElementTree
from __builtin__ import object as py_object
from datetime import datetime, date, timedelta
from logging.handlers import RotatingFileHandler


"""import for tbot_service"""
# noinspection PyUnresolvedReferences
import mimetools, mimetypes, itertools

logger = logging.getLogger()


class ScriptError(Exception):
    """Base script exception"""

    _host_api = host

    def __init__(self, *args):
        super(ScriptError, self).__init__(*args)
        self._host_api.timeout(1, self.rise_from_thread)

    def rise_from_thread(self):
        raise self


class HostLogHandler(logging.Handler):
    """Trassir main log handler"""

    def __init__(self, host_api=host):
        super(HostLogHandler, self).__init__()
        self._host_api = host_api

    def emit(self, record):
        msg = self.format(record)
        self._host_api.log_message(msg)


class PopupHandler(logging.Handler):
    """Trassir popup handler"""

    def __init__(self, host_api=host):
        super(PopupHandler, self).__init__()
        self._host_api = host_api
        self._popups = {
            "CRITICAL": host_api.error,
            "FATAL": host_api.error,
            "ERROR": host_api.error,
            "WARN": host_api.alert,
            "WARNING": host_api.alert,
            "INFO": host_api.message,
            "DEBUG": host_api.message,
            "NOTSET": host_api.message,
        }

    def emit(self, record):
        msg = self.format(record)
        self._popups[record.levelname](msg)


class DuplicateFilter(logging.Filter):
    """Suppressing multiple messages with same content.

    Tracking last logged record and filter out any
    repeated (similar) records. Output something more rsyslog style.
    
    Example:
        --- The last message repeated 3 times
    """

    def __init__(self):
        super(DuplicateFilter, self).__init__()
        self._last_log = None
        self._last_log_count = 1

    def filter(self, record):
        record.duplicates = ""
        current_log = (record.module, record.levelno, record.msg)
        if current_log == self._last_log:
            self._last_log_count += 1
            return False
        else:
            if self._last_log_count > 1:
                record.duplicates = (
                    "--- The last message repeated %s times\n" % self._last_log_count
                )
            self._last_log = current_log
            self._last_log_count = 1
            return True


class BaseUtils:
    """Base utils for your scripts"""

    _host_api = host
    _FOLDERS = {obj[1]: obj[3] for obj in host.objects_list("Folder")}
    _TEXT_FILE_EXTENSIONS = [".txt", ".csv", ".log"]
    _LPR_FLAG_BITS = {
        "LPR_UP": 0x00001,
        "LPR_DOWN": 0x00002,
        "LPR_BLACKLIST": 0x00004,
        "LPR_WHITELIST": 0x00008,
        "LPR_INFO": 0x00010,
        "LPR_FIRST_LANE": 0x01000,
        "LPR_SECOND_LANE": 0x02000,
        "LPR_THIRD_LANE": 0x04000,
        "LPR_EXT_DB_ERROR": 0x00020,
        "LPR_CORRECTED": 0x00040,
    }
    _EVENT_STR_TO_INT = {
        "Border Crossed A -> B": -2010220362,
        "Border Crossed B -> A": 881900680,
        "Border %1 A-B Crossing": 1745631458,
        "Border %1 B-A Crossing": 1382034490,
        "Border %1 Unique Object A-B Crossing": -1764400102,
        "Border %1 Unique Object B-A Crossing": -755097134,
        "Connected To %1 under %2": -567223767,
        "Connection Established": 1689573124,
        "Connection Lost": -1739961019,
        "Deny: %1 (%2)": 1400866841,
        "Disconnected From %1": 854687023,
        "FACS Connected": 928164014,
        "FACS Disconnected": -528751441,
        "Face Detected": -145480902,
        "Face Recognized": 1904675878,
        "Fire Detected": -2095846277,
        "Fire Stopped": 1556160195,
        "HDD Broken": -359176531,
        "HDD Error": -2035571413,
        "HDD Restored": 2054776042,
        "Health Turns Bad": -1338064969,
        "Health Turns Good": 1737407416,
        "Input High to Low": 1260011944,
        "Input Low to High": 108469542,
        "Login Failed, %1 from %2": -1785217387,
        "Login Successful, %1 from %2": 1634136664,
        "Logout, %1 from %2": 334348171,
        "Motion Start": -1960416690,
        "Motion Stop": 452886769,
        "No Connection to Cloud": -1220531757,
        "Object Entered the Zone": -1484834142,
        "Object Left the Zone": 1838034845,
        "Output High to Low": -994975116,
        "Output Low to High": 842360770,
        "Pass: %1 (%2)": 1944146750,
        "Photo Detected": -220640968,
        "Script: %1": 865778551,
        "Shutdown": 390175606,
        "Signal Lost": -997068283,
        "Signal Restored": -1801421619,
        "Slow Down Detected": -438590449,
        "Software update to version %1 succeeded": 1188419157,
        "Startup": -37228692,
        "Tracked Object Left Zone %1": 456308509,
        "Tracked Unique Object Entered Zone %1": -1766980008,
    }
    _EVENT_INT_TO_STR = {v: k for k, v in _EVENT_STR_TO_INT.iteritems()}
    _IMAGE_EXT = [".png", ".jpg", ".jpeg", ".bmp"]
    _HTML_IMG_TEMPLATE = """<img src="data:image/png;base64,{img}" {attr}>"""

    _SCR_DEFAULT_NAMES = [
        "Yeni skript",
        "Unnamed Script",
        "უსახელო სკრიპტი",
        "Жаңа скрипт",
        "Script nou",
        "Новый скрипт",
        "Yeni skript dosyası",
        "Новий скрипт",
        "未命名脚本",
    ]

    def __init__(self):
        pass

    # noinspection PyUnusedLocal
    @staticmethod
    def do_nothing(*args, **kwargs):
        """Ничего не делает.

        Returns:
            :obj:`bool`: ``True``
        """
        return True

    @classmethod
    def run_as_thread_v2(cls, locked=False, daemon=True):
        """Декоратор для запуска функций в отдельном потоке.

        Args:
            locked (:obj:`bool`, optional): Если :obj:`True` - запускает поток с блокировкой
                доступа к ресурсам. По умолчанию :obj:`False`
            daemon (:obj:`bool`, optional): Устанавливает значение :obj:`threading.Thread.daemon`.
                По умолчанию :obj:`True`

        Examples:
            >>> import time
            >>>
            >>>
            >>> @BaseUtils.run_as_thread_v2()
            >>> def run_count_timer():
            >>>     time.sleep(1)
            >>>     host.stats()["run_count"] += 1
            >>>
            >>>
            >>> run_count_timer()
        """
        lock = threading.Lock()

        def wrapped(fn):
            @wraps(fn)
            def run(*args, **kwargs):
                def raise_exc(err):
                    # noinspection PyShadowingNames
                    args = list(err.args)
                    args[0] = "[{}]: {}".format(fn.__name__, args[0])
                    err.args = args
                    raise err

                def locked_fn(*args_, **kwargs_):
                    lock.acquire()
                    try:
                        return fn(*args_, **kwargs_)
                    except Exception as err:
                        cls._host_api.timeout(1, lambda: raise_exc(err))
                    finally:
                        lock.release()

                def unlocked_fn(*args_, **kwargs_):
                    try:
                        return fn(*args_, **kwargs_)
                    except Exception as err:
                        cls._host_api.timeout(1, lambda: raise_exc(err))

                t = threading.Thread(
                    target=locked_fn if locked else unlocked_fn,
                    args=args,
                    kwargs=kwargs,
                )
                t.daemon = daemon
                t.start()
                return t

            return run

        return wrapped

    @staticmethod
    def run_as_thread(fn):
        """Декоратор для запуска функций в отдельном потоке.

        Returns:
            :obj:`threading.Thread`: Функция в отдельном потоке

        Examples:
            >>> import time
            >>>
            >>>
            >>> @BaseUtils.run_as_thread
            >>> def run_count_timer():
            >>>     time.sleep(1)
            >>>     host.stats()["run_count"] += 1
            >>>
            >>>
            >>> run_count_timer()
        """

        @wraps(fn)
        def run(*args, **kwargs):
            t = threading.Thread(target=fn, args=args, kwargs=kwargs)
            t.daemon = True
            t.start()
            return t

        return run

    @staticmethod
    def catch_request_exceptions(func):
        """Catch request errors"""

        @wraps(func)
        def wrapped(self, *args, **kwargs):
            try:
                return func(self, *args, **kwargs)
            except urllib2.HTTPError as e:
                return e.code, "HTTPError: {}".format(e.code)
            except urllib2.URLError as e:
                return e.reason, "URLError: {}".format(e.reason)
            except httplib.HTTPException as e:
                return e, "HTTPException: {}".format(e)
            except ssl.SSLError as e:
                return e.errno, "SSLError: {}".format(e)

        return wrapped

    @staticmethod
    def win_encode_path(path):
        """Изменяет кодировку на ``"cp1251"`` для WinOS.

        Args:
            path (:obj:`str`): Путь до файла или папки

        Returns:
            :obj:`str`: Декодированый путь до файла или папки

        Examples:
            >>> path = r"D:\Shots\Скриншот.jpeg"
            >>> os.path.isfile(path)
            False
            >>> os.path.isfile(BaseUtils.win_encode_path(path))
            True
        """
        if os.name == "nt":
            try:
                path = path.decode("utf8")
            except UnicodeDecodeError:
                logger.warning("UnicodeDecodeError: {}".format(path), exc_info=True)
                pass

        return path

    @staticmethod
    def is_file_exists(file_path, tries=1):
        """Проверяет, существует ли файл.

        Проверка происходит в течении ``tries`` секунд.

        Warning:
            | Запускайте функцию только в отдельном потоке если ``tries > 1``
            | Вторая и последующие проверки производятся с ``time.sleep(1)``

        Args:
            file_path (:obj:`str`): Полный путь до файла
            tries (:obj:`int`, optional): Количество проверок. По умолчанию ``tries=1``

        Returns:
            :obj:`bool`: ``True`` if file exists, ``False`` otherwise

        Examples:
            >>> BaseUtils.is_file_exists("_t1server.settings")
            True
        """
        file_path_encoded = BaseUtils.win_encode_path(file_path)
        if os.path.isfile(file_path) or os.path.isfile(file_path_encoded):
            return True
        for x in xrange(tries - 1):
            time.sleep(1)
            if os.path.isfile(file_path) or os.path.isfile(file_path_encoded):
                return True
        return False

    @staticmethod
    def is_folder_exists(folder):
        """Проверяет существование папки и доступ на запись.

        Args:
            folder (:obj:`str`): Путь к папке.

        Raises:
            IOError: Если папка не существует

        Examples:
            >>> BaseUtils.is_folder_exists("/test_path")
            IOError: Folder '/test_path' is not exists
        """

        if not os.path.isdir(folder):
            raise IOError("Folder '{}' is not exists".format(folder))

        readme_file = os.path.join(folder, "readme.txt")
        with open(readme_file, "w") as f:
            f.write(
                "If you see this file - Trassir script have no access to remove it!"
            )
        os.remove(readme_file)

    @classmethod
    def is_template_exists(cls, template_name):
        """Проверяет существование шаблона

        Args:
            template_name (:obj:`str`): Имя шаблона

        Returns:
            :obj:`bool`: :obj:`True` если шаблон существует, иначе :obj:`False`
        """
        if template_name in [
            tmpl_.name for tmpl_ in cls._host_api.settings("templates").ls()
        ]:
            return True
        return False

    @classmethod
    def cat(cls, filepath, check_ext=True):
        """Выводит на отображение текстовую инфомрацию.

        Tip:
            - *WinOS*: открывает файл программой по умолчанию
            - *TrassirOS*: открывает файл в терминале с помощью утилиты `cat`

        Note:
            | Доступные расширения файлов: ``[".txt", ".csv", ".log"]``
            | Если открываете файл с другим расширением установите ``check_ext=False``

        Args:
            filepath (:obj:`str`): Полный путь до файла
            check_ext (:obj:`bool`, optional): Если ``True`` - проверяет расширение файла.
                По умолчанию ``True``

        Examples:
            >>> BaseUtils.cat("/home/trassir/ Trassir 3 License.txt")
        .. image:: images/base_utils.cat.png

        Raises:
            :class:`TypeError`: Если ``check_ext=True`` расширение файла нет в списке :obj:`_TEXT_FILE_EXTENSIONS`
        """

        if check_ext:
            _, ext = os.path.splitext(filepath)
            if ext not in cls._TEXT_FILE_EXTENSIONS:
                raise TypeError(
                    "Bad file extension: {}. To ignore this: set check_ext=False".format(
                        ext
                    )
                )

        if os.name == "nt":
            os.startfile(filepath)
        else:
            subprocess.Popen(
                [
                    "xterm -fg black -bg white -geometry 90x35 -fn "
                    "-misc-fixed-medium-r-normal--18-120-100-100-c-90-iso10646-1 -e bash -c \"cat '{}'; "
                    "read -n 1 -s -r -p '\n\nPress any key to exit'; exit\"".format(
                        filepath
                    )
                ],
                shell=True,
                close_fds=True,
            )

    @classmethod
    def _json_serializer(cls, data):
        """JSON serializer for objects not serializable by default"""
        if isinstance(data, (datetime, date)):
            return data.isoformat()

        elif isinstance(data, cls._host_api.ScriptHost.SE_Settings):
            return "settings('{}')".format(data.path)

        elif isinstance(data, cls._host_api.ScriptHost.SE_Object):
            return "object('{}')".format(data.guid)

        return type(data).__name__

    @classmethod
    def to_json(cls, data, **kwargs):
        """Сериализация объекта в JSON стрку

        Note:
            Не вызывает ошибку при сериализации объектов :obj:`datetime`,
            :obj:`date`, :obj:`SE_Settings`, :obj:`SE_Object`

        Args:
            data (:obj:`obj`): Объект для сериализации

        Returns:
            :obj:`str`: JSON строка

        Examples:
            >>> obj = {"now": datetime.now()}
            >>> json.dumps(obj)
            TypeError: datetime.datetime(2019, 4, 2, 18, 01, 33, 881000) is not JSON serializable
            >>> BaseUtils.to_json(obj, indent=None)
            '{"now": "2019-04-02T18:01:33.881000"}'
        """

        return json.dumps(data, default=cls._json_serializer, **kwargs)

    @staticmethod
    def ts_to_dt(ts):
        """Конвертирует timestamp в :obj:`datetime` объект

        Args:
            ts (:obj:`int`): Timestamp

        Returns:
            :obj:`datetime`: Datetime объект
        """
        if ts > 1e10:
            ts_sec = int(ts / 1e6)
            ts_ms = int(ts - ts_sec * 1e6)
        else:
            ts_sec = int(ts)
            ts_ms = 0

        return datetime.fromtimestamp(ts_sec) + timedelta(microseconds=ts_ms)

    @staticmethod
    def dt_to_ts(dt):
        """Конвертирует :obj:`datetime` объект в trassir timestamp

        Args:
            dt (:obj:`datetime`): Datetime

        Returns:
            :obj:`int`: Trassir timestamp
        """
        return int(time.mktime(dt.timetuple())) * 1e6 + dt.microsecond

    @classmethod
    def lpr_flags_decode(cls, flags):
        """Преобразует флаги события AutoTrassir

        Приводит флаги события человекочитаемый список

        Note:
            Список доступных флагов:

            - ``LPR_UP`` - Направление движения вверх
            - ``LPR_DOWN`` - Направление движения вниз

            - ``LPR_BLACKLIST`` - Номер в черном списке
            - ``LPR_WHITELIST`` - Номер в черном списке
            - ``LPR_INFO`` - Номер в информационном списке

            - ``LPR_FIRST_LANE`` - Автомобиль двигается по первой полосе
            - ``LPR_SECOND_LANE`` - Автомобиль двигается по второй полосе
            - ``LPR_THIRD_LANE`` - Автомобиль двигается по третей полосе

            - ``LPR_EXT_DB_ERROR`` - Ошибка во внешнем списке
            - ``LPR_CORRECTED`` - Номер исправлен оператором

        Args:
            flags (:obj:`int`): Биты LPR события. Как правило аргумент :obj:`ev.flags`
                события :obj:`SE_LprEvent` AutoTrassir. Например :obj:`536870917`

        Returns:
            List[:obj:`str`]: Список флагов

        Examples:
            >>> BaseUtils.lpr_flags_decode(536870917)
            ['LPR_UP', 'LPR_BLACKLIST']
        """
        return [bit for bit, code in cls._LPR_FLAG_BITS.iteritems() if (flags & code)]

    @classmethod
    def event_type_encode(cls, event_type):
        """Преобразует тип события :obj:`str` -> :obj:`int`

        Note:
            События в БД хранятся в :obj:`int`, в скриптах
            приходят в человекочитаемом, строковом формате.

        Args:
            event_type (:obj:`str`): Тип события как в скриптах.

        Examples:
            >>> BaseUtils.event_type_encode("Border Crossed A -> B")
            -2010220362

        Returns:
            :obj:`int`: Тип события как в БД
        """
        if not isinstance(event_type, str):
            raise TypeError(
                "Expected str, got {}".format(type(event_type).__name__)
            )
        return cls._EVENT_STR_TO_INT.get(event_type)

    @classmethod
    def event_type_decode(cls, event_type):
        """Преобразует тип события :obj:`int` -> :obj:`str`

        Note:
            События в БД хранятся в :obj:`int`, в скриптах
            приходят в человекочитаемом, строковом формате.

        Args:
            event_type (:obj:`int`): Тип события как в БД.

        Examples:
            >>> BaseUtils.event_type_encode(-2010220362)
            "Border Crossed A -> B"

        Returns:
            :obj:`str`: Тип события как в скриптах
        """
        if not isinstance(event_type, int):
            raise TypeError(
                "Expected int, got {}".format(type(event_type).__name__)
            )
        return cls._EVENT_INT_TO_STR.get(event_type)

    @classmethod
    def image_to_base64(cls, image):
        """Создает base64 из изображения

        Args:
            image (:obj:`str`): Путь к изображению или изображение

        Returns:
            :obj:`str`: Base64 image

        Examples:
            >>> BaseUtils.image_to_base64(r"manual\en\cloud-devices-16.png")
            'iVBORw0KGgoAAAANSUhEUgAAB1MAAAH0CAYAAABo5wRhAAAACXBIWXMAAC4jA...'
            >>> BaseUtils.image_to_base64(open(r"manual\en\cloud-devices-16.png", "rb").read())
            'iVBORw0KGgoAAAANSUhEUgAAB1MAAAH0CAYAAABo5wRhAAAACXBIWXMAAC4jA...'
        """
        _, ext = os.path.splitext(image)

        if ext.lower() in cls._IMAGE_EXT:
            image = cls.win_encode_path(image)
            if not BaseUtils.is_file_exists(image):
                return ""

            with open(image, "rb") as image_file:
                image = image_file.read()

        return base64.b64encode(image)

    @classmethod
    def base64_to_html_img(cls, image_base64, **kwargs):
        """Возвращает base64 изображение в `<img>` html теге

        Args:
            image_base64 (:obj:`str`): Base64 image
            **kwargs: HTML `<img>` tag attributes. Подробнее на `html.com
                <https://html.com/tags/img/#Attributes_of_img>`_

        Returns:
            :obj:`str`: html image

        Examples:
            >>> base64_image = BaseUtils.image_to_base64(r"manual\en\cloud-devices-16.png")
            >>> html_image = BaseUtils.base64_to_html_img(base64_image, width=280, height=75)
            >>> html_image
            '<img src="data:image/png;base64,iVBORw0KGgoAA...Jggg==" width="280" height="75">'
            >>> host.message(html_image)

                .. image:: images/popup_sender.image.png
        """
        html_img = cls._HTML_IMG_TEMPLATE.format(
            img=image_base64,
            attr=" ".join(
                '%s="%s"' % (key, value) for key, value in kwargs.iteritems()
            ),
        )
        return html_img

    @staticmethod
    def save_pkl(file_path, data):
        """Сохраняет данные в `.pkl` файл

        Args:
            file_path (:obj:`str`): Путь до файла
            data: Данные для сохранения

        Returns:
            :obj:`str`: Абсолютный путь до файла

        Examples:
            >>> data = {"key": "value"}
            >>> BaseUtils.save_pkl("saved_data.pkl", data)
            'D:\\DSSL\\Trassir-4.1-Client\\saved_data.pkl'

        """
        if not file_path.endswith(".pkl"):
            file_path = file_path + ".pkl"

        with open(file_path, "wb") as opened_file:
            pickle.dump(data, opened_file)

        return os.path.abspath(file_path)

    @staticmethod
    def load_pkl(file_path, default_type=dict):
        """Загружает данные из `.pkl` файла

        Args:
            file_path (:obj:`str`): Путь до файла
            default_type (optional):
                Тип данных, возвращаемый при неудачной загрузке данных из файла.
                По умолчанию :obj:`dict`

        Returns:
            Данные из файла или :obj:`default_type()`

        Examples:
            >>> BaseUtils.load_pkl("fake_saved_data.pkl")
            {}
            >>> BaseUtils.load_pkl("fake_saved_data.pkl", default_type=list)
            []
            >>> BaseUtils.load_pkl("fake_saved_data.pkl", default_type=int)
            0
            >>> BaseUtils.load_pkl("fake_saved_data.pkl", default_type=str)
            ''
            >>> BaseUtils.load_pkl("saved_data.pkl")
            {'key': 'value'}
        """

        if not file_path.endswith(".pkl"):
            file_path = file_path + ".pkl"

        data = default_type()

        if os.path.isfile(file_path):
            try:
                with open(file_path, "rb") as opened_file:
                    data = pickle.load(opened_file)
            except (EOFError, IndexError, ValueError, TypeError):
                """ dump file is empty or broken """

        return data

    @classmethod
    def get_object(cls, obj_id):
        """Возвращает объект Trassir, если он доступен, иначе ``None``

        Args:
            obj_id (:obj:`str`): Guid объекта или его имя

        Returns:
            :obj:`ScriptHost.SE_Object`: Объект Trassir или ``None``

        Examples:
            >>> obj = BaseUtils.get_object("EZJ4QnbC")
            >>> if obj is None:
            >>>     host.error("Object not found")
            >>> else:
            >>>     host.message("Object name is {0.name}".format(obj))
        """
        if not isinstance(obj_id, (str, unicode)):
            raise TypeError(
                "Expected str or unicode, got '{}'".format(type(obj_id).__name__)
            )
        obj = cls._host_api.object(obj_id)
        try:
            obj.name
        except EnvironmentError:
            """Object not found"""
            obj = None
        return obj

    @classmethod
    def get_object_name_by_guid(cls, guid):
        """Возвращает имя объекта Trassir по его guid

        Tip:
            Можно использовать:

            - guid объекта ``"CFsuNBzt"``
            - guid объекта + guid сервера ``"CFsuNBzt_pV4ggECb"``

        Args:
            guid (:obj:`str`): Guid объекта Trassir

        Returns:
            :obj:`str`: Имя объекта, если объект найден, иначе ``guid``

        Examples:
            >>> BaseUtils.get_object_name_by_guid("EZJ4QnbC")
            'AC-D2141IR3'
            >>> BaseUtils.get_object_name_by_guid("EZJ4QnbC-")
            'EZJ4QnbC-'
        """
        guid = guid.split("_", 1)[0]
        obj = cls.get_object(guid)
        if obj is None:
            name = guid
        else:
            name = obj.name
        return name

    @classmethod
    def get_full_guid(cls, obj_id):
        """Возвращает полный guid объекта

        Args:
            obj_id (:obj:`str`): Guid объекта или его имя

        Returns:
            :obj:`str`: Полный guid объекта
        """

        tr_obj = cls.get_object(obj_id)
        if tr_obj is not None:
            for obj in cls._host_api.objects_list(""):
                if tr_obj.guid == obj[1]:
                    return "{}_{}".format(obj[1], cls._FOLDERS.get(obj[3], obj[3]))

    @classmethod
    def get_operator_gui(cls):
        """Возвращает объект интерфейса оператора

        Returns:
            :obj:`OperatorGUI`: Объект интерфейса оператора

        Raises:
            ScriptError: Если не удается загрузить интерфейс

        Examples:
            Открыть интерфейс Trassir а мониторе №1

            >>> operator_gui = BaseUtils.get_operator_gui()
            >>> operator_gui.raise_monitor(1)
        """
        obj = cls.get_object("operatorgui_{}".format(cls._host_api.settings("").guid))
        if obj is None:
            raise ScriptError("Failed to load operator gui")
        return obj

    @classmethod
    def get_server_guid(cls):
        """Возвращает guid текущего сервра

        Returns:
            :obj:`str`: Guid сервера

        Examples:
            >>> BaseUtils.get_server_guid()
            'client'
        """
        return cls._host_api.settings("").guid

    @classmethod
    def get_script_name(cls):
        """Возвращает имя текущего скрипта

        Returns:
            :obj:`str`: Имя скрипта

        Examples:
            >>> BaseUtils.get_script_name()
            'Новый скрипт'
        """
        return cls._host_api.stats().parent()["name"] or __name__

    @classmethod
    def get_screenshot_folder(cls):
        """Возвращает путь до папки скриншотов

        При этом производит проверку папки методом
        :meth:`BaseUtils.is_folder_exists`

        Returns:

            :obj:`str`: Полный путь к папке скриншотов

        Examples:
            >>> BaseUtils.get_screenshot_folder()
            '/home/trassir/shots'
        """
        folder = cls._host_api.settings("system_wide_options")["screenshots_folder"]
        cls.is_folder_exists(folder)
        return folder

    @classmethod
    def get_logger(
        cls,
        host_log="WARNING",
        popup_log="ERROR",
        file_log=None,
        file_name=None,
        file_max_bytes=5 * 1024 * 1024,
        file_backup_count=2,
    ):
        """Возвращает логгер с предустановленными хэндлерами

        Доступные хэндлеры:
            - *host_log*: Пишет сообщения в основной лог сервера _t1server.log
            - *popup_log*: Показывает всплывающие сообщения ``message/alert/error``
            - *file_log*: Пишет сообщения в отдельный файл в папку скриншотов

        Для каждого хэндлера можно установить разный уровень логирования

        По умолчанию ``host_log="WARNING"`` и ``popup_log="ERROR"``

        Note:
            Имя файла лога можно указать с расширение ".log" или без.

        See Also:
            `Logging levels на сайте docs.python.org
            <https://docs.python.org/2/library/logging.html#logging-levels>`_

        Args:
            host_log (:obj:`str`, optional): Уровень логирования в основной лог.
                По умолчанию ``"WARNING"``
            popup_log (:obj:`str`, optional): Уровень логирования во всплывающих
                сообщениях. По умолчанию ``"ERROR"``
            file_log (:obj:`str`, optional): Уровень логирования в отдельный файл
                По умолчанию :obj:`None`
            file_name (:obj:`str`, optional): Имя файла для логирования.
                По умолчанию :obj:`None` и равно ``<имени скрипта>.log``
            file_max_bytes (:obj:`int`, optional): Максимальный размер файла лога
                в байтах. По умолчанию :obj:`5 * 1024 * 1024`
            file_backup_count (:obj:`int`, optional): Макссимальное кол-во бэкапов лога.
                По умолчанию :obj:`2`

        Returns:
            :obj:`logging.logger`: Логгер

        Examples:
            >>> logger = BaseUtils.get_logger()
            >>> logger.warning("My warning message")
            >>> try:
            >>>     # noinspection PyUnresolvedReferences
            >>>     do_something()
            >>> except NameError:
            >>>     logger.error("Function is not defined", exc_info=True)
        """
        logger_ = logging.getLogger(__name__)
        logger_.setLevel("DEBUG")

        def _remove_handlers():
            """Close and remove handlers on disable script"""
            logger_.info("Remove handlers...")
            for handler in logger_.handlers[:]:
                handler.close()
                logger_.removeHandler(handler)

        cls._host_api.register_finalizer(_remove_handlers)

        if host_log:
            host_handler = HostLogHandler()
            host_handler.setLevel(host_log)
            host_formatter = logging.Formatter(
                "[%(levelname)-8s] %(lineno)-4s <%(funcName)s> - %(message)s"
            )
            host_handler.setFormatter(host_formatter)
            logger_.addHandler(host_handler)

        if popup_log:
            popup_handler = PopupHandler()
            popup_handler.setLevel(popup_log)
            popup_formatter = logging.Formatter(
                fmt="<b>[%(levelname)s]</b> Line: %(lineno)s<br><i>%(message).630s</i>"
            )
            popup_handler.setFormatter(popup_formatter)
            logger_.addHandler(popup_handler)

        if file_log:
            if file_name is None:
                file_name = cls.get_script_name()

            if not file_name.endswith(".log"):
                file_name = "{}.log".format(file_name)

            file_path = os.path.join(cls.get_screenshot_folder(), file_name)
            file_path = cls.win_encode_path(file_path)

            file_handler = RotatingFileHandler(
                file_path, maxBytes=file_max_bytes, backupCount=file_backup_count
            )
            file_handler.setLevel(file_log)
            file_formatter = logging.Formatter(
                fmt="%(duplicates)s%(asctime)s [%(levelname)-8s] %(lineno)-4s <%(funcName)s> - %(message)s",
                datefmt="%Y/%m/%d %H:%M:%S",
            )
            file_handler.setFormatter(file_formatter)
            file_handler.addFilter(DuplicateFilter())
            logger_.addHandler(file_handler)

        return logger_

    @classmethod
    def set_script_name(cls, fmt=None, script_name=None):
        """Автоматически изменяет имя скрипта

        Новое имя скрипта создается на основе `параметров
        <https://www.dssl.ru/files/trassir/manual/ru/setup-script-parameters.html>`_
        скрипта. По желанию можно изменить шаблон имени. По умолчанию
        :obj:`"[{company}] {title} v{version}"`

        Note:
            Имя изменяется только если сейчас у скрипта стандартное имя,
            например :obj:`"Новый скрипт"` или :obj:`"Unnamed Script"` и др.

        Args:
            fmt (:obj:`str`, optional): Шаблон имени скрипта. По умолчанию :obj:`None`
            script_name (:obj:`str`, optional): Имя скрипта. Если не задано - парсит
                имя из параметров. По умолчанию :obj:`None`

        Examples:
            >>> BaseUtils.set_script_name()
            'AATrubilin - trassir_script_framework v0.4'

            >>> BaseUtils.set_script_name(fmt="{title}")
            'trassir_script_framework'
        """
        if cls._host_api.stats().parent()["name"] in cls._SCR_DEFAULT_NAMES:
            if script_name is None:
                try:
                    root = ElementTree.fromstring(__doc__)
                except ElementTree.ParseError:
                    root = None

                if root is None:
                    company, title, version = None, None, None
                else:
                    company = root.find("company") if root else None
                    title = root.find("title") if root else None
                    version = root.find("version") if root else None

                if fmt is None:
                    fmt = "[{company}] {title} v{version}"

                script_name = fmt.format(
                    company="DSSL" if company is None else company.text,
                    title="Script" if title is None else title.text,
                    version="0.1" if version is None else version.text,
                )

            cls._host_api.stats().parent()["name"] = script_name

            return script_name


class Worker(threading.Thread):
    """Thread executing tasks from a given tasks queue"""

    def __init__(self, tasks):
        super(Worker, self).__init__()
        alert("START WORKER")
        self.tasks = tasks
        self.daemon = True
        self.start()

    def run(self):
        while __name__ in sys.modules.keys():
            if not self.tasks.empty():
                func, args, kwargs = self.tasks.get(timeout=1)
                # noinspection PyBroadException
                try:
                    func(*args, **kwargs)
                except:
                    logger.exception("ThreadPool Worker error")
                finally:
                    self.tasks.task_done()


class ThreadPool:
    """Pool of threads consuming tasks from a queue"""

    def __init__(self, num_threads, host_api=host):
        self._host_api = host_api
        self.tasks = Queue()
        self.workers = [Worker(self.tasks) for _ in xrange(num_threads)]

    def add_task(self, func, *args, **kargs):
        """Add a task to the queue"""
        self.tasks.put((func, args, kargs))

    def wait_completion(self):
        """Wait for completion of all the tasks in the queue"""
        self.tasks.join()


class HTTPRequester(py_object):
    """Framework for urllib2

    See Also:
        https://docs.python.org/2/library/urllib2.html#urllib2.build_opener

    Args:
        opener (:obj:`urllib2.OpenerDirector`, optional): Обработчик запросов.
            По умолчанию :obj:`None`
        timeout (:obj:`int`, optional): Время ожидания запроса, в секундах.
            По умолчанию :obj:`timeout=10`

    Examples:
        Пример запроса к SDK Trassir

        >>> # Отключение проверки сертификата
        >>> context = ssl.create_default_context()
        >>> context.check_hostname = False
        >>> context.verify_mode = ssl.CERT_NONE
        >>>
        >>> handler = urllib2.HTTPSHandler(context=context)
        >>> opener = urllib2.build_opener(handler)
        >>>
        >>> requests = HTTPRequester(opener, timeout=20)
        >>> response = requests.get(
        >>>     "https://172.20.0.101:8080/login",
        >>>     params={"username": "Admin", "password": "12345"}
        >>> )
        >>>
        >>> response.code
        200
        >>> response.text
        '{\\n   "sid" : "T6LAAcxg",\\n   "success" : 1\\n}\\n'
        >>> response.json
        {u'success': 1, u'sid': u'T6LAAcxg'}
    """

    class Response(py_object):
        """Класс ответа от сервера

        Attributes:
            code (:obj:`str` | :obj:`int`): Код ответа сервера
            text (:obj:`str`): Текст ответа
            json (:obj:`dict` | :obj:`list`): Создает объект из json ответа
        """

        def __init__(self, *args):
            self.code, self.text = args

        @property
        def json(self):
            return json.loads(self.text)

    def __init__(self, opener=None, timeout=10):
        if opener is None:
            handler = urllib2.BaseHandler()
            opener = urllib2.build_opener(handler)
        self._opener = opener

        self.timeout = timeout

    @BaseUtils.catch_request_exceptions
    def _get_response(self, request):
        """Returns response

        Args:
            request (:obj:`urllib2.Request`): This class is an abstraction of a URL request
        """
        response = self._opener.open(request, timeout=self.timeout)
        return response.code, response.read()

    @staticmethod
    def _parse_params(**params):
        """Params get string params

        Args:
            **params (dict): Keyword arguments

        Returns:
            str: params string
        """
        return "&".join(
            "{key}={value}".format(key=key, value=value)
            for key, value in params.iteritems()
        )

    @staticmethod
    def _prepare_headers(headers):
        """Prepare headers for request"""
        if headers is None:
            headers = {}

        if "User-Agent" not in headers:
            headers["User-Agent"] = "TrassirScript"
        return headers

    def get(self, url, params=None, headers=None):
        """Создает GET запрос по указанному :obj:`url`

        Args:
            url (:obj:`str`): Url для запроса
            params (:obj:`dict`, optional): Параметры GET запроса
            headers (:obj:`dict`, optional): Заголовки запроса

        Examples:
            >>> requests = HTTPRequester()
            >>> response = requests.get(
            >>>     "http://httpbin.org/get",
            >>>     params={"PARAMETER": "TEST"},
            >>> )
            >>> response.code
            200
            >>> response.text
            '{\\n  "args": {\\n    "PARAMETER": "TEST"\\n  }, \\n ...'
            >>> response.json
            {u'args': {u'PARAMETER': u'TEST'}, ...}

        Returns:
            :class:`HTTPRequester.Response`: Response instance
        """
        if params is not None:
            url += "?{params}".format(params=self._parse_params(**params))

        headers = self._prepare_headers(headers)

        request = urllib2.Request(url, headers=headers)
        response = self._get_response(request)
        return self.Response(*response)

    def post(self, url, data=None, headers=None):
        """Создает POST запрос по указанному :obj:`url`

        Args:
            url (:obj:`str`): Url для запроса
            data (:obj:`dict`, optional): Данные POST запроса
            headers (:obj:`dict`, optional): Заголовки запроса

        Examples:
            >>> requests = HTTPRequester()
            >>> response = requests.post(
            >>>     "http://httpbin.org/post",
            >>>     data={"PARAMETER": "TEST"},
            >>>     headers={"Content-Type": "application/json"},
            >>> )
            >>> response.code
            200
            >>> response.text
            '{\\n  "args": {\\n    "PARAMETER": "TEST"\\n  }, \\n ...'
            >>> response.json
            {u'args': {u'PARAMETER': u'TEST'}, ...}

        Returns:
            :class:`HTTPRequester.Response`: Response instance
        """
        if data is None:
            data = {}

        if isinstance(data, dict):
            data = urllib.urlencode(data)

        headers = self._prepare_headers(headers)

        request = urllib2.Request(url, data=data, headers=headers)
        response = self._get_response(request)
        return self.Response(*response)


class ScriptObject(host.TrassirObject, py_object):
    """Создает объект для генерации событий

    Args:
        name (:obj:`str`, optional): Имя объекта. По умолчанию :obj:`None`
        guid (:obj:`str`, optional): Guid объекта. По умолчанию :obj:`None`
        parent (:obj:`str`, optional): Guid родительского объекта. По умолчанию :obj:`None`

    Note:
        - Имя объекта по умолчанию - :meth:`BaseUtils.get_script_name`
        - Guid объекта по умолчанию строится по шаблноу ``"{script_guid}_object"``
        - Guid родительского объекта по умолчанию -
          :meth:`BaseUtils.get_server_guid`

    Examples:
        >>> # Создаем объект
        >>> scr_obj = ScriptObject()

        >>> # Проверяем текущее состояние объекта
        >>> scr_obj.health
        'OK'

        >>> # Установить флаг возле объекта
        >>> scr_obj.check_me = True

        >>> # Сгенерировать событие с текстом
        >>> scr_obj.fire_event_v2("New event")
    """

    def __init__(self, name=None, guid=None, parent=None, host_api=host):
        super(ScriptObject, self).__init__("Script")

        self._host_api = host_api
        scr_parent = host_api.stats().parent()

        self._name = name or BaseUtils.get_script_name()
        self.set_name(self._name)

        self._guid = guid or "{}-object".format(scr_parent.guid)
        self.set_guid(self._guid)

        self._parent = parent or BaseUtils.get_server_guid()
        self.set_parent(self._parent)

        self._folder = ""

        self._health = "OK"
        self._check_me = True

        self.set_initial_state([self._health, self._check_me])

        host_api.object_add(self)

    @property
    def health(self):
        """:obj:`"OK"` | :obj:`"Error"`: Состояние объекта"""
        return self._health

    @health.setter
    def health(self, value):
        if value in ["OK", "Error"]:
            self.set_state([value, self._check_me])
            self._health = value
        else:
            raise ValueError("Expected 'OK' or 'Error', got '{}'".format(value))

    @property
    def check_me(self):
        """:obj:`bool`: Флаг ``check_me`` объекта"""
        return self._check_me

    @check_me.setter
    def check_me(self, value):
        if isinstance(value, bool) or value in [1, 0]:
            value = 1 - value
            self.set_state([self._health, value])
            self._check_me = value
        else:
            raise ValueError("Expected bool or 1|0, got '{}'".format(value))

    @property
    def name(self):
        """:obj:`str`: Имя объекта"""
        return self._name

    @name.setter
    def name(self, value):
        if isinstance(value, str):
            self.set_name(value)
            self._name = value
        else:
            raise ValueError("Expected str, got {}".format(type(value).__name__))

    @property
    def folder(self):
        """:obj:`str`: Папка объекта"""
        return self._folder

    @folder.setter
    def folder(self, value):
        if not value:
            raise ValueError("Object guid can't be empty")

        if isinstance(value, str):
            if self._folder:
                self.change_folder(value)
            else:
                self.set_folder(value)
            self._folder = value
        else:
            raise ValueError("Expected str, got {}".format(type(value).__name__))

    def fire_event_v2(self, message, channel="", data=""):
        """Создает событие в Trassir

        Args:
            message (:obj:`str`): Сообщение события (``p1``)
            channel (:obj:`str`, optional): Ассоциированный с событием канал (``p2``)
            data (:obj:`str`, optional): Дополнительные данные (``p3``)
        """
        if not isinstance(data, str):
            data = BaseUtils.to_json(data, indent=None)

        self.fire_event("Script: %1", message, channel, data)


class ShotSaverError(ScriptError):
    """Base ShotSaver Exception"""

    pass


class ShotSaver(py_object):
    """Класс для сохранения скриншотов

        Args:
            shot_awaiting_time (:obj:`int`, optional): Время ожидания скриншота, с. По умолчанию :obj:`5`.
            tries_to_make_shot (:obj:`int`, optional): Кол-во попыток сохранить скриншот.
                Если в течении времени `shot_awaiting_time` скриншот не был сохранен - производится
                следующая попытка сохранить скриншот. По умолчанию :obj:`2`
            pool_size (:obj:`int`): Размер пула. По умолчанию :obj:`10`
        """

    _SHOT_NAME_TEMPLATE = (
        "{name} (%Y.%m.%d %H-%M-%S).jpg"
    )  # Template for shot file name

    def __init__(
        self, shot_awaiting_time=5, tries_to_make_shot=2, pool_size=10, host_api=host
    ):
        self._shot_awaiting_time = shot_awaiting_time
        self._tries_to_make_shot = tries_to_make_shot
        self._thread_pool = None
        self._pool_size = pool_size

        self._host_api = host_api
        self._screenshots_folder = BaseUtils.get_screenshot_folder()

    @property
    def pool_size(self):
        """:obj:`int`: Размер пула для метода :obj:`pool_shot`

        Устанавливает размер пула (кол-во одновременно созданных задач
        сохранения скриншотов). По умолчанию :obj:`10`.

        Warnings:
            Изменить данный параметр можно только до первого вызова
            метода :obj:`pool_shot`. После вызовет :obj:`RuntimeError`

        Raises:
            RuntimeError: Если пул уже создан.
        """
        return self._pool_size

    @pool_size.setter
    def pool_size(self, value):
        if self._thread_pool is None:
            self._pool_size = value
        else:
            raise RuntimeError("You can't change pool size when workers created")

    @property
    def pool_queue_size(self):
        """:obj:`int`: Размер текущей очереди в пуле

        Возвращает текущий размер очереди в пуле.

        Note:
            Если пул еще не был созда (метод :obj:`pool_shot`
            не вызывался) данный метод вернет :obj:`-1`
        """
        if self._thread_pool is None:
            return -1
        else:
            return self._thread_pool.tasks.qsize()

    @property
    def screenshots_folder(self):
        """:obj:`str`: Папка для сохранения скриншотов по умолчанию

        Устанавливает новый путь по умолчанию для сохранения скриншотов,
        если папка не существует - создает папку. Или возвращает текущий
        путь для сохранения скриншотов.

        Note:
            По молчанию :obj:`screenshots_folder`  =
            :meth:`BaseUtils.get_screenshot_folder`

        Raises:
            OSError: Если возникает ошибка при создании папки
        """
        return self._screenshots_folder

    @screenshots_folder.setter
    def screenshots_folder(self, folder):
        if not os.path.isdir(folder):
            try:
                os.makedirs(folder)
            except OSError as err:
                raise OSError("Can't make dir '{}': {}".format(folder, err))

        self._screenshots_folder = folder

    def shot(self, channel_full_guid, dt=None, file_name=None, file_path=None):
        """Делает скриншот с указанного канала

        Note:
            По умолчанию:

            - :obj:`dt=datetime.now()`
            - :obj:`file_name="{name} (%Y.%m.%d %H-%M-%S).jpg"`, где ``{name}`` - имя канала

        Args:
            channel_full_guid (:obj:`str`): Полный guid анала. Например: ``"CFsuNBzt_pV4ggECb"``
            dt (:obj:`datetime.datetime`, optional): :obj:`datetime.datetime` для скриншота.
                По умолчанию :obj:`None`
            file_name (:obj:`str`, optional): Имя файла с расширением. По умолчанию :obj:`None`
            file_path (:obj:`str`, optional): Путь для сохранения скриншота. По умолчанию :obj:`None`

        Returns:
            :obj:`str`: Полный путь до скриншота

        Raises:
            ValueError: Если в guid канала отсутствует guid сервера
            TypeError: Если ``isinstance(dt, (datetime, date)) is False``

        Examples:
            >>> ss = ShotSaver()
            >>> ss.shot("e80kgBLh_pV4ggECb")
            '/home/trassir/shots/AC-D2141IR3 Склад (2019.04.03 15-58-26).jpg'
        """
        logger.debug(
            "ShotSaver.shot({channel_full_guid}, dt={dt}, file_name={file_name}, file_path={file_path})".format(
                channel_full_guid=repr(channel_full_guid),
                dt=repr(dt),
                file_name=repr(file_name),
                file_path=repr(file_path),
            )
        )
        if "_" not in channel_full_guid:
            raise ValueError(
                "Expected full channel guid, got {}".format(channel_full_guid)
            )

        if dt is None:
            ts = "0"
            dt = datetime.now()
        else:
            if not isinstance(dt, (datetime, date)):
                raise TypeError("Expected datetime, got {}".format(type(dt).__name__))
            ts = dt.strftime("%Y%m%d_%H%M%S")

        if file_name is None:
            file_name = dt.strftime(
                self._SHOT_NAME_TEMPLATE.format(
                    name=BaseUtils.get_object_name_by_guid(channel_full_guid)
                )
            )
        if file_path is None:
            file_path = self.screenshots_folder

        self._host_api.screenshot_v2_figures(
            channel_full_guid, file_name, file_path, ts
        )

        return os.path.join(file_path, file_name)

    def _async_shot(
        self, channel_full_guid, dt=None, file_name=None, file_path=None, callback=None
    ):
        """Вызывает ``callback`` после сохнанения скриншота

        * Метод работает в отдельном потоке
        * Вызывает функцию :meth:`ShotSaver.shot`
        * Ждет выполнения функции :meth:`BaseUtils.check_file` ``tries=10``
        * Вызвает ``callback`` функцию

        Args:
            channel_full_guid (:obj:`str`): Полный guid канала. Например: ``"CFsuNBzt_pV4ggECb"``
            dt (:obj:`datetime.datetime`, optional): :obj:`datetime.datetime` для скриншота.
                По умолчанию :obj:`None`
            file_name (:obj:`str`, optional): Имя файла с расширением. По умолчанию :obj:`None`
            file_path (:obj:`str`, optional): Путь для сохранения скриншота. По умолчанию :obj:`None`
            callback (:obj:`function`): Callable function
        """
        if callback is None:
            callback = BaseUtils.do_nothing

        shot_file = ""
        for _ in xrange(self._tries_to_make_shot):
            shot_file = self.shot(
                channel_full_guid, dt=dt, file_name=file_name, file_path=file_path
            )
            if BaseUtils.is_file_exists(
                BaseUtils.win_encode_path(shot_file), self._shot_awaiting_time
            ):
                self._host_api.timeout(100, lambda: callback(True, shot_file))
                break
        else:
            self._host_api.timeout(100, lambda: callback(False, shot_file))

    @BaseUtils.run_as_thread
    def async_shot(
        self, channel_full_guid, dt=None, file_name=None, file_path=None, callback=None
    ):
        """async_shot(channel_full_guid, dt=None, file_name=None, file_path=None, callback=None)
        Вызывает ``callback`` после сохнанения скриншота

        * Метод работает в отдельном потоке
        * Вызывает функцию :meth:`ShotSaver.shot`
        * Ждет выполнения функции :meth:`BaseUtils.check_file` ``tries=10``
        * Вызвает ``callback`` функцию

        Args:
            channel_full_guid (:obj:`str`): Полный guid канала. Например: ``"CFsuNBzt_pV4ggECb"``
            dt (:obj:`datetime.datetime`, optional): :obj:`datetime.datetime` для скриншота.
                По умолчанию :obj:`None`
            file_name (:obj:`str`, optional): Имя файла с расширением. По умолчанию :obj:`None`
            file_path (:obj:`str`, optional): Путь для сохранения скриншота. По умолчанию :obj:`None`
            callback (:obj:`function`, optional): Функциюя, которая вызывается после сохранения скриншота.
                В качестве аргументов должна принимать `success`, `shot_path`. По умолчанию :obj:`None`

        Returns:
            :obj:`threading.Thread`: Thread object

        Examples:
            >>> # noinspection PyUnresolvedReferences
            >>> def callback(success, shot_path):
            >>>     # Пример callback функции
            >>>     # Args:
            >>>     #     success (bool): True если скриншот успешно сохранен, иначе False
            >>>     #     shot_path (str): Полный путь до скриншота
            >>>     if success:
            >>>         host.message("Скриншот успешно сохранен<br>%s" % shot_path)
            >>>     else:
            >>>         host.error("Ошибка сохранения скриншота <br>%s" % shot_path)
            >>>
            >>> ss = ShotSaver()
            >>> ss.async_shot("e80kgBLh_pV4ggECb", callback=callback)
        """
        self._async_shot(
            channel_full_guid,
            dt=dt,
            file_name=file_name,
            file_path=file_path,
            callback=callback,
        )

    @BaseUtils.run_as_thread
    def _pool_awaiting(self):
        self._thread_pool.wait_completion()

    # noinspection PyIncorrectDocstring
    def pool_shot(self, *args, **kwargs):
        """pool_shot(channel_full_guid, dt=None, file_name=None, file_path=None, callback=None)
        Сохраняет скриншоты в пуле.

        Одновременно в работе не более :obj:`ShotSaver.pool_size` задач.

        Warnings:
            Данный метод создает :obj:`ShotSaver.pool_size` доп. потоков.
            Потоки удаляются при отключении скрипта.

        Args:
            channel_full_guid (:obj:`str`): Полный guid канала. Например: ``"CFsuNBzt_pV4ggECb"``
            dt (:obj:`datetime.datetime`, optional): :obj:`datetime.datetime` для скриншота.
                По умолчанию :obj:`None`
            file_name (:obj:`str`, optional): Имя файла с расширением. По умолчанию :obj:`None`
            file_path (:obj:`str`, optional): Путь для сохранения скриншота. По умолчанию :obj:`None`
            callback (:obj:`function`, optional): Функциюя, которая вызывается после сохранения скриншота.
                В качестве аргументов должна принимать `success`, `shot_path`. По умолчанию :obj:`None`

        Examples:

            >>> ss = ShotSaver()
            >>> ss.pool_size = 2
            >>>
            >>> ss.pool_shot("e80kgBLh_pV4ggECb")
            >>> ss.pool_shot("e80kgBLh_pV4ggECb")
            >>> ss.pool_shot("e80kgBLh_pV4ggECb")
            >>> ss.pool_shot("e80kgBLh_pV4ggECb")
            >>>
            >>> ss.pool_queue_size
            4
        """
        if self._thread_pool is None:
            self._thread_pool = ThreadPool(self._pool_size)

        self._thread_pool.add_task(self._async_shot, *args, **kwargs)


class VideoExporterError(ScriptError):
    """Base ShotSaver Exception"""

    pass


class VideoExporter(py_object):
    """Класс для экспорта видео

    Examples:
        Смена папки экспорта видео по умолчанию

        >>> ss = VideoExporter()
        >>> ss.export_folder
        '/home/trassir/shots'
        >>> ss.export_folder += "/my_videos"
        >>> ss.export_folder
        '/home/trassir/shots/my_videos'

        | Экспорт видео с вызовом ``callback`` функции после выполнения.
        | Начало экспорта - 120 секунд назад, продолжительность 60 сек.

        >>> # noinspection PyUnresolvedReferences
        >>> def callback(success, file_path, channel_full_guid):
        >>>     # Пример callback функции
        >>>     # Args:
        >>>     #     success (bool): True если видео экспортировано успешно, иначе False
        >>>     #     file_path (str): Полный путь до видеофайла
        >>>     #     channel_full_guid (str) : Полный guid канала
        >>>     if success:
        >>>         host.message("Экспорт успешно завершен<br>%s" % file_path)
        >>>     else:
        >>>         host.error("Ошибка экспорта<br>%s" % file_path)

        >>> ss = VideoExporter()
        >>> dt_start = datetime.now() - timedelta(seconds=120)
        >>> ss.export(callback, "e80kgBLh_pV4ggECb", dt_start)
    """

    _EXPORTED_VIDEO_NAME_TEMPLATE = (
        "{name} ({dt_start} - {dt_end}){sub}.avi"
    )  # Template for shot file name

    def __init__(self, host_api=host):
        self._host_api = host_api
        self._export_folder = BaseUtils.get_screenshot_folder()
        self._now_exporting = False
        self._queue = deque()
        self._default_prebuffer = host_api.settings("archive")["prebuffer"] + 2

    @property
    def export_folder(self):
        """:obj:`str`: Папка для экспорта видео по умолчанию

        Устанавливает новый путь по умолчанию для экспорта видео,
        если папка не существует - создает папку. Или возвращает текущий
        путь для экспорта видео.

        Note:
            По молчанию ``export_folder`` = :meth:`BaseUtils.get_screenshot_folder`

        Raises:
            OSError: Если возникает ошибка при создании папки
        """
        return self._export_folder

    @export_folder.setter
    def export_folder(self, folder):
        if not os.path.isdir(folder):
            try:
                os.makedirs(folder)
            except OSError as err:
                raise OSError("Can't make dir '{}': {}".format(folder, err))

        self._export_folder = folder

    def _get_prebuffer(self, server_guid, dt_end):
        """Get prebuffer delay

        Args:
            server_guid (str): Full channel guid include server guid

        Returns:
            int: Prebuffer delay
        """
        setting_path = "/{}/archive".format(server_guid)

        try:
            prebuffer = self._host_api.settings(setting_path)["prebuffer"] + 2
        except KeyError:
            prebuffer = self._default_prebuffer

        wait_dt_end = (int(time.mktime(dt_end.timetuple())) + prebuffer) * 1000000

        return "%.0f" % wait_dt_end

    def clear_complete_tasks(self):
        for task in self._host_api.archive_export_tasks_get():
            if task["state"] != 1:
                self._host_api.archive_export_task_cancel(
                    task["id"],  # task id from archive_export_tasks_get
                    -1,  # -1 - do not wait for result, 0 - wait forever, > 0 - wait timeout_sec seconds
                    BaseUtils.do_nothing,  # callback_success
                    BaseUtils.do_nothing,  # callback_error
                )

    def _check_queue(self):
        self._host_api.timeout(10, self.clear_complete_tasks)
        if self._queue:
            args, kwargs = self._queue.popleft()
            self._export(*args, **kwargs)

    def _export_checker(self, status, callback, file_path, channel_full_guid):
        if status == 1:
            return
        elif status in [0, 2]:
            """Export failed"""
            self._host_api.timeout(
                100, lambda: callback(False, file_path, channel_full_guid)
            )
        else:
            """Export success"""
            self._host_api.timeout(
                100, lambda: callback(True, file_path, channel_full_guid)
            )

        self._now_exporting = False
        self._check_queue()

    def _export(
        self,
        channel_full_guid,
        dt_start,
        dt_end=None,
        duration=60,
        prefer_substream=False,
        file_name=None,
        file_path=None,
        callback=None,
    ):
        """Exporting file

        Call callback(success: bool, file_path: str, channel_full_guid: str)
        when export finished, and clear tasks in trassir main control panel

        Note:
            Export task adding only when previous task finished
            You can set dt_start, dt_end, or dt_start, duration for export
            if dt_end is None: dt_end = dt_start + timedelta(seconds=duration)

        Args:
            channel_full_guid (str): Full channel guid; example: "CFsuNBzt_pV4ggECb"
            dt_start (datetime): datetime instance for export start
            dt_end (datetime, optional): datetime instance for export end; default: None
            duration (int, optional): Export duration (dt_start + duration seconds) if dt_end is None; default: 10
            prefer_substream (bool, optional): If True - export substream; default: False
            file_name (str, optional): File name with extension; default: _EXPORTED_VIDEO_NAME_TEMPLATE
            file_path (str, optional): Path to save shot; default: screenshots_folder
            callback (function, optional): Function that calling when export finished
        """

        if "_" not in channel_full_guid:
            raise ValueError(
                "Expected full channel guid, got {}".format(channel_full_guid)
            )

        if not isinstance(dt_start, (datetime, date)):
            raise TypeError("Expected datetime, got {}".format(type(dt_start).__name__))

        if dt_end:
            if not isinstance(dt_end, (datetime, date)):
                raise TypeError(
                    "Expected datetime, got {}".format(type(dt_end).__name__)
                )
        else:
            dt_end = dt_start + timedelta(seconds=duration)

        ts_start = "%.0f" % (time.mktime(dt_start.timetuple()) * 1000000)
        ts_end = "%.0f" % (time.mktime(dt_end.timetuple()) * 1000000)

        channel_guid, server_guid = channel_full_guid.split("_")

        options = {
            "prefer_substream": prefer_substream,
            "postponed_until_ts": self._get_prebuffer(server_guid, dt_end),
        }

        if file_name is None:
            file_name = self._EXPORTED_VIDEO_NAME_TEMPLATE.format(
                name=BaseUtils.get_object_name_by_guid(channel_guid),
                dt_start=dt_start.strftime("%Y.%m.%d %H-%M-%S"),
                dt_end=dt_end.strftime("%Y.%m.%d %H-%M-%S"),
                sub="_sub" if prefer_substream else "",
            )

        if file_path is None:
            file_path = self.export_folder

        exporting_path = os.path.join(file_path, file_name)

        if callback is None:
            callback = BaseUtils.do_nothing

        self._now_exporting = True

        def checker(status):
            self._export_checker(status, callback, exporting_path, channel_full_guid)

        self._host_api.archive_export(
            server_guid,
            channel_guid,
            exporting_path,
            ts_start,
            ts_end,
            options,
            checker,
        )

    def export(
        self,
        channel_full_guid,
        dt_start,
        dt_end=None,
        duration=60,
        prefer_substream=False,
        file_name=None,
        file_path=None,
        callback=None,
    ):
        """Запускает экспорт или добавляет задачу экспорта в очередь.

        После завершения экспорта вызывает ``callback`` функцию
        а также очищает список задач экспорта в панеле управления Trassir.

        Note:
            Задача экспорта добавляется только после завершения предыдущей.

        Tip:
            - Вы можете задать время начала и окончания экспорта
              ``dt_start``, ``dt_end``.
            - Или можно задать время начала экспорта ``dt_start`` и
              продолжительность экспорта (в сек.) ``duration``. По умолчнию
              ``duration=60``.
            - Если ``dt_end=None`` фунция использует ``duration`` для вычисления
              времени окончания ``dt_end = dt_start + timedelta(seconds=duration)``.

        Args:
            channel_full_guid (:obj:`str`): Полный guid канала. Например: ``"CFsuNBzt_pV4ggECb"``
            dt_start (:obj:`datetime.datetime`): :obj:`datetime.datetime` начала экспорта
            dt_end (:obj:`datetime.datetime`, optional): :obj:`datetime.datetime` окончания экспорта.
                По умолчанию :obj:`None`
            duration (:obj:`int`, optional): Продолжительность экспорта, в секундах. Используется если
                ``dt_end is None``. По умолчанию ``60``
            prefer_substream (:obj:`bool`, optional): Если ``True`` - Экспортирует субпоток.
                По умолчанию ``False``
            file_name (:obj:`str`, optional): Имя экспортируемого файла. По умолчанию :obj:`None`
            file_path (:obj:`str`, optional): Путь для экспорта. По умолчанию :obj:`None`
            callback (:obj:`function`, optional): Функция, которая вызывается после завершения экспорта.
                По умолчанию :obj:`None`
        """

        args = (channel_full_guid, dt_start)
        kwargs = {
            "dt_end": dt_end,
            "duration": duration,
            "prefer_substream": prefer_substream,
            "file_name": file_name,
            "file_path": file_path,
            "callback": callback,
        }
        if self._now_exporting:
            self._queue.append((args, kwargs))
        else:
            self._export(*args, **kwargs)


class TemplateError(ScriptError):
    """Raised by Template class"""

    pass


class GUITemplate(py_object):
    """Класс для работы с шаблонами Trassir

    При инициализации находит существующий шаблон по имени или создает новый.

    Note:
        Если вручную создать два или большее шаблона с одинаковыми именами
        данный класс выберет первый попавшийся шаблон с заданным именем.

    Warning:
            Работа с контентом шаблона может привести к падениям трассира.
            Используйте данный класс на свой страх и риск!

    Tip:
        Для понимания, как формируется контент отредактируйте любой шаблон
        вручную и посмотрите что получится в скрытых параметрах трассира
        (активируются нажатием клавиши F4 в настройках трассира)
        `Настройки/Шабоны/<Имя шаблона>/content`

        Ниже предсталвены некоторые примеры шаблонов

        - Вывод одного канала ``S0tE8nfg_Or3QZu4D``
          :obj:`gui7(DEWARP_SETTINGS,zwVj07w0,dewarp(),1,S0tE8nfg_Or3QZu4D)`
        - Вывод шаблона 4х4 с каналами двумя ``Kpid6EC0_Or3QZu4D``, ``ZRtXLrgu_Or3QZu4D``
          :obj:`gui7(DEWARP_SETTINGS,zwVj07w0,dewarp(),4,Kpid6EC0_Or3QZu4D,ZRtXLrgu_Or3QZu4D,,)`
        - Вывод шаблон с минибраузером и ссылкой на https://www.google.com/
          :obj:`minibrowser(0,htmltab(,https://www.google.com/))`

    Args:
        template_name (:obj:`str`): Имя шаблон

    Examples:
        >>> # Создаем шаблон с именем "New template" и получаем его guid
        >>> template = Template("New template")
        >>> template.guid
        'Y2YFAkeZ'


        >>> # Устанавливаем на шаблон минибраузер с ссылкой на google
        >>> template.content = "minibrowser(0,htmltab(,https://www.google.com/))"

        >>> # Изменяем имя шаблона на "Google search"
        >>> template.name = "Google search"

        >>> # Открываем шаблон на первом мониторе
        >>> template.show(1)
    """

    _DEFAULT_TEMPLATE = ""

    def __init__(self, template_name, host_api=host):
        self._name = template_name
        self._host_api = host_api
        self._operator_gui = BaseUtils.get_operator_gui()
        try:
            self._guid, self._template_settings = self._find_template_guid(
                template_name
            )
        except KeyError:
            self._guid, self._template_settings = self._init_template(template_name)

    def _find_template_guid(self, name):
        """Find template guid by name

        Args:
            name (str) : Template name

        Raises:
            KeyError if can't find template
        """
        templates = self._host_api.settings("templates")
        for template_ in templates.ls():
            if name == template_.name:
                return (
                    template_.guid,
                    self._host_api.settings("templates/{}".format(template_.guid)),
                )
        raise KeyError

    def _init_template(self, name):
        """Create new template

        Args:
            name (str) : Template name
        """
        self._host_api.object(self._host_api.settings("").guid + "T").create_template(
            name, self._DEFAULT_TEMPLATE
        )
        try:
            return self._find_template_guid(name)
        except KeyError:
            raise TemplateError("Failed to create template {}".format(self._name))

    @property
    def guid(self):
        """:obj:`str`: Guid шаблона"""
        return self._guid

    @guid.setter
    def guid(self, value):
        raise RuntimeError("You can't change object guid")

    @property
    def name(self):
        """:obj:`str`: Имя шаблона"""
        return self._name

    @name.setter
    def name(self, value):
        if isinstance(value, str):
            self._name = value
            self._template_settings["name"] = value
        else:
            raise TypeError("Expected str, got {}".format(type(value).__name__))

    @property
    def content(self):
        """:obj:`str`: Контент шаблона"""
        return self._template_settings["content"]

    @content.setter
    def content(self, value):
        if isinstance(value, str):
            self._template_settings["content"] = value
        else:
            raise TypeError("Expected str, got {}".format(type(value).__name__))

    def delete(self):
        """Удаляет шаблон"""
        obj = BaseUtils.get_object(self.guid)
        if obj is None:
            raise TemplateError("Template object not found!")

        obj.delete_template()

    def show(self, monitor=1):
        """Открывает шаблон на указаном мониторе

        Args:
            monitor (:obj:`int`, optional): Номер монитора. По умолчанию ``monitor=1``
        """
        self._operator_gui.show(self.guid, monitor)


class TrObject(py_object):
    """Вспомогательный класс для работы с объектами Trassir

    Attributes:
        obj (:obj:`SE_Object`): Объект trassir :obj:`object('{guid}')` или :obj:`None`
        obj_methods (List[:obj:`str`]): Список методов объекта :attr:`TrObject.obj`
        name (:obj:`str`): Имя объекта или его guid
        guid (:obj:`str`): Guid объекта
        full_guid (:obj:`str`): Полный guid :obj:`{guid объекта}_{guid сервера}`
            или :obj:`None`
        type (:obj:`str`): Тип объекта, например :obj:`"RemoteServer"`, :obj:`"Channel"`,
            :obj:`"Grabber"`, :obj:`"User"`, и др.
        path (:obj:`str`): Путь в настройках или :obj:`None`
        parent (:obj:`str`): Guid родительского объекта или :obj:`None`
        server (:obj:`str`): Guid сервера или :obj:`None`
        settings (:obj:`SE_Settings`): Объект настроек ``settings('{path}')`` или :obj:`None`

    Raises:
        TypeError: Если неправильные параметры объекта
        ValueError: Если в имени объекта есть запятые
    """

    obj, name, guid, full_guid, type = None, None, None, None, None
    path, parent, server, settings = None, None, None, None

    def __init__(self, obj, host_api=host):
        self._host_api = host_api

        if isinstance(obj, host_api.ScriptHost.SE_Settings):
            self._load_from_settings(obj)
        elif isinstance(obj, tuple):
            if len(obj) == 4:
                self._load_from_tuple(obj)
            else:
                raise TypeError(
                    "Expected tuple(name, guid, type, parent), got tuple'{}'".format(
                        obj
                    )
                )
        else:
            raise TypeError("Unexpected object type '{}'".format(type(obj).__name__))

    @staticmethod
    def _check_object_name(object_name):
        """Check if object name hasn't got commas

        Args:
            object_name (str):

        Returns:
            str: object_name.strip()

        Raises:
            ValueError: If "," found in object name
        """
        if "," in object_name:
            raise ValueError(
                "Please, rename object '{}' without commas".format(object_name)
            )
        return object_name.strip()

    @staticmethod
    def _parse_server_from_path(path):
        """Parse server guid from full path

        Args:
            path (str): Full Trassir settings path;
                example: '/pV4ggECb/_persons/n68LOBhG' returns 'pV4ggECb'
        """
        try:
            server = path.split("/", 2)[1]
        except IndexError:
            server = None

        return server

    def _find_server_guid_for_object(self, object_guid):
        """Find server guid for object

        Args:
            object_guid (str): Object guid

        Returns:
            str: Server guid if server found
            None: If server not found
        """
        all_objects = {
            obj[1]: {"name": obj[0], "guid": obj[1], "type": obj[2], "parent": obj[3]}
            for obj in self._host_api.objects_list("")
        }

        def get_parent(child_guid):
            child = all_objects.get(child_guid, None)
            if child:
                if child["type"] == "Server":
                    return child["guid"]
                else:
                    return get_parent(child["parent"])
            else:
                return None

        return get_parent(object_guid)

    def _get_object_methods(self):
        """Get object methods"""
        if self.obj:
            return [method for method in dir(self.obj) if not method.startswith("__")]
        else:
            return []

    def _load_from_settings(self, obj):
        """Preparing attributes from SE_Settings object"""
        self.obj = BaseUtils.get_object(obj.guid)
        self.obj_methods = self._get_object_methods()

        try:
            obj_name = obj.name
        except KeyError:
            obj_name = obj.guid

        self.name = self._check_object_name(obj_name)
        self.guid = obj.guid
        self.type = obj.type
        self.path = obj.path
        self.server = self._parse_server_from_path(obj.path)
        self.settings = obj

        if self.server and self.server != self.guid:
            self.full_guid = "{0.guid}_{0.server}".format(self)

    def _load_from_tuple(self, obj):
        """Preparing attributes from tuple object"""
        self.obj = BaseUtils.get_object(obj[1])
        self.obj_methods = self._get_object_methods()
        self.name = self._check_object_name(obj[0])
        self.guid = obj[1]
        self.type = obj[2]
        self.parent = obj[3]
        self.server = self._find_server_guid_for_object(obj[1])

        if self.server and self.server != self.guid:
            self.full_guid = "{0.guid}_{0.server}".format(self)

    def __repr__(self):
        return "TrObject('{}')".format(self.name)

    def __str__(self):
        return "{self.type}: {self.name} ({self.guid})".format(self=self)


class ParameterError(ScriptError):
    """Ошибка в параметрах скрипта"""

    pass


class BasicObject(py_object):
    """"""

    def __init__(self, host_api=host):
        self._host_api = host_api
        self.this_server_guid = BaseUtils.get_server_guid()

    class UniqueNameError(ScriptError):
        """Имя объекта не уникально"""

        pass

    class ObjectsNotFoundError(ScriptError):
        """Не найдены объекты с заданными именами"""

        pass

    def _check_unique_name(self, objects, object_names):
        """Check if all objects name are unique

        Args:
            objects (list): Objects list from _get_objects_from_settings

        Raises:
            UniqueNameError: If some object name is not uniques
        """
        unique_names = []
        for obj in objects:
            if obj.name in object_names:
                if obj.name not in unique_names:
                    unique_names.append(obj.name)
                else:
                    raise self.UniqueNameError(
                        "Найдено несколько объектов {obj.type} с одинаковым именем '{obj.name}'! "
                        "Задайте уникальные имена".format(obj=obj)
                    )

    @staticmethod
    def _objects_str_to_list(objects):
        """Split object names if objects is str and strip each name

        Args:
            objects (str|list): Trassir object names in comma spaced string or list

        Returns:
            list: Stripped Trassir object names

        Raises:
            ScriptError: If object name selected more than once
        """
        if isinstance(objects, str):
            objects = objects.split(",")

        names = []
        for name in objects:
            strip_name = name.strip()
            if strip_name in names:
                raise ParameterError("Объект '{}' выбран несколько раз".format(name))
            names.append(strip_name)

        return names

    def _filter_objects_by_name(self, objects, object_names):
        """Filter object by names

        Args:
            objects (list): TrObject objects list
            object_names (str|list): Trassir object names in comma spaced string or list

        Raises:
            ObjectsNotFoundError: If len(object_name) != len(filtered_object)
        """
        object_names = self._objects_str_to_list(object_names)

        self._check_unique_name(objects, object_names)

        filtered_object = [obj for obj in objects if obj.name in object_names]

        if len(filtered_object) != len(object_names):
            channels_not_found = set(object_names) - set(
                obj.name for obj in filtered_object
            )

            try:
                object_type = objects[0].type
            except IndexError:
                object_type = "Unknown"

            raise self.ObjectsNotFoundError(
                "Не найдены объекты {object_type}: {names}".format(
                    object_type=object_type,
                    names=", ".join(name for name in channels_not_found),
                )
            )

        return filtered_object


class ObjectFromSetting(BasicObject):
    """"""

    def __init__(self):
        super(ObjectFromSetting, self).__init__()

    def _load_objects_from_settings(self, settings_path, obj_type, sub_condition=None):
        """Load objects from Trassir settings

        Args:
            settings_path (:obj:`str`): Trassir settings path. Example ``"scripts"``.
                Click F4 in the Trassir settings window to show hidden parameters.
            obj_type (:obj:`str` | :obj:`list`): Loading object type. Example ``"EmailAccount"``
            sub_condition (function, optional): Function with SE_Settings as argument to filter objects

        Returns:
            list: TrObject objects list
                Example [TrObject(...), TrObject(...), ...]
        """
        try:
            settings = self._host_api.settings(settings_path)
        except KeyError:
            settings = None

        objects = []
        if settings is not None:
            if isinstance(obj_type, str):
                obj_type = [obj_type]

            if sub_condition is None:
                sub_condition = BaseUtils.do_nothing

            for obj in settings.ls():
                if obj.type in obj_type:
                    if sub_condition(obj):
                        objects.append(TrObject(obj))
        return objects

    def _get_objects_from_settings(
        self,
        settings_path,
        object_type,
        object_names=None,
        server_guid=None,
        ban_empty_result=False,
        sub_condition=None,
    ):
        """Check if objects exists and returns list from _load_objects_from_settings

        Note:
             If object_names is not None - checking if all object names are unique

        Args:
            settings_path (:obj:`str`): Trassir settings path. Example ``"scripts"``.
                Click F4 in the Trassir settings window to show hidden parameters.
            object_type (:obj:`str` | :obj:`list`): Loading object type. Example ``"EmailAccount"``
            object_names (:obj:`str` | :obj:`list`, optional): Comma spaced string or
                list of object names. Default :obj:`None`
            server_guid (:obj:`str` | :obj:`list`, optional): Server guid. Default :obj:`None`
            ban_empty_result (:obj:`bool`, optional): If True - raise error if no one object found
            sub_condition (:obj:`func`, optional) : Function with SE_Settings as argument to filter objects

        Returns:
            list: Trassir list from _load_objects_from_settings

        Raises:
            ObjectsNotFoundError: If can't find channel
        """
        if object_names == "":
            raise ParameterError("'{}' не выбраны".format(object_type))

        if server_guid is None:
            server_guid = self.this_server_guid

        if isinstance(server_guid, str):
            server_guid = [server_guid]

        objects = []

        for guid in server_guid:
            objects += self._load_objects_from_settings(
                settings_path.format(server_guid=guid), object_type, sub_condition
            )

        if ban_empty_result and not objects:
            raise self.ObjectsNotFoundError(
                "Не найдено ниодного объекта '{}'".format(object_type)
            )

        if object_names is None:
            return objects

        else:
            return self._filter_objects_by_name(objects, object_names)


class Servers(ObjectFromSetting):
    """Класс для работы с серверами

    Examples:
        >>> srvs = Servers()
        >>> local_srv = srvs.get_local()
        [TrObject('Клиент')]
        >>> # Првоерим "Здоровье" локального сервера
        >>> local_srv[0].obj.state("server_health")
        'Health Problem'
    """

    def __init__(self):
        super(Servers, self).__init__()

    def get_local(self):
        """Возвращает локальный сервер (на котором запущен скрипт)

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._load_objects_from_settings("/", ["Client", "LocalServer"])

    def get_remote(self):
        """Возвращает список удаленных серверов

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._load_objects_from_settings("/", "RemoteServer")

    def get_all(self):
        """Возвращает список всех доступных серверов

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._load_objects_from_settings(
            "/", ["Client", "LocalServer", "RemoteServer"]
        )


class Channels(ObjectFromSetting):
    """Класс для работы с каналами

    See Also:
        `Каналы - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-channels-folder.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> channels = Channels()
        >>> selected_channels = channels.get_enabled("AC-D2121IR3W 2,AC-D9141IR2 1")
        >>> selected_channels
        [TrObject('AC-D2121IR3W 2'), TrObject('AC-D9141IR2 1')]
        >>>
        >>> # Включим ручную запись на выбранных каналах
        >>> for channel in selected_channels:
        >>>     channel.obj.manual_record_start()
        >>>
        >>> # Или добавим к имени канала его guid
        >>> for channel in selected_channels:
        >>>     channel.settings["name"] += " ({})".format(channel.guid)
    """

    def __init__(self, server_guid=None):
        super(Channels, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных каналов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            not_zombie = 1 - sett["archive_zombie_flag"]
            if not_zombie:
                try:
                    return self._host_api.settings(sett.cd("info")["grabber_path"])[
                        "grabber_enabled"
                    ]
                except KeyError:
                    return 0
            return 0

        return self._get_objects_from_settings(
            "/{server_guid}/channels",
            "Channel",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных каналов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            zombie = sett["archive_zombie_flag"]
            if not zombie:
                try:
                    return (
                        1
                        - self._host_api.settings(sett.cd("info")["grabber_path"])[
                            "grabber_enabled"
                        ]
                    )
                except KeyError:
                    return 1
            return 1

        return self._get_objects_from_settings(
            "/{server_guid}/channels",
            "Channel",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех каналов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/channels",
            "Channel",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Devices(ObjectFromSetting):
    """Класс для работы с ip устройствами

    See Also:
        `IP-устройства - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-ip-cameras-folder.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> devices = Devices()
        >>> enabled_devices = devices.get_enabled()
        >>> enabled_devices
        [TrObject('AC-D2121IR3W'), TrObject('AC-D5123IR32'), ...]
        >>>
        >>> # Перезагрузим все устройства
        >>> for dev in enabled_devices:
        >>>     dev.settings["reboot"] = 1
    """

    def __init__(self, server_guid=None):
        super(Devices, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных устройств

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["grabber_enabled"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/ip_cameras",
            "Grabber",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных устройств

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["grabber_enabled"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/ip_cameras",
            "Grabber",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех устройств

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/ip_cameras",
            "Grabber",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Scripts(ObjectFromSetting):
    """Класс для работы со скриптами

    See Also:
        `Скрипты - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-script-feature.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> scripts = Scripts()
        >>> all_scripts = scripts.get_all()
        >>> all_scripts
        [TrObject('Новый скрипт'), TrObject('HDD Health Monitor'), TrObject('Password Reminder')]
        >>>
        >>> # Отключим все скрипты
        >>> for script in all_scripts:
        >>>     script.settings["enable"] = 0
    """

    def __init__(self, server_guid=None):
        super(Scripts, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных скриптов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["enable"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Script",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных скриптов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["enable"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Script",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех скриптов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Script",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

class StockScripts(ObjectFromSetting):
    """Класс для работы со встроенными скриптами

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> stock_scripts = StockScripts()
        >>> all_scripts = stock_scripts.get_all()
        >>> all_scripts
        [TrObject('MegaRAID Monitor')]
        >>>
        >>> # Отключим все скрипты
        >>> for script in all_scripts:
        >>>     script.settings["enable"] = 0
    """

    def __init__(self, server_guid=None):
        super(StockScripts, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных скриптов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["enable"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "StockScript",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных скриптов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["enable"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "StockScript",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех скриптов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "StockScript",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Rules(ObjectFromSetting):
    """Класс для работы с правилами

    See Also:
        `Правила - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-rule.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> rules = Rules()
        >>> all_rules = rules.get_all()
        >>> all_rules
        [TrObject('!Rule'), TrObject('NEW RULE'), TrObject('Новое правило')]
        >>>
        >>> # Отключим все правила
        >>> for rule in all_rules:
        >>>     rule.settings["enable"] = 0
    """

    def __init__(self, server_guid=None):
        super(Rules, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных правил

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["enable"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Rule",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных правил

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["enable"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Rule",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех правил

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен. По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Rule",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Schedules(ObjectFromSetting):
    """Класс для работы с расписаниями

    See Also:
        `Расписания - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-schedule.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> schedules = Schedules()
        >>> my_schedule = schedules.get_enabled("!Schedule")[0]
        >>> my_schedule.obj.state("color")
        'Red'
    """

    def __init__(self, server_guid=None):
        super(Schedules, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    @BaseUtils.run_as_thread
    def on_load(self, schedule_name, callback, tries=5):
        """on_load(schedule_name, callback, tries=5)
        Вызывает `callback` после загрузки расписания

        Note:
            При загрузке сервера, объект расписания становится не сразу доступен.
            Данный метод помогает предотвратить данную ошибку.

        Args:
            schedule_name (:obj:`str`): Имя расписания
            callback (:obj:`function`): Функция, которая вызывается после
                загрузки расписания.
            tries (:obj:`int`, optional): Кол-во попыток загрузки расписания.
                Каждая попытка производится с интервалом 1 с. По умолчанию :obj:`5`

        Examples
            >>> schedule = None
            >>> # noinspection PyGlobalUndefined,PyUnresolvedReferences
            >>> def on_schedule_loaded(schedule_obj):
            >>>     global schedule
            >>>     schedule = schedule_obj
            >>>
            >>>     message("Schedule '{obj.name}' ({obj.guid}) loaded".format(obj=schedule))
            >>>     schedule.activate_on_state_changes(lambda: alert(schedule.state("color")))
            >>>
            >>> Schedules().on_load("Unnamed Schedule", on_schedule_loaded)
        """
        if not schedule_name:
            raise ParameterError("Empty schedule name")

        tmp_server_guid = self.server_guid
        self.server_guid = BaseUtils.get_server_guid()

        while tries:
            obj = self.get_enabled(schedule_name)[0].obj

            if obj is None:
                tries -= 1
                time.sleep(1)
            else:
                self.server_guid = tmp_server_guid
                self._host_api.timeout(1, lambda: callback(obj))
                break
        else:
            self.server_guid = tmp_server_guid
            raise ScriptError(
                "Ошибка получения объекта расписания '{}'".format(schedule_name)
            )

    def get_enabled(self, names=None):
        """Возвращает список активных расписаний

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["enable"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Schedule",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных расписаний

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["enable"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Schedule",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех расписаний

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Schedule",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class TemplateLoops(ObjectFromSetting):
    """Класс для работы с циклическими просмотрами шаблонов

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> tmplate_loops = TemplateLoops()
        >>> tmplate_loops.get_all()
        [TrObject('Новый циклический просмотр')]
    """

    def __init__(self, server_guid=None):
        super(TemplateLoops, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных циклических просмотров шаблонов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["enable"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "TemplateLoop",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных циклических просмотров шаблонов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["enable"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "TemplateLoop",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех циклических просмотров шаблонов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "TemplateLoop",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class EmailAccounts(ObjectFromSetting):
    """Класс для работы с E-Mail аккаунтами

    See Also:
        `Добавление учетной записи e-mail - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-email-account.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> email_accounts = EmailAccounts()
        >>> email_accounts.get_all()
        [TrObject('Новая учетная запись e-mail'), TrObject('MyAccount')]
    """

    def __init__(self, server_guid=None):
        super(EmailAccounts, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_all(self, names=None):
        """Возвращает список всех E-Mail аккаунтов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "EmailAccount",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class NetworkNodes(ObjectFromSetting):
    """Класс для работы с сетевыми подключениями

    See Also:
        `Сеть - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-network-folder.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> network_nodes = NetworkNodes("client")
        >>> network_nodes.get_enabled()
        [TrObject('QuattroStationPro (172.20.0.101)'), TrObject('NSK-HD-01 (127.0.0.1)')]
    """

    def __init__(self, server_guid=None):
        super(NetworkNodes, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных сетевых подключений

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["should_be_connected"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/network",
            "NetworkNode",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных сетевых подключений

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["should_be_connected"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/network",
            "NetworkNode",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех сетевых подключений

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/network",
            "NetworkNode",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class PosTerminals(ObjectFromSetting):
    """Класс для работы с POS Терминалами

    See Also:
        `Настройка POS-терминалов - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-pos-terminals-folder.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> pos_terminals = PosTerminals()
        >>> pos_terminals.get_disabled()
        [TrObject('Касса (1)')]
    """

    def __init__(self, server_guid=None):
        super(PosTerminals, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных POS Терминалов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["pos_enable"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/pos_folder2/terminals",
            "PosTerminal",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных POS Терминалов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["pos_enable"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/pos_folder2/terminals",
            "PosTerminal",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех POS Терминалов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/pos_folder2/terminals",
            "PosTerminal",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Users(ObjectFromSetting):
    """Класс для работы с пользователями и их группами.

    See Also:
        `Пользователи - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-users-folder.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> users = Users()
        >>> users.get_groups()
        [TrObject('TEST')]
    """

    def __init__(self, server_guid=None):
        super(Users, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_groups(self, names=None):
        """Возвращает список групп пользователей

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_settings(
            "/{server_guid}/users",
            "Group",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_users(self, names=None):
        """Возвращает список пользователей

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_settings(
            "/{server_guid}/users",
            "User",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_users_by_groups(self, group_names):
        """Возвращает список пользователей из указанных групп

        Args:
            group_names (:obj:`str` | :obj:`list`): :obj:`str` - имена групп,
                разделенные запятыми или :obj:`list` - список имен.

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        if group_names is None:
            groups = [""]
        else:
            groups = [group.guid for group in self.get_groups(names=group_names)]

        def sub_condition(sett):
            return sett["group"] in groups

        return self._get_objects_from_settings(
            "/{server_guid}/users",
            "User",
            object_names=None,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )


class Templates(ObjectFromSetting):
    """Класс для работы с существующими шаблонами.

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> templates = Templates(BaseUtils.get_server_guid())
        >>> templates.get_all()
        [TrObject('Parking'), TrObject('FR'), TrObject('AT'), TrObject('AD+')]
    """

    def __init__(self, server_guid=None):
        super(Templates, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_all(self, names=None):
        """Возвращает список шаблонов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_settings(
            "/{server_guid}/templates",
            "Template",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Persons(ObjectFromSetting):
    """Класс для работы с персонами и их папками.

    See Also:
        `Персоны - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-persons-folder.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
            >>> persons = Persons()
            >>> persons.get_folders()
            [TrObject('Мошенники'), TrObject('DSSL'), TrObject('persons')]
            >>> persons.get_persons()
            [
                {
                    'name': 'Leonardo',
                    'guid': 'cJuJYAha',
                    'gender': 0,
                    'birth_date': '1980-01-01',
                    'comment': 'Comment',
                    'contact_info': 'Contact info',
                    'folder_guid': 'n68LOBhG',
                    'image': <image, str>,
                    'image_guid': 'gBHZ2vpz',
                    'effective_rights': 0,
                },
                ...
            ]
            >>> persons.get_person_by_guid("cJuJYAha")
            {
                'name': 'Leonardo',
                'guid': 'cJuJYAha',
                'gender': 0,
                'birth_date': '1980-01-01',
                'comment': 'Comment',
                'contact_info': 'Contact info',
                'folder_guid': 'n68LOBhG',
                'image': <image, str>,
                'image_guid': 'gBHZ2vpz',
                'effective_rights': 0,
            }
    """

    _PERSONS_UPDATE_TIMEOUT = 10 * 60  # Time in sec between update _persons dict

    def __init__(self, server_guid=None):
        super(Persons, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        if isinstance(server_guid, str):
            server_guid = [server_guid]

        self.server_guid = server_guid

        self._persons = None

    def _update_persons_dict(self, timeout=10):
        """Updating self._persons dict"""
        persons = self.get_persons(timeout=timeout)
        by_guid, by_name = {}, {}
        for person in persons:
            by_guid[person["guid"]] = person
            by_name[person["name"]] = person

        self._persons = {
            "update_ts": int(time.time()),
            "by_guid": by_guid,
            "by_name": by_name,
        }

    def _check_loaded_persons(self, timeout=10):
        """This method check if self._persons dict is need to be updated"""
        ts_now = int(time.time())

        if (
            self._persons is None
            or (ts_now - self._persons["update_ts"]) > self._PERSONS_UPDATE_TIMEOUT
        ):
            self._update_persons_dict(timeout=timeout)

    def get_folders(self, names=None):
        """Возвращает список папок персон

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        try:
            folders = self._get_objects_from_settings(
                "/{server_guid}/persons",
                "PersonsSubFolder",
                object_names=names,
                server_guid=self.server_guid,
            )

            if names is None or "persons" in names:
                for guid in self.server_guid:
                    try:
                        settings = self._host_api.settings("/{}/persons".format(guid))
                    except KeyError:
                        continue

                    folders.append(TrObject(settings))

        except self.ObjectsNotFoundError as err:
            folders = []
            names = self._objects_str_to_list(names)

            if names is None or "persons" in names:
                for guid in self.server_guid:
                    try:
                        settings = self._host_api.settings("/{}/persons".format(guid))
                    except KeyError:
                        continue

                    folders.append(TrObject(settings))

            if not folders:
                raise err

        return folders

    def get_persons(self, folder_names=None, timeout=10):
        """Возвращает список персон

        Note:
            Данный метод работает только с локальной БД.

        Args:
            folder_names (:obj:`str` | List[:obj:`str`], optional): :obj:`str` -
                названия папок персон, разделенные запятыми или :obj:`list` -
                список папок персон. По умолчанию :obj:`None`
            timeout (:obj:`int`, optional): Макс. время запроса к БД.
                По умолчанию ``timeout=10``

        Returns:
            List[:obj:`dict`]: Список персон - если персоны найдены

        Raises:
            EnvironmentError: Если произошла ошибка при запросе в БД.
            TrassirError: Если в данной сборке Trassir нет метода :obj:`host.service_persons_get`
        """
        tmp_server_guid = self.server_guid[:]
        self.server_guid = [self.this_server_guid]
        persons_folders = self.get_folders(names=folder_names)
        self.server_guid = tmp_server_guid[:]

        try:
            persons = self._host_api.service_persons_get(
                [folder.guid for folder in persons_folders], True, 0, 0, timeout
            )
        except AttributeError:
            raise TrassirError(
                "Данный функционал не поддерживается вашей сборкой Trassir. "
                "Попробуйте обновить ПО."
            )

        if isinstance(persons, str):
            raise EnvironmentError(persons)

        return persons

    def get_person_by_guid(self, person_guid, timeout=10):
        """Возвращает информацию о персоне по его guid

        Note:
            Для уменьшения кол-ва запросов к БД - метод создает локальную
            копию всех персон при первом запросе и обновляет ее вместе
            с последующими запросами не чаще чем 1 раз в 10 минут.

        Args:
            person_guid (:obj:`str`): Guid персоны
            timeout (:obj:`int`, optional): Макс. время запроса к БД.
                По умолчанию ``timeout=10``

        Returns:
            :obj:`dict`: Даные о персоне или :obj:`None` если персона не найдена
        """
        self._check_loaded_persons(timeout=timeout)
        return self._persons["by_guid"].get(person_guid)

    def get_person_by_name(self, person_name, timeout=10):
        """Возвращает информацию о персоне по его имени

        Note:
            Для уменьшения кол-ва запросов к БД - метод создает локальную
            копию всех персон при первом запросе и обновляет ее вместе
            с последующими запросами не чаще чем 1 раз в 10 минут.

        Args:
            person_name (:obj:`str`): Имя персоны
            timeout (:obj:`int`, optional): Макс. время запроса к БД.
                По умолчанию ``timeout=10``

        Returns:
            :obj:`dict`: Даные о персоне или :obj:`None` если персона не найдена
        """
        self._check_loaded_persons(timeout=timeout)
        return self._persons["by_name"].get(person_name)


class ObjectFromList(BasicObject):
    """"""

    def __init__(self):
        super(ObjectFromList, self).__init__()

    def _load_objects_from_list(self, obj_type, sub_condition=None):
        """Load objects from Trassir objects_list method

        Args:
            obj_type (str | list): Loading object type; example: "EmailAccount"
            sub_condition (function, optional): Function with SE_Settings as argument to filter objects

        Returns:
            list: TrObject objects list
                Example [TrObject(...), TrObject(...), ...]
        """
        if sub_condition is None:
            sub_condition = BaseUtils.do_nothing

        objects = []
        for obj in self._host_api.objects_list(obj_type):
            if sub_condition(obj):
                objects.append(TrObject(obj))

        return objects

    def _get_objects_from_list(
        self,
        object_type,
        object_names=None,
        server_guid=None,
        ban_empty_result=False,
        sub_condition=None,
    ):
        """Check if objects exists and returns list from _load_objects_from_settings

        Note:
             If object_names is not None - checking if all object names are unique

        Args:
            object_type (str|list): Loading object type; example: "EmailAccount"
            object_names (str|list, optional): Comma spaced string or list of object names; default: None
            server_guid (str|list, optional): Server guids; default: None
            ban_empty_result (bool, optional): If True - raise ObjectsNotFoundError if no one object found
            sub_condition (func, optional) : Function with SE_Settings as argument to filter objects

        Returns:
            list: Trassir list from _load_objects_from_settings

        Raises:
            ObjectsNotFoundError: If can't find channel
        """
        if object_names == "":
            raise ParameterError("'{}' не выбраны".format(object_type))

        if server_guid is None:
            server_guid = self.this_server_guid
        else:
            if isinstance(server_guid, str):
                server_guid = [server_guid]

        objects = self._load_objects_from_list(object_type, sub_condition)

        objects = [obj for obj in objects if obj.server in server_guid]

        if ban_empty_result and not objects:
            raise self.ObjectsNotFoundError(
                "Не найдено ниодного объекта '{}'".format(object_type)
            )

        if object_names is None:
            return objects

        else:
            return self._filter_objects_by_name(objects, object_names)

    def _zone_type(self, zone_obj):
        """Возвращает тип зоны для объекта

        Args:
            zone_obj (:obj:`SE_Object`): Объект trassir ``object('{guid}')``

        Returns:
            :obj:`str`: Тип объекта
            :obj:`None`: Если тип зоны неизвестен
        """

        if not isinstance(zone_obj, self._host_api.ScriptHost.SE_Object):
            raise TypeError(
                "Expected SE_Object, got '{}'".format(type(zone_obj).__name__)
            )

        try:
            guid = zone_obj.guid
            channel, server = zone_obj.associated_channel.split("_")
        except (AttributeError, ValueError):
            return None

        try:
            zones_dir = self._host_api.settings(
                "/{}/channels/{}/people_zones".format(server, channel)
            )
            for i in xrange(16):
                if zones_dir["zone%02d_guid" % i] == guid:
                    func_type = zones_dir["zone%02d_func_type" % i]
                    if isinstance(func_type, int):
                        return (
                            ["Queue", "Workplace"][func_type]
                            if func_type in range(2)
                            else "Queue"
                        )
                    else:
                        return func_type
        except KeyError:
            "not a queue or workplace"

        try:
            zones_dir = self._host_api.settings(
                "/{}/channels/{}/workplace_zones".format(server, channel)
            )
            for i in xrange(16):
                if zones_dir["zone%02d_guid" % i] == guid:
                    return "Workplace"
        except KeyError:
            "not a workplace"

        try:
            zones_dir = settings("/%s/channels/%s/deep_people" % (server, channel))
            for i in xrange(16):
                if zones_dir["zone%02d_guid" % i] == guid:
                    if zones_dir["zone%02d_type" % i] in ["border", "border_swapped"]:
                        return "Border"
                    else:
                        return "Queue"
        except KeyError:
            "not a deep people queue"


class GPIO(ObjectFromList):
    """Класс для работы с тревожными входами/выходами

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> gpio = GPIO()
        >>> gpio_door = gpio.get_inputs("Door")[0]
        >>> gpio_door.obj.state("gpio_input_level")
        'Input Low (Normal High)'
        >>> gpio_light = gpio.get_outputs("Light")[0]
        >>> gpio_light.obj.set_output_high()
    """

    def __init__(self, server_guid=None):
        super(GPIO, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_inputs(self, names=None):
        """Возвращает список тревожных входов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "GPIO Input",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_outputs(self, names=None):
        """Возвращает список тревожных выходов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "GPIO Output",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Zones(ObjectFromList):
    """Класс для работы с зонами

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> zones = Zones()
        >>> zones.get_queues("Касса 1")[0].obj.state("zone_queue")
        '5+'
    """

    def __init__(self, server_guid=None):
        super(Zones, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_people(self, names=None):
        """Возвращает список PeopleZones

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "PeopleZone",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_simt(self, names=None):
        """Возвращает список зон SIMT

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "SIMT Zone",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_workplaces(self, names=None):
        """Возвращает список рабочих зон

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        people_zones = self.get_people(names=names)

        return [
            zone
            for zone in people_zones
            if self._zone_type(zone.obj) in ["Workplace", "Рабочее место"]
        ]

    def get_queues(self, names=None):
        """Возвращает список зон очередей

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        people_zones = self.get_people(names=names)

        return [
            zone
            for zone in people_zones
            if self._zone_type(zone.obj) in ["", "Queue", "Очередь"]
        ]

    def get_shelves(self, names=None):
        """Возвращает список зон полок

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "Shelf",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Borders(ObjectFromList):
    """Класс для работы с линиями пересечения

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> borders = Borders()
        >>> borders.get_simt()
        [TrObject('DBOP')]
        >>> borders.get_all()
        [TrObject('Вход в офис'), TrObject('DBOP')]
    """

    def __init__(self, server_guid=None):
        super(Borders, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_head(self, names=None):
        """Возвращает список HeadBorders

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "HeadBorder",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_people(self, names=None):
        """Возвращает список PeopleBorders

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "PeopleBorder",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_simt(self, names=None):
        """Возвращает список SIMT Borders

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "SIMT Border",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_deep_people(self, names=None):
        """Возвращает список DeepPeopleBorders

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        people_zones = self._get_objects_from_list(
            "PeopleZone",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

        return [zone for zone in people_zones if self._zone_type(zone.obj) == "Border"]

    def get_all(self, names=None):
        """Возвращает список всех линий пересечения

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        all_borders = (
            self.get_head()
            + self.get_people()
            + self.get_simt()
            + self.get_deep_people()
        )

        if names is None:
            return all_borders
        else:
            return self._filter_objects_by_name(all_borders, names)


class Sigur(ObjectFromList):
    """Класс для работы со СКУД Sigur

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.
    """

    def __init__(self, server_guid=None):
        super(Sigur, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_access_points(self, names=None):
        """Возвращает список точек доступа

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "Access Point",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class TrassirError(ScriptError):
    """Exception if bad trassir version"""

    pass


class PokaYoke(py_object):
    """Класс для защиты от дурака

    Позволяет блокировать запуск скрипта на ПО, где это
    не предусмотрено (например, на клиенте или TOS).
    А также производить некоторые другие проверки.
    """

    _EMAIL_REGEXP = re.compile(
        r"[^@]+@[^@]+\.[^@]+"
    )  # Default regex to check emails list
    _PHONE_REGEXP = re.compile(r"[^\d,;]")  # Default regex to check phone list

    _host_api = host

    def __init__(self):
        pass

    @staticmethod
    def ban_tos():
        """Блокирует запуск скрипта на `Trassir OS`

        Raises:
            OSError: Если скрипт запускается на `Trassir OS`

        Examples:
            >>> PokaYoke.ban_tos()
            OSError: Скрипт недоступен для TrassirOS
        """
        if os.name != "nt":
            raise OSError("Скрипт недоступен для TrassirOS")

    @staticmethod
    def ban_win():
        """Блокирует запуск скрипта на `Windows OS`

        Raises:
            OSError: Если скрипт запускается на `Windows OS`

        Examples:
            >>> PokaYoke.ban_win()
            OSError: Скрипт недоступен для WindowsOS
        """
        if os.name == "nt":
            raise OSError("Скрипт недоступен для WindowsOS")

    @staticmethod
    def ban_client():
        """Блокирует запуск скрипта на `Trassir Client`

        Raises:
            TrassirError: Если скрипт запускается на `Trassir Client`

        Examples:
            >>> PokaYoke.ban_client()
            TrassirError: Скрипт недоступен для клиентской версии Trassir
        """
        if BaseUtils.get_server_guid() == "client":
            raise TrassirError("Скрипт недоступен для клиентской версии Trassir")

    @classmethod
    def ban_daemon(cls):
        """Блокирует запуск скрипта на сервре Trassir, который запущен как служба

        Raises:
            TrassirError: Если скрипт запускается на сервре Trassir,
                который запущен как служба

        Examples:
            >>> PokaYoke.ban_daemon()
            TrassirError: Скрипт недоступен для Trassir запущенным как служба
        """
        if cls._host_api.settings("system_wide_options")["daemon"]:
            raise TrassirError("Скрипт недоступен для Trassir запущенным как служба")

    @staticmethod
    def check_email_account(account_name):
        """Проверяет существование E-Mail аккаунта

        Args:
            account_name (:obj:`str`): Имя E-Mail аккаунта

        Returns:
             List[:class:`TrObject`]: Список объектов

        Raises:
            ParameterError: Если аккаунт не выбран
            ObjectsNotFoundError: Если аккаунт не найден

        Examples:
            >>> PokaYoke.check_email_account("")
            ParameterError: 'EmailAccount' не выбраны
            >>> PokaYoke.check_email_account("YourAccount")
            ObjectsNotFoundError: Не найдены объекты EmailAccount: YourAccount
            >>> PokaYoke.check_email_account("MyAccount")
            [TrObject('MyAccount')]
        """
        e_accounts = EmailAccounts(BaseUtils.get_server_guid())
        return e_accounts.get_all(account_name)

    @classmethod
    def parse_emails(cls, mailing_list, regex=None):
        """Парсит email дреса из строки

        Каждый email проверяется с помощью regex ``r"[^@]+@[^@]+\.[^@]+"``.

        Args:
            mailing_list (:obj:`str`): Список email адресов, разделенный запятыми
            regex (:obj:`SRE_Pattern`, optional): Новый regex шаблон для проверки.
                По умолчанию :obj:`None`

        Returns:
            List[:obj:`str`]: Список адресов

        Raises:
            ParameterError: Если найден невалидный email

        Examples:
            >>> PokaYoke.parse_emails("a.trubilil!dssl.ru,support@dssl.ru")
            ParameterError: Email 'a.trubilil!dssl.ru' is not valid!
            >>>
            >>> PokaYoke.parse_emails("a.trubilil@dssl.ru,support@dssl.ru")
            ['a.trubilil@dssl.ru', 'support@dssl.ru']
        """
        mailing_list = mailing_list.replace(" ", "")

        if not mailing_list:
            raise ParameterError("No emails to send!")

        if regex is None:
            regex = cls._EMAIL_REGEXP
        else:
            if not isinstance(regex, cls._EMAIL_REGEXP.__class__):
                raise TypeError(
                    "Expected re.compile, got '{}'".format(type(regex).__name__)
                )

        if isinstance(mailing_list, str):
            mailing_list = mailing_list.split(",")

        mailing_list = [mail.strip() for mail in mailing_list]

        for mail in mailing_list:
            if not regex.match(mail):
                raise ParameterError("Email '{}' is not valid!".format(mail))

        return mailing_list

    @classmethod
    def check_phones(cls, phones, regex=None):
        """Проверяет строку на валидность телефонных номеров

        Строка проверяется с помощью regex ``r"[^\d,;]"``.

        Args:
            phones (:obj:`str`): Список телефонов, разделенный запятыми или точкой с запятой
            regex (:obj:`SRE_Pattern`, optional): Новый regex шаблон для проверки.
                По умолчанию :obj:`None`

        Returns:
            :obj:`str`: Список номеров телефона

        Raises:
            ParameterError: Если найден невалидный номер телефона

        Examples:
            >>> PokaYoke.check_phones("79999999999,78888888888A")
            ParameterError: Bad chars in phone list: `A`
            >>>
            >>> PokaYoke.check_phones("a.trubilil@dssl.ru,support@dssl.ru")
            '79999999999,78888888888'
        """
        phones = phones.replace(" ", "")

        if not phones:
            raise ParameterError("No phones!")

        if regex is None:
            regex = cls._PHONE_REGEXP
        else:
            if not isinstance(regex, cls._PHONE_REGEXP.__class__):
                raise TypeError(
                    "Expected re.compile, got '{}'".format(type(regex).__name__)
                )
        bad_chars = regex.findall(phones)
        if bad_chars:
            raise ParameterError(
                "Bad chars in phone list: `{}`".format(", ".join(bad_chars))
            )

        return phones


class SenderError(Exception):
    """Base Sender Exception"""

    pass


class Sender(py_object):
    _HTML_IMG_TEMPLATE = """<img src="data:image/png;base64,{img}" {attr}>"""

    def __init__(self, host_api=host):
        self._host_api = host_api

    @staticmethod
    def _get_base64(image_path):
        """Returns base64 image

        Args:
            image_path (str): Image full path
        """
        image_path = BaseUtils.win_encode_path(image_path)
        if os.path.isfile(image_path):
            with open(image_path, "rb") as image_file:
                return base64.b64encode(image_file.read())

    @staticmethod
    def _get_html_img(image_base64, **kwargs):
        """Returns html img

        Args:
            image_base64 (str): Base64 image
        """
        return BaseUtils.base64_to_html_img(image_base64, **kwargs)

    def text(self, text):
        """Send text

        Args:
            text (str): Text message
        """
        pass

    def image(self, image_path, text=""):
        """Send image and optional text

        Args:
            image_path (str): Image path
            text (str, optional): Text message; default: ""
        """
        pass

    def files(self, file_paths, text=""):
        """Send file or list of files

        Args:
            file_paths (str|list): File path or list of paths
            text (str, optional): Text message; default: ""
        """
        pass


class PopupSender(Sender):
    """Класс для показа всплывающих окон в правом нижнем углу экрана

    Args:
        width (:obj:`int`, optional): Ширина изображения, px.
            По умолчанию :obj:`width=400`

    Examples:
        >>> sender = PopupSender(300)
        >>> sender.text("Hello World!")

            .. image:: images/popup_sender.text.png

        >>> sender.image(r"manual\en\cloud-devices-16.png")

            .. image:: images/popup_sender.image.png
    """

    def __init__(self, width=400):
        super(PopupSender, self).__init__()
        self._attr = {"width": width}

    def text(self, text, popup_type="message"):
        """Показывает текст во всплывающем окне

        Вызывает один из методов Trassir :obj:`host.alert`,
        :obj:`host.message` или :obj:`host.error` с текстом

        Args:
            text (:obj:`str`): Текст сообщения
            popup_type (:obj:`"message"` | :obj:`"alert"` | :obj:`"error"`, optional)
                Тип сообщения. По умолчанию :obj:`"message"`
        """

        if popup_type == "alert":
            self._host_api.alert(text)
        elif popup_type == "error":
            self._host_api.error(text)
        else:
            self._host_api.message(text)

    def image(self, image_path, text="", popup_type=None):
        """Показывает изображение во всплывающем окне

        Args:
            image_path (:obj:`str`): Полный путь до изображения
            text (:obj:`str`, optional): Текст сообщения. По умолчанию :obj:`""`
            popup_type (:obj:`"message"` | :obj:`"alert"` | :obj:`"error"`, optional)
                Тип сообщения. По умолчанию :obj:`"message"`
        """
        image_base64 = self._get_base64(image_path)

        if not image_base64:
            self.text("<b>File not found</b><br>{}".format(image_path), popup_type)
            return

        html_image = BaseUtils.base64_to_html_img(image_base64, **self._attr)

        html = "{image}"
        if text:
            html = "<b>{text}</b><br>{image}"

        self.text(html.format(text=text, image=html_image), popup_type)


class PopupWithBtnSender(Sender):
    """Класс для показа всплывающих окон с кнопкой `Оk`

    Note:
        | Для закрытия окна необходимо нажать кнопку `Ok` в течении 60 сек.
        | После 60 сек окно закрывается автоматически.

    Args:
        width (:obj:`int`, optional): Ширина изображения, px.
            По умолчанию :obj:`width=800`

    Examples:
        >>> sender = PopupWithBtnSender()
        >>> sender.text("Hello World!")

            .. image:: images/popup_with_btn_sender.text.png

        >>> sender.image(r"manual\en\cloud-devices-16.png")

            .. image:: images/popup_with_btn_sender.image.png
    """

    def __init__(self, width=800):
        super(PopupWithBtnSender, self).__init__()
        self._attr = {"width": width}

    def text(self, text):
        """Показывает текст во всплывающем окне

        Вызывает метод Trassir :obj:`host.question` с текстом

        Args:
            text (:obj:`str`): Текст сообщения
        """
        self._host_api.question(
            "<pre>{}</pre>".format(text), "Ok", BaseUtils.do_nothing
        )

    def image(self, image_path, text=""):
        """Показывает изображение во всплывающем окне

        Args:
            image_path (:obj:`str`): Полный путь до изображения
            text (:obj:`str`, optional): Текст сообщения. По умолчанию :obj:`""`
        """
        image_base64 = self._get_base64(image_path)

        if not image_base64:
            self.text("<b>File not found</b><br>{}".format(image_path))
            return

        html_image = BaseUtils.base64_to_html_img(image_base64, **self._attr)

        html = "{image}"
        if text:
            html = "<b>{text}</b><br>{image}"

        self.text(html.format(text=text, image=html_image))


class EmailSender(Sender):
    """Класс для отправки уведомлений, изображений и файлов на почту

    Note:
        По умолчанию тема сообщений соответствует шаблону
        ``{server_name} -> {script_name}``

    Tip:
        При отправке изображения с текстом предпочтительней использовать метод
        :meth:`EmailSender.image` с необязательным аргументом :obj:`text` чем
        :meth:`EmailSender.text` с необазательным аргументом :obj:`attachments`

    Args:
        account (:obj:`str`): E-Mail аккаунт trassir. Проверяется
            методом :meth:`PokaYoke.check_email_account`
        mailing_list (:obj:`str`): Список email адресов для отправки писем
            разделенный запятыми. Проверяется и парсится в список методом
            :meth:`PokaYoke.parse_emails`
        subject (:obj:`str`, optional): Общая тема для сообщений.
            По умолчанию :obj:`None`
        max_size (:obj:`int`, optional): Максимальный размер вложения, байт.
            По умолчанию 25 * 1024 * 1024

    Examples:
        >>> sender = EmailSender("MyAccount", "my_mail@google.com")
        >>> sender.text("Hello World!")

            .. image:: images/email_sender.text.png

        >>> sender.image(r"manual\en\cloud-devices-16.png")

            .. image:: images/email_sender.image.png

        >>> sender.files([r"manual\en\cloud.html", r"manual\en\cloud.png"])

            .. image:: images/email_sender.files.png
    """

    def __init__(self, account, mailing_list, subject=None, max_size=None):
        super(EmailSender, self).__init__()

        PokaYoke.check_email_account(account)

        self.max_size = max_size or 25 * 1024 * 1024

        self._account = account
        self._mailing_list = PokaYoke.parse_emails(mailing_list)

        self._subject_default = subject or self._generate_subject()

        logger.info(
            "EmailSender({}, {}, subject={}, max_size={})".format(
                repr(account),
                repr(mailing_list),
                repr(self._subject_default),
                repr(self.max_size),
            )
        )

    def _generate_subject(self):
        """Returns `server name` -> `script name`"""
        subject = "{server_name} -> {script_name}".format(
            server_name=self._host_api.settings("").name or "Client",
            script_name=self._host_api.stats().parent()["name"],
        )
        return subject

    def _group_files_by_max_size(self, file_paths, max_size):
        """Split files to groups. Size of each group is less then max_size

        Args:
            file_paths (list): List of files
            max_size (int): Max group size, bytes
        """
        group = []
        cur_size = 0
        for idx, file_path in enumerate(file_paths):
            file_size = os.stat(BaseUtils.win_encode_path(file_path)).st_size
            if not cur_size or (cur_size + file_size) < max_size:
                cur_size += file_size
                group.append(file_path)
            else:
                break
        else:
            return [group]

        return [group] + self._group_files_by_max_size(file_paths[idx:], max_size)

    def text(self, text, subject=None, attachments=None):
        """Отправка текстового сообщения

        Args:
            text (:obj:`str`): Текст сообщения
            subject (:obj:`str`, optional): Новая тема сообщения.
                По умолчанию :obj:`None`
            attachments (:obj:`list`, optional): Список вложений.
                По умолчанию :obj:`None`
        """
        if attachments is None:
            attachments = []
        self._host_api.send_mail_from_account(
            self._account,
            self._mailing_list,
            subject or self._subject_default,
            text,
            attachments,
        )

    def image(self, image_path, text="", subject=None):
        """Отправка изображения

        Args:
            image_path (:obj:`str`): Полный путь до изображения
            text (:obj:`str`, optional): Текст сообщения.
                По умолчанию :obj:`""`
            subject (:obj:`str`, optional): Новая тема сообщения.
                По умолчанию :obj:`None`
        """
        self.files([image_path], text=text, subject=subject)

    def files(self, file_paths, text="", subject=None, callback=None):
        """Отправка файлов

        Note:
            Если отправляется несколько файлов они могут быть разделены на
            несколько сообщений, основываясь на максимальном размере вложений.

        Args:
            file_paths (:obj:`str` | :obj:`list`): Путь до файла или список
                файлов для отправки
            text (:obj:`str`, optional): Текст сообщения.
                По умолчанию :obj:`""`
            subject (:obj:`str`, optional): Новая тема сообщения.
                По умолчанию :obj:`None`
            callback (:obj:`function`, optional): Функция, которая вызывается после
                отправки частей
        """
        logger.debug(
            "EmailSender.files({}, text={})".format(repr(file_paths), repr(text))
        )
        if isinstance(file_paths, str):
            file_paths = [file_paths]

        if callback is None:
            callback = BaseUtils.do_nothing

        files_to_send = []
        for path in file_paths:
            if BaseUtils.is_file_exists(path):
                files_to_send.append(path)
            else:
                text += "\nFile not found: {}".format(path)

        file_groups = self._group_files_by_max_size(files_to_send, self.max_size)

        for grouped_files in file_groups:
            logger.debug(
                "EmailSender.files: grouped_files: {}".format(repr(grouped_files))
            )
            self.text(text, subject=subject, attachments=grouped_files)
            callback(grouped_files)


class TelegramSender(Sender):
    """Работа с телеграм ботом `@trassirbot <https://t.me/trassirbot>`_

    Warnings:
        | Cкрипт должен быть запущен на **сервере** Trassir.
        | На Клиенте скрипт вызовет ошибку ``ServerKeyError``

    Args:
        telegram_ids (:obj:`str`): Id пользователей, через запятую.

    Examples:
        >>> # Можно указать id для рассылки при инициализации
        >>> # класса, для всех уведомлений
        >>> sender = TelegramSender("123456789")
        >>> sender.text("Hello World!")

            .. image:: images/telegram_sender.text.png

        >>> sender.image(r"manual\en\cloud-devices-16.png")

            .. image:: images/telegram_sender.image.png

        >>> sender.files([r"manual\en\cloud.html", r"manual\en\cloud.png"])

            .. image:: images/telegram_sender.files.png

        >>> # Или можно опередовать telegram id при вызове методов
        >>> sender = TelegramSender()
        >>> sender.text("Hello World!", tg_users=[123456789])

            .. image:: images/telegram_sender.text.png

        >>> sender.image(r"manual\en\cloud-devices-16.png", tg_users=[123456789])

            .. image:: images/telegram_sender.image.png

        >>> sender.files([r"manual\en\cloud.html", r"manual\en\cloud.png"], tg_users=[123456789])

            .. image:: images/telegram_sender.files.png
    """

    def __init__(self, telegram_ids=None):
        super(TelegramSender, self).__init__()
        self._host_api.exec_encoded(tbot_service)
        self._tbot_api = TBotAPI()
        if telegram_ids is not None:
            self.telegram_ids = TBotAPI.prepare_users(telegram_ids)
        else:
            self.telegram_ids = None

    def text(self, text, tg_users=None):
        """Отправка текстового сообщения

        Args:
            text (:obj:`str`): Текст сообщения.
            tg_users (List[:obj:`int`], optional): Список id пользователей
                telegram для отправки отдельных сообщений. По умолчанию :obj:`None`
        """
        if tg_users is None:
            tg_users = self.telegram_ids

        self._tbot_api.send_message(tg_users, text)

    def image(self, image_path, text="", tg_users=None, remove=False):
        """Отправка изображения

        Args:
            image_path (:obj:`str`): Полный путь до изображения
            text (:obj:`str`, optional): Текст сообщения.
                По умолчанию :obj:`""`
            tg_users (List[:obj:`int`], optional): Список id пользователей
                telegram для отправки отдельных сообщений. По умолчанию :obj:`None`
            remove (bool, optional): Удалить файл после отправки или нет. По умолчанию :obj:`False`
        """
        if not os.path.isfile(image_path):
            self.text("Image not found: {}".format(image_path))
            return

        if tg_users is None:
            tg_users = self.telegram_ids

        self._tbot_api.send_image(tg_users, image_path, caption=text, remove=remove)

    def files(self, file_paths, text="", tg_users=None, remove=False):
        """Отправка файлов

        Args:
            file_paths (:obj:`str` | :obj:`list`): Путь до файла или список
                файлов для отправки
            text (:obj:`str`, optional): Текст сообщения.
                По умолчанию :obj:`""`
            tg_users (List[:obj:`int`], optional): Список id пользователей
                telegram для отправки отдельных сообщений. По умолчанию :obj:`None`
            remove (bool, optional): Удалить файл после отправки или нет. По умолчанию :obj:`False`
        """

        if tg_users is None:
            tg_users = self.telegram_ids

        if isinstance(file_paths, str):
            file_paths = [file_paths]

        if text and len(file_paths) == 1:
            self.text(text, tg_users=tg_users)
            text = ""

        files_not_found_text = ""
        for path in file_paths:
            if os.path.isfile(BaseUtils.win_encode_path(path)):
                self._tbot_api.send_document(
                    tg_users, path, caption=text, remove=remove
                )
            else:
                files_not_found_text += "\nFile not found: {}".format(path)

        if files_not_found_text:
            self.text(files_not_found_text, tg_users=tg_users)


class SMSCSenderError(SenderError):
    """Raises with SMSCSender errors"""

    pass


class SMSCSender(Sender):
    """Класс для отправки сообщений с помощью сервиса smsc.ru

    See Also:
        `https://smsc.ru/api/http/ <https://smsc.ru/api/http/>`_

    Note:
        | Номера проверяются методом
          :meth:`PokaYoke.check_phones`
        | Также при первом запуске скрипт проверяет данные авторизации

    Warnings:
        | По умолчанию сервис smsc.ru отправляет сообщения от своего имени *SMSC.RU.*
          При этом отправка на номера Мегафон/Йота **недоступна** т.к. имя *SMSC.RU*
          заблокировано оператором.
        |
        | Мы настоятельно **НЕ** рекомендуем использовать стандартное имя *SMSC.RU.*
        |
        | Для отправки смс от вашего буквенного имени необходимо его
          создать в разделе - https://smsc.ru/senders/ и зарегистрировать для
          операторов в колонке Действия по кнопке Изменить (после заключения договора
          согласно инструкции - https://smsc.ru/contract/info/ ) а также приложить
          гарантийное письмо на МТС в личный кабинет http://smsc.ru/documents/ и
          отправить на почту inna@smsc.ru

    Args:
        login (:obj:`str`): SMSC Логин
        password (:obj:`str`): SMSC Пароль
        phones (:obj:`str`): Список номеров для отправки смс резделенный
            запятыми или точкой с запятой
        translit(:obj:`bool`, optional): Переводить сообщение в
            транслит. По умолчанию :obj:`True`

    Raises:
        SMSCSenderError: При любых ошибках с отправкой сообщения

    Examples:
        >>> sender = SMSCSender("login", "password", "79999999999")
        >>> sender.text("Hello World!")

            .. image:: images/smsc_sender.text.png
    """

    _BASE_URL = "https://smsc.ru/sys/send.php?{params}"
    _ERROR_CODES = {
        1: "URL Params error",
        2: "Invalid login or password",
        3: "Not enough money",
        4: "Your IP is temporary blocked. More info: https://smsc.ru/faq/99",
        5: "Bad date format",
        6: "Message is denied (by text or sender name)",
        7: "Bad phone format",
        8: "Can't send message to this number",
        9: "Too many requests",
    }

    def __init__(self, login, password, phones, translit=True):
        super(SMSCSender, self).__init__()
        if not login:
            raise SMSCSenderError("Empty login")
        if not password:
            raise SMSCSenderError("Empty password")

        self._params = {
            "login": urllib.quote(login),  # Login
            "psw": urllib.quote(password),  # Password or MD5 hash
            "phones": urllib.quote(
                PokaYoke.check_phones(phones)
            ),  # Comma or semicolon spaced phone list
            "fmt": 3,  # Response format: 0 - string; 1 - integers; 2 - xml; 3 - json
            "translit": 1 if translit else 0,  # If 1 - transliting message
            "charset": "utf-8",  # Message charset: "windows-1251"|"utf-8"|"koi8-r"
            "cost": 3,  # Message cost in response: 0 - msg; 1 - cost; 2 - msg+cost, 3 - msg+cost+balance
        }

        self._check_account()

    def _get_link(self, **kwargs):
        """Returns get link"""
        params = self._params.copy()
        params.update(kwargs)
        url = self._BASE_URL.format(params=urllib.urlencode(params))

        return url

    def _request_callback(self, code, result, error):
        """Callback for async_get"""
        if code != 200:
            raise SMSCSenderError("RequestError [{}]: {}".format(code, error))
        else:
            try:
                data = json.loads(result)
            except ValueError:
                data = {"error_code": 0, "error": "JSON loads error: {}".format(result)}

            error_code = data.get("error_code")
            if error_code is not None:
                error = self._ERROR_CODES.get(error_code)
                if not error:
                    error = data.get("error", "Unknown error")
                raise SMSCSenderError(
                    "ResponseError [{}]: {}".format(error_code, error)
                )

    def _check_account(self):
        """Send test request to smsc server"""
        url = self._get_link(cost=1, mes=urllib.quote("Hello world!"))
        self._host_api.async_get(url, self._request_callback)

    def text(self, text):
        """Отправка текстового сообщения

        Args:
            text (:obj:`str`): Текст сообщения.
        """

        url = self._get_link(mes=text)

        self._host_api.async_get(url, self._request_callback)


class FtpUploadTracker:
    """Upload progress class"""

    size_written = 0.0
    last_shown_percent = 0

    def __init__(self, file_path, callback, host_api=host):
        self._host_api = host_api
        self.total_size = os.path.getsize(BaseUtils.win_encode_path(file_path))
        self.file_path = file_path
        self.callback = callback

    # noinspection PyUnusedLocal
    def handle(self, block):
        """Handler for storbinary

        See Also:
            https://docs.python.org/2/library/ftplib.html#ftplib.FTP.storbinary
        """
        self.size_written += 1024.0
        percent_complete = round((self.size_written / self.total_size) * 100)

        if self.last_shown_percent != percent_complete:
            self.last_shown_percent = percent_complete
            self._host_api.timeout(
                100, lambda: self.callback(self.file_path, int(percent_complete), "")
            )


class FTPSenderError(SenderError):
    """Raises with FTPSender errors"""

    pass


class FTPSender(Sender):
    """Класс для отправки файлов на ftp сервер

    При инициализации проверят подключение к ftp серверу. Файлы отправляет
    по очереди. Максимальный размер очереди можно изменить. Во время
    выполнения передает текущий прогресс отправки файла в callback функцию.

    Note:
        Помимо прогресса в функцию callback может вернуться код ошибки.
            - -1 Файл не существует.
            - -2 Ошибка отправки на ftp, файл будет повторно отправлен.
            - -3 Неизвестная ошибка.


    Args:
        host (:obj:`str`): Адрес ftp сервера.
        port (:obj:`int`, optional): Порт ftp сервера. По умолчанию :obj:`port=21`
        user (:obj:`str`, optional): Имя пользователя. По умолчанию :obj:`"anonymous"`
        passwd (:obj:`str`, optional): Пароль пользователя. По умолчанию :obj:`passwd=""`
        work_dir (:obj:`str`, optional): Директория на сервре для сохранения файлов.
            По умолчанию :obj:`None`
        callback (:obj:`function`, optional): Callable function. По умолчанию :obj:`None`
        queue_maxlen (:obj:`int`, optional): Максимальная длина очереди на отправку.
            По умолчанию :obj:`queue_maxlen=1000`

    Examples:
        >>> # noinspection PyUnresolvedReferences
        >>> def callback(file_path, progress, error):
        >>>     # Пример callback функции, которая отображает
        >>>     # текущий прогресс в счетчике запуска скрипта
        >>>     # Args:
        >>>     #   file_path (str): Путь до файла
        >>>     #   progress (int): Текущий прогресс передачи файла, %
        >>>     #   error (str | Exception): Ошибка при отправке файла, если есть
        >>>     host.stats()["run_count"] = progress
        >>>     if error:
        >>>         host.error(error)
        >>>
        >>>     if progress == 100:
        >>>         host.timeout(3000, lambda: os.remove(BaseUtils.win_encode_path(file_path)))
        >>>
        >>> sender = FTPSender("172.20.0.10", 21, "trassir", "12345", work_dir="/test_dir/", callback=callback)
        >>> sender.files(r"D:\Shots\export_video.avi")
    """

    # noinspection SpellCheckingInspection,PyShadowingNames
    def __init__(
        self,
        host,
        port=21,
        user="anonymous",
        passwd="",
        work_dir=None,
        callback=None,
        queue_maxlen=1000,
    ):
        super(FTPSender, self).__init__()
        self._host = host
        self._port = port
        self._user = user
        self._passwd = passwd
        self._work_dir = work_dir

        self.queue = deque(maxlen=queue_maxlen)

        self._ftp = None

        if callback is None:
            callback = BaseUtils.do_nothing

        self.callback = callback

        self._work_now = False

        self._check_connection()

    def _check_connection(self):
        """Check if it possible to connect"""
        try:
            ftp = ftplib.FTP()
            ftp.connect(self._host, self._port, timeout=10)
            ftp.login(self._user, self._passwd)
        except ftplib.all_errors as err:
            raise FTPSenderError(err)
        if self._work_dir:
            try:
                ftp.cwd(self._work_dir)
            except ftplib.error_perm:
                ftp.mkd(self._work_dir)
                ftp.cwd(self._work_dir)

        ftp.quit()

    def _get_connection(self):
        """Connecting to ftp

        Returns:
            ftplib.FTP: Ftp object
        """
        try:
            ftp = ftplib.FTP()
            ftp.connect(self._host, self._port, timeout=10)
            ftp.login(self._user, self._passwd)
            if self._work_dir:
                try:
                    ftp.cwd(self._work_dir)
                except ftplib.error_perm:
                    ftp.mkd(self._work_dir)
                    ftp.cwd(self._work_dir)
            ftp.encoding = "utf-8"
            return ftp
        except ftplib.all_errors:
            return

    def _close_connection(self):
        """Close ftp connection"""
        try:
            if self._ftp is not None:
                self._ftp.close()
        finally:
            self._ftp = None

    def _send_file(self, file_path, work_dir=None):
        """Storbinary file with self.ftp

        Args:
            file_path (str): Full file path
            work_dir (str): Work dir on ftp
        """
        if work_dir is not None:
            if self._work_dir:
                work_dir = os.path.normpath("{}/{}".format(self._work_dir, work_dir))
            try:
                self._ftp.cwd(work_dir)
            except ftplib.error_perm:
                self._ftp.mkd(work_dir)
                self._ftp.cwd(work_dir)

        file_name = os.path.basename(file_path)
        upload_tracker = FtpUploadTracker(file_path, self.callback)
        with open(BaseUtils.win_encode_path(file_path), "rb") as opened_file:
            self._ftp.storbinary(
                "STOR " + file_name, opened_file, 1024, upload_tracker.handle
            )

    @BaseUtils.run_as_thread
    def _sender(self):
        """Send files in queue"""
        if self.queue:
            if self._ftp is None:
                self._ftp = self._get_connection()

            if self._ftp:
                work_dir = None
                file_path = self.queue.popleft()

                if isinstance(file_path, tuple):
                    file_path, work_dir = file_path

                if BaseUtils.is_file_exists(BaseUtils.win_encode_path(file_path)):
                    try:
                        self._send_file(file_path, work_dir)

                    except ftplib.all_errors as err:
                        self._host_api.timeout(
                            100, lambda: self.callback(file_path, -2, error=err)
                        )
                        self.queue.append(file_path)
                        self._close_connection()

                    except Exception as err:
                        self._host_api.timeout(
                            100, lambda: self.callback(file_path, -3, error=err)
                        )

                else:
                    self._host_api.timeout(
                        100,
                        lambda: self.callback(file_path, -1, error="File not found"),
                    )

            self._host_api.timeout(500, self._sender)
        else:
            self._work_now = False
            self._close_connection()

    def files(self, file_paths, *args):
        """Отправка файлов

        Note:
            Можно указать отдельный путь на ftp сервере для каждого файла.
            Для этого список файлов на отправку должен быть приведен к виду
            ``[(shot_path, ftp_path), ...]`` При этом так же будет учитываться
            глобальная папка :obj:`work_dir` заданная при инициализации класса.

        Args:
            file_paths (:obj:`str` | :obj:`list`): Путь до файла или список
                файлов для отправки
        """
        if not isinstance(file_paths, list):
            file_paths = [file_paths]

        self.queue.extend(file_paths)
        if not self._work_now:
            self._work_now = True
            self._sender()
