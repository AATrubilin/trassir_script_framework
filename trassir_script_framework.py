# -*- coding: utf-8 -*-
"""
<parameters>
    <company>AATrubilin</company>
    <title>trassir_script_framework</title>
    <version>0.63</version>
</parameters>
"""

# _SERVICE_VERSION = 0.64
tbot_service = """
    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
    ZL7PVWKj+RbYTY5fP64DebjUdUQzoA==
"""

import re
import os
import sys
import ssl
import time
import host
import json

import pickle
import base64
import ftplib
import urllib
import urllib2
import httplib
import logging
import threading
import subprocess

from Queue import Queue
from functools import wraps
from collections import deque
from xml.etree import ElementTree
from __builtin__ import object as py_object
from datetime import datetime, date, timedelta
from logging.handlers import RotatingFileHandler

logger = logging.getLogger()


class ScriptError(Exception):
    """Base script exception"""

    _host_api = host

    def __init__(self, *args):
        super(ScriptError, self).__init__(*args)
        self._host_api.timeout(1, self.rise_from_thread)

    def rise_from_thread(self):
        raise self


class HostLogHandler(logging.Handler):
    """Trassir main log handler"""

    def __init__(self, host_api=host):
        super(HostLogHandler, self).__init__()
        self._host_api = host_api

    def emit(self, record):
        msg = self.format(record)
        self._host_api.log_message(msg)


class PopupHandler(logging.Handler):
    """Trassir popup handler"""

    def __init__(self, host_api=host):
        super(PopupHandler, self).__init__()
        self._host_api = host_api
        self._popups = {
            "CRITICAL": host_api.error,
            "FATAL": host_api.error,
            "ERROR": host_api.error,
            "WARN": host_api.alert,
            "WARNING": host_api.alert,
            "INFO": host_api.message,
            "DEBUG": host_api.message,
            "NOTSET": host_api.message,
        }

    def emit(self, record):
        msg = self.format(record)
        self._popups[record.levelname](msg)


class DuplicateFilter(logging.Filter):
    """Suppressing multiple messages with same content.

    Tracking last logged record and filter out any
    repeated (similar) records. Output something more rsyslog style.
    
    Example:
        --- The last message repeated 3 times
    """

    def __init__(self):
        super(DuplicateFilter, self).__init__()
        self._last_log = None
        self._last_log_count = 1

    def filter(self, record):
        record.duplicates = ""
        current_log = (record.module, record.levelno, record.msg)
        if current_log == self._last_log:
            self._last_log_count += 1
            return False
        else:
            if self._last_log_count > 1:
                record.duplicates = (
                    "--- The last message repeated %s times\n" % self._last_log_count
                )
            self._last_log = current_log
            self._last_log_count = 1
            return True


class BaseUtils:
    """Base utils for your scripts"""

    _host_api = host
    _FOLDERS = {obj[1]: obj[3] for obj in host.objects_list("Folder")}
    _TEXT_FILE_EXTENSIONS = [".txt", ".csv", ".log"]
    _LPR_FLAG_BITS = {
        "LPR_UP": 0x00001,
        "LPR_DOWN": 0x00002,
        "LPR_BLACKLIST": 0x00004,
        "LPR_WHITELIST": 0x00008,
        "LPR_INFO": 0x00010,
        "LPR_FIRST_LANE": 0x01000,
        "LPR_SECOND_LANE": 0x02000,
        "LPR_THIRD_LANE": 0x04000,
        "LPR_EXT_DB_ERROR": 0x00020,
        "LPR_CORRECTED": 0x00040,
    }
    _EVENT_STR_TO_INT = {
        "Border Crossed A -> B": -2010220362,
        "Border Crossed B -> A": 881900680,
        "Border %1 A-B Crossing": 1745631458,
        "Border %1 B-A Crossing": 1382034490,
        "Border %1 Unique Object A-B Crossing": -1764400102,
        "Border %1 Unique Object B-A Crossing": -755097134,
        "Connected To %1 under %2": -567223767,
        "Connection Established": 1689573124,
        "Connection Lost": -1739961019,
        "Deny: %1 (%2)": 1400866841,
        "Disconnected From %1": 854687023,
        "FACS Connected": 928164014,
        "FACS Disconnected": -528751441,
        "Face Detected": -145480902,
        "Face Recognized": 1904675878,
        "Fire Detected": -2095846277,
        "Fire Stopped": 1556160195,
        "HDD Broken": -359176531,
        "HDD Error": -2035571413,
        "HDD Restored": 2054776042,
        "Health Turns Bad": -1338064969,
        "Health Turns Good": 1737407416,
        "Input High to Low": 1260011944,
        "Input Low to High": 108469542,
        "Login Failed, %1 from %2": -1785217387,
        "Login Successful, %1 from %2": 1634136664,
        "Logout, %1 from %2": 334348171,
        "Motion Start": -1960416690,
        "Motion Stop": 452886769,
        "No Connection to Cloud": -1220531757,
        "Object Entered the Zone": -1484834142,
        "Object Left the Zone": 1838034845,
        "Output High to Low": -994975116,
        "Output Low to High": 842360770,
        "Pass: %1 (%2)": 1944146750,
        "Photo Detected": -220640968,
        "Script: %1": 865778551,
        "Shutdown": 390175606,
        "Signal Lost": -997068283,
        "Signal Restored": -1801421619,
        "Slow Down Detected": -438590449,
        "Software update to version %1 succeeded": 1188419157,
        "Startup": -37228692,
        "Tracked Object Left Zone %1": 456308509,
        "Tracked Unique Object Entered Zone %1": -1766980008,
    }
    _EVENT_INT_TO_STR = {v: k for k, v in _EVENT_STR_TO_INT.iteritems()}
    _IMAGE_EXT = [".png", ".jpg", ".jpeg", ".bmp"]
    _HTML_IMG_TEMPLATE = """<img src="data:image/png;base64,{img}" {attr}>"""

    _SCR_DEFAULT_NAMES = [
        "Yeni skript",
        "Unnamed Script",
        "უსახელო სკრიპტი",
        "Жаңа скрипт",
        "Script nou",
        "Новый скрипт",
        "Yeni skript dosyası",
        "Новий скрипт",
        "未命名脚本",
    ]

    def __init__(self):
        pass

    # noinspection PyUnusedLocal
    @staticmethod
    def do_nothing(*args, **kwargs):
        """Ничего не делает.

        Returns:
            :obj:`bool`: ``True``
        """
        return True

    @classmethod
    def run_as_thread_v2(cls, locked=False, daemon=True):
        """Декоратор для запуска функций в отдельном потоке.

        Args:
            locked (:obj:`bool`, optional): Если :obj:`True` - запускает поток с блокировкой
                доступа к ресурсам. По умолчанию :obj:`False`
            daemon (:obj:`bool`, optional): Устанавливает значение :obj:`threading.Thread.daemon`.
                По умолчанию :obj:`True`

        Examples:
            >>> import time
            >>>
            >>>
            >>> @BaseUtils.run_as_thread_v2()
            >>> def run_count_timer():
            >>>     time.sleep(1)
            >>>     host.stats()["run_count"] += 1
            >>>
            >>>
            >>> run_count_timer()
        """
        lock = threading.Lock()

        def wrapped(fn):
            @wraps(fn)
            def run(*args, **kwargs):
                def raise_exc(err):
                    # noinspection PyShadowingNames
                    args = list(err.args)
                    args[0] = "[{}]: {}".format(fn.__name__, args[0])
                    err.args = args
                    raise err

                def locked_fn(*args_, **kwargs_):
                    lock.acquire()
                    try:
                        return fn(*args_, **kwargs_)
                    except Exception as err:
                        cls._host_api.timeout(1, lambda: raise_exc(err))
                    finally:
                        lock.release()

                def unlocked_fn(*args_, **kwargs_):
                    try:
                        return fn(*args_, **kwargs_)
                    except Exception as err:
                        cls._host_api.timeout(1, lambda: raise_exc(err))

                t = threading.Thread(
                    target=locked_fn if locked else unlocked_fn,
                    args=args,
                    kwargs=kwargs,
                )
                t.daemon = daemon
                t.start()
                return t

            return run

        return wrapped

    @staticmethod
    def run_as_thread(fn):
        """Декоратор для запуска функций в отдельном потоке.

        Returns:
            :obj:`threading.Thread`: Функция в отдельном потоке

        Examples:
            >>> import time
            >>>
            >>>
            >>> @BaseUtils.run_as_thread
            >>> def run_count_timer():
            >>>     time.sleep(1)
            >>>     host.stats()["run_count"] += 1
            >>>
            >>>
            >>> run_count_timer()
        """

        @wraps(fn)
        def run(*args, **kwargs):
            t = threading.Thread(target=fn, args=args, kwargs=kwargs)
            t.daemon = True
            t.start()
            return t

        return run

    @staticmethod
    def catch_request_exceptions(func):
        """Catch request errors"""

        @wraps(func)
        def wrapped(self, *args, **kwargs):
            try:
                return func(self, *args, **kwargs)
            except urllib2.HTTPError as e:
                return e.code, "HTTPError: {}".format(e.code)
            except urllib2.URLError as e:
                return e.reason, "URLError: {}".format(e.reason)
            except httplib.HTTPException as e:
                return e, "HTTPException: {}".format(e)
            except ssl.SSLError as e:
                return e.errno, "SSLError: {}".format(e)

        return wrapped

    @staticmethod
    def win_encode_path(path):
        """Изменяет кодировку на ``"cp1251"`` для WinOS.

        Args:
            path (:obj:`str`): Путь до файла или папки

        Returns:
            :obj:`str`: Декодированый путь до файла или папки

        Examples:
            >>> path = r"D:\Shots\Скриншот.jpeg"
            >>> os.path.isfile(path)
            False
            >>> os.path.isfile(BaseUtils.win_encode_path(path))
            True
        """
        if os.name == "nt":
            try:
                path = path.decode("utf8")
            except UnicodeDecodeError:
                logger.warning("UnicodeDecodeError: {}".format(path), exc_info=True)
                pass

        return path

    @staticmethod
    def is_file_exists(file_path, tries=1):
        """Проверяет, существует ли файл.

        Проверка происходит в течении ``tries`` секунд.

        Warning:
            | Запускайте функцию только в отдельном потоке если ``tries > 1``
            | Вторая и последующие проверки производятся с ``time.sleep(1)``

        Args:
            file_path (:obj:`str`): Полный путь до файла
            tries (:obj:`int`, optional): Количество проверок. По умолчанию ``tries=1``

        Returns:
            :obj:`bool`: ``True`` if file exists, ``False`` otherwise

        Examples:
            >>> BaseUtils.is_file_exists("_t1server.settings")
            True
        """
        file_path_encoded = BaseUtils.win_encode_path(file_path)
        if os.path.isfile(file_path) or os.path.isfile(file_path_encoded):
            return True
        for x in xrange(tries - 1):
            time.sleep(1)
            if os.path.isfile(file_path) or os.path.isfile(file_path_encoded):
                return True
        return False

    @staticmethod
    def is_folder_exists(folder):
        """Проверяет существование папки и доступ на запись.

        Args:
            folder (:obj:`str`): Путь к папке.

        Raises:
            IOError: Если папка не существует

        Examples:
            >>> BaseUtils.is_folder_exists("/test_path")
            IOError: Folder '/test_path' is not exists
        """

        if not os.path.isdir(folder):
            raise IOError("Folder '{}' is not exists".format(folder))

        readme_file = os.path.join(folder, "readme.txt")
        with open(readme_file, "w") as f:
            f.write(
                "If you see this file - Trassir script have no access to remove it!"
            )
        os.remove(readme_file)

    @classmethod
    def is_template_exists(cls, template_name):
        """Проверяет существование шаблона

        Args:
            template_name (:obj:`str`): Имя шаблона

        Returns:
            :obj:`bool`: :obj:`True` если шаблон существует, иначе :obj:`False`
        """
        if template_name in [
            tmpl_.name for tmpl_ in cls._host_api.settings("templates").ls()
        ]:
            return True
        return False

    @classmethod
    def cat(cls, filepath, check_ext=True):
        """Выводит на отображение текстовую инфомрацию.

        Tip:
            - *WinOS*: открывает файл программой по умолчанию
            - *TrassirOS*: открывает файл в терминале с помощью утилиты `cat`

        Note:
            | Доступные расширения файлов: ``[".txt", ".csv", ".log"]``
            | Если открываете файл с другим расширением установите ``check_ext=False``

        Args:
            filepath (:obj:`str`): Полный путь до файла
            check_ext (:obj:`bool`, optional): Если ``True`` - проверяет расширение файла.
                По умолчанию ``True``

        Examples:
            >>> BaseUtils.cat("/home/trassir/ Trassir 3 License.txt")
        .. image:: images/base_utils.cat.png

        Raises:
            :class:`TypeError`: Если ``check_ext=True`` расширение файла нет в списке :obj:`_TEXT_FILE_EXTENSIONS`
        """

        if check_ext:
            _, ext = os.path.splitext(filepath)
            if ext not in cls._TEXT_FILE_EXTENSIONS:
                raise TypeError(
                    "Bad file extension: {}. To ignore this: set check_ext=False".format(
                        ext
                    )
                )

        if os.name == "nt":
            os.startfile(filepath)
        else:
            subprocess.Popen(
                [
                    "xterm -fg black -bg white -geometry 90x35 -fn "
                    "-misc-fixed-medium-r-normal--18-120-100-100-c-90-iso10646-1 -e bash -c \"cat '{}'; "
                    "read -n 1 -s -r -p '\n\nPress any key to exit'; exit\"".format(
                        filepath
                    )
                ],
                shell=True,
                close_fds=True,
            )

    @classmethod
    def _json_serializer(cls, data):
        """JSON serializer for objects not serializable by default"""
        if isinstance(data, (datetime, date)):
            return data.isoformat()

        elif isinstance(data, cls._host_api.ScriptHost.SE_Settings):
            return "settings('{}')".format(data.path)

        elif isinstance(data, cls._host_api.ScriptHost.SE_Object):
            return "object('{}')".format(data.guid)

        return type(data).__name__

    @classmethod
    def to_json(cls, data, **kwargs):
        """Сериализация объекта в JSON стрку

        Note:
            Не вызывает ошибку при сериализации объектов :obj:`datetime`,
            :obj:`date`, :obj:`SE_Settings`, :obj:`SE_Object`

        Args:
            data (:obj:`obj`): Объект для сериализации

        Returns:
            :obj:`str`: JSON строка

        Examples:
            >>> obj = {"now": datetime.now()}
            >>> json.dumps(obj)
            TypeError: datetime.datetime(2019, 4, 2, 18, 01, 33, 881000) is not JSON serializable
            >>> BaseUtils.to_json(obj, indent=None)
            '{"now": "2019-04-02T18:01:33.881000"}'
        """

        return json.dumps(data, default=cls._json_serializer, **kwargs)

    @staticmethod
    def ts_to_dt(ts):
        """Конвертирует timestamp в :obj:`datetime` объект

        Args:
            ts (:obj:`int`): Timestamp

        Returns:
            :obj:`datetime`: Datetime объект
        """
        if ts > 1e10:
            ts_sec = int(ts / 1e6)
            ts_ms = int(ts - ts_sec * 1e6)
        else:
            ts_sec = int(ts)
            ts_ms = 0

        return datetime.fromtimestamp(ts_sec) + timedelta(microseconds=ts_ms)

    @staticmethod
    def dt_to_ts(dt):
        """Конвертирует :obj:`datetime` объект в trassir timestamp

        Args:
            dt (:obj:`datetime`): Datetime

        Returns:
            :obj:`int`: Trassir timestamp
        """
        return int(time.mktime(dt.timetuple())) * 1e6 + dt.microsecond

    @classmethod
    def lpr_flags_decode(cls, flags):
        """Преобразует флаги события AutoTrassir

        Приводит флаги события человекочитаемый список

        Note:
            Список доступных флагов:

            - ``LPR_UP`` - Направление движения вверх
            - ``LPR_DOWN`` - Направление движения вниз

            - ``LPR_BLACKLIST`` - Номер в черном списке
            - ``LPR_WHITELIST`` - Номер в черном списке
            - ``LPR_INFO`` - Номер в информационном списке

            - ``LPR_FIRST_LANE`` - Автомобиль двигается по первой полосе
            - ``LPR_SECOND_LANE`` - Автомобиль двигается по второй полосе
            - ``LPR_THIRD_LANE`` - Автомобиль двигается по третей полосе

            - ``LPR_EXT_DB_ERROR`` - Ошибка во внешнем списке
            - ``LPR_CORRECTED`` - Номер исправлен оператором

        Args:
            flags (:obj:`int`): Биты LPR события. Как правило аргумент :obj:`ev.flags`
                события :obj:`SE_LprEvent` AutoTrassir. Например :obj:`536870917`

        Returns:
            List[:obj:`str`]: Список флагов

        Examples:
            >>> BaseUtils.lpr_flags_decode(536870917)
            ['LPR_UP', 'LPR_BLACKLIST']
        """
        return [bit for bit, code in cls._LPR_FLAG_BITS.iteritems() if (flags & code)]

    @classmethod
    def event_type_encode(cls, event_type):
        """Преобразует тип события :obj:`str` -> :obj:`int`

        Note:
            События в БД хранятся в :obj:`int`, в скриптах
            приходят в человекочитаемом, строковом формате.

        Args:
            event_type (:obj:`str`): Тип события как в скриптах.

        Examples:
            >>> BaseUtils.event_type_encode("Border Crossed A -> B")
            -2010220362

        Returns:
            :obj:`int`: Тип события как в БД
        """
        if not isinstance(event_type, str):
            raise TypeError("Expected str, got {}".format(type(event_type).__name__))
        return cls._EVENT_STR_TO_INT.get(event_type)

    @classmethod
    def event_type_decode(cls, event_type):
        """Преобразует тип события :obj:`int` -> :obj:`str`

        Note:
            События в БД хранятся в :obj:`int`, в скриптах
            приходят в человекочитаемом, строковом формате.

        Args:
            event_type (:obj:`int`): Тип события как в БД.

        Examples:
            >>> BaseUtils.event_type_encode(-2010220362)
            "Border Crossed A -> B"

        Returns:
            :obj:`str`: Тип события как в скриптах
        """
        if not isinstance(event_type, int):
            raise TypeError("Expected int, got {}".format(type(event_type).__name__))
        return cls._EVENT_INT_TO_STR.get(event_type)

    @classmethod
    def image_to_base64(cls, image):
        """Создает base64 из изображения

        Args:
            image (:obj:`str`): Путь к изображению или изображение

        Returns:
            :obj:`str`: Base64 image

        Examples:
            >>> BaseUtils.image_to_base64(r"manual\en\cloud-devices-16.png")
            'iVBORw0KGgoAAAANSUhEUgAAB1MAAAH0CAYAAABo5wRhAAAACXBIWXMAAC4jA...'
            >>> BaseUtils.image_to_base64(open(r"manual\en\cloud-devices-16.png", "rb").read())
            'iVBORw0KGgoAAAANSUhEUgAAB1MAAAH0CAYAAABo5wRhAAAACXBIWXMAAC4jA...'
        """
        _, ext = os.path.splitext(image)

        if ext.lower() in cls._IMAGE_EXT:
            image = cls.win_encode_path(image)
            if not BaseUtils.is_file_exists(image):
                return ""

            with open(image, "rb") as image_file:
                image = image_file.read()

        return base64.b64encode(image)

    @classmethod
    def base64_to_html_img(cls, image_base64, **kwargs):
        """Возвращает base64 изображение в `<img>` html теге

        Args:
            image_base64 (:obj:`str`): Base64 image
            **kwargs: HTML `<img>` tag attributes. Подробнее на `html.com
                <https://html.com/tags/img/#Attributes_of_img>`_

        Returns:
            :obj:`str`: html image

        Examples:
            >>> base64_image = BaseUtils.image_to_base64(r"manual\en\cloud-devices-16.png")
            >>> html_image = BaseUtils.base64_to_html_img(base64_image, width=280, height=75)
            >>> html_image
            '<img src="data:image/png;base64,iVBORw0KGgoAA...Jggg==" width="280" height="75">'
            >>> host.message(html_image)

                .. image:: images/popup_sender.image.png
        """
        html_img = cls._HTML_IMG_TEMPLATE.format(
            img=image_base64,
            attr=" ".join(
                '%s="%s"' % (key, value) for key, value in kwargs.iteritems()
            ),
        )
        return html_img

    @staticmethod
    def save_pkl(file_path, data):
        """Сохраняет данные в `.pkl` файл

        Args:
            file_path (:obj:`str`): Путь до файла
            data: Данные для сохранения

        Returns:
            :obj:`str`: Абсолютный путь до файла

        Examples:
            >>> data = {"key": "value"}
            >>> BaseUtils.save_pkl("saved_data.pkl", data)
            'D:\\DSSL\\Trassir-4.1-Client\\saved_data.pkl'

        """
        if not file_path.endswith(".pkl"):
            file_path = file_path + ".pkl"

        with open(file_path, "wb") as opened_file:
            pickle.dump(data, opened_file)

        return os.path.abspath(file_path)

    @staticmethod
    def load_pkl(file_path, default_type=dict):
        """Загружает данные из `.pkl` файла

        Args:
            file_path (:obj:`str`): Путь до файла
            default_type (optional):
                Тип данных, возвращаемый при неудачной загрузке данных из файла.
                По умолчанию :obj:`dict`

        Returns:
            Данные из файла или :obj:`default_type()`

        Examples:
            >>> BaseUtils.load_pkl("fake_saved_data.pkl")
            {}
            >>> BaseUtils.load_pkl("fake_saved_data.pkl", default_type=list)
            []
            >>> BaseUtils.load_pkl("fake_saved_data.pkl", default_type=int)
            0
            >>> BaseUtils.load_pkl("fake_saved_data.pkl", default_type=str)
            ''
            >>> BaseUtils.load_pkl("saved_data.pkl")
            {'key': 'value'}
        """

        if not file_path.endswith(".pkl"):
            file_path = file_path + ".pkl"

        data = default_type()

        if os.path.isfile(file_path):
            try:
                with open(file_path, "rb") as opened_file:
                    data = pickle.load(opened_file)
            except (EOFError, IndexError, ValueError, TypeError):
                """ dump file is empty or broken """

        return data

    @classmethod
    def get_object(cls, obj_id):
        """Возвращает объект Trassir, если он доступен, иначе ``None``

        Args:
            obj_id (:obj:`str`): Guid объекта или его имя

        Returns:
            :obj:`ScriptHost.SE_Object`: Объект Trassir или ``None``

        Examples:
            >>> obj = BaseUtils.get_object("EZJ4QnbC")
            >>> if obj is None:
            >>>     host.error("Object not found")
            >>> else:
            >>>     host.message("Object name is {0.name}".format(obj))
        """
        if not isinstance(obj_id, (str, unicode)):
            raise TypeError(
                "Expected str or unicode, got '{}'".format(type(obj_id).__name__)
            )
        obj = cls._host_api.object(obj_id)
        try:
            obj.name
        except EnvironmentError:
            """Object not found"""
            obj = None
        return obj

    @classmethod
    def get_object_name_by_guid(cls, guid):
        """Возвращает имя объекта Trassir по его guid

        Tip:
            Можно использовать:

            - guid объекта ``"CFsuNBzt"``
            - guid объекта + guid сервера ``"CFsuNBzt_pV4ggECb"``

        Args:
            guid (:obj:`str`): Guid объекта Trassir

        Returns:
            :obj:`str`: Имя объекта, если объект найден, иначе ``guid``

        Examples:
            >>> BaseUtils.get_object_name_by_guid("EZJ4QnbC")
            'AC-D2141IR3'
            >>> BaseUtils.get_object_name_by_guid("EZJ4QnbC-")
            'EZJ4QnbC-'
        """
        guid = guid.split("_", 1)[0]
        obj = cls.get_object(guid)
        if obj is None:
            name = guid
        else:
            name = obj.name
        return name

    @classmethod
    def get_full_guid(cls, obj_id):
        """Возвращает полный guid объекта

        Args:
            obj_id (:obj:`str`): Guid объекта или его имя

        Returns:
            :obj:`str`: Полный guid объекта
        """

        tr_obj = cls.get_object(obj_id)
        if tr_obj is not None:
            for obj in cls._host_api.objects_list(""):
                if tr_obj.guid == obj[1]:
                    return "{}_{}".format(obj[1], cls._FOLDERS.get(obj[3], obj[3]))

    @classmethod
    def get_operator_gui(cls):
        """Возвращает объект интерфейса оператора

        Returns:
            :obj:`OperatorGUI`: Объект интерфейса оператора

        Raises:
            ScriptError: Если не удается загрузить интерфейс

        Examples:
            Открыть интерфейс Trassir а мониторе №1

            >>> operator_gui = BaseUtils.get_operator_gui()
            >>> operator_gui.raise_monitor(1)
        """
        obj = cls.get_object("operatorgui_{}".format(cls._host_api.settings("").guid))
        if obj is None:
            raise ScriptError("Failed to load operator gui")
        return obj

    @classmethod
    def get_server_guid(cls):
        """Возвращает guid текущего сервра

        Returns:
            :obj:`str`: Guid сервера

        Examples:
            >>> BaseUtils.get_server_guid()
            'client'
        """
        return cls._host_api.settings("").guid

    @classmethod
    def get_script_name(cls):
        """Возвращает имя текущего скрипта

        Returns:
            :obj:`str`: Имя скрипта

        Examples:
            >>> BaseUtils.get_script_name()
            'Новый скрипт'
        """
        return cls._host_api.stats().parent()["name"] or __name__

    @classmethod
    def get_screenshot_folder(cls):
        """Возвращает путь до папки скриншотов

        При этом производит проверку папки методом
        :meth:`BaseUtils.is_folder_exists`

        Returns:

            :obj:`str`: Полный путь к папке скриншотов

        Examples:
            >>> BaseUtils.get_screenshot_folder()
            '/home/trassir/shots'
        """
        folder = cls._host_api.settings("system_wide_options")["screenshots_folder"]
        cls.is_folder_exists(folder)
        return folder

    @classmethod
    def get_logger(
        cls,
        host_log="WARNING",
        popup_log="ERROR",
        file_log=None,
        file_name=None,
        file_max_bytes=5 * 1024 * 1024,
        file_backup_count=2,
    ):
        """Возвращает логгер с предустановленными хэндлерами

        Доступные хэндлеры:
            - *host_log*: Пишет сообщения в основной лог сервера _t1server.log
            - *popup_log*: Показывает всплывающие сообщения ``message/alert/error``
            - *file_log*: Пишет сообщения в отдельный файл в папку скриншотов

        Для каждого хэндлера можно установить разный уровень логирования

        По умолчанию ``host_log="WARNING"`` и ``popup_log="ERROR"``

        Note:
            Имя файла лога можно указать с расширение ".log" или без.

        See Also:
            `Logging levels на сайте docs.python.org
            <https://docs.python.org/2/library/logging.html#logging-levels>`_

        Args:
            host_log (:obj:`str`, optional): Уровень логирования в основной лог.
                По умолчанию ``"WARNING"``
            popup_log (:obj:`str`, optional): Уровень логирования во всплывающих
                сообщениях. По умолчанию ``"ERROR"``
            file_log (:obj:`str`, optional): Уровень логирования в отдельный файл
                По умолчанию :obj:`None`
            file_name (:obj:`str`, optional): Имя файла для логирования.
                По умолчанию :obj:`None` и равно ``<имени скрипта>.log``
            file_max_bytes (:obj:`int`, optional): Максимальный размер файла лога
                в байтах. По умолчанию :obj:`5 * 1024 * 1024`
            file_backup_count (:obj:`int`, optional): Макссимальное кол-во бэкапов лога.
                По умолчанию :obj:`2`

        Returns:
            :obj:`logging.logger`: Логгер

        Examples:
            >>> logger = BaseUtils.get_logger()
            >>> logger.warning("My warning message")
            >>> try:
            >>>     # noinspection PyUnresolvedReferences
            >>>     do_something()
            >>> except NameError:
            >>>     logger.error("Function is not defined", exc_info=True)
        """
        logger_ = logging.getLogger(__name__)
        logger_.setLevel("DEBUG")

        def _remove_handlers():
            """Close and remove handlers on disable script"""
            logger_.info("Remove handlers...")
            for handler in logger_.handlers[:]:
                handler.close()
                logger_.removeHandler(handler)

        cls._host_api.register_finalizer(_remove_handlers)

        if host_log:
            host_handler = HostLogHandler()
            host_handler.setLevel(host_log)
            host_formatter = logging.Formatter(
                "[%(levelname)-8s] %(lineno)-4s <%(funcName)s> - %(message)s"
            )
            host_handler.setFormatter(host_formatter)
            logger_.addHandler(host_handler)

        if popup_log:
            popup_handler = PopupHandler()
            popup_handler.setLevel(popup_log)
            popup_formatter = logging.Formatter(
                fmt="<b>[%(levelname)s]</b> Line: %(lineno)s<br><i>%(message).630s</i>"
            )
            popup_handler.setFormatter(popup_formatter)
            logger_.addHandler(popup_handler)

        if file_log:
            if file_name is None:
                file_name = cls.get_script_name()

            if not file_name.endswith(".log"):
                file_name = "{}.log".format(file_name)

            file_path = os.path.join(cls.get_screenshot_folder(), file_name)
            file_path = cls.win_encode_path(file_path)

            file_handler = RotatingFileHandler(
                file_path, maxBytes=file_max_bytes, backupCount=file_backup_count
            )
            file_handler.setLevel(file_log)
            file_formatter = logging.Formatter(
                fmt="%(duplicates)s%(asctime)s [%(levelname)-8s] %(lineno)-4s <%(funcName)s> - %(message)s",
                datefmt="%Y/%m/%d %H:%M:%S",
            )
            file_handler.setFormatter(file_formatter)
            file_handler.addFilter(DuplicateFilter())
            logger_.addHandler(file_handler)

        return logger_

    @classmethod
    def set_script_name(cls, fmt=None, script_name=None):
        """Автоматически изменяет имя скрипта

        Новое имя скрипта создается на основе `параметров
        <https://www.dssl.ru/files/trassir/manual/ru/setup-script-parameters.html>`_
        скрипта. По желанию можно изменить шаблон имени. По умолчанию
        :obj:`"{title} v{version}"`

        Note:
            Имя изменяется только если сейчас у скрипта стандартное имя,
            например :obj:`"Новый скрипт"` или :obj:`"Unnamed Script"` и др.

        Args:
            fmt (:obj:`str`, optional): Шаблон имени скрипта. По умолчанию :obj:`None`
            script_name (:obj:`str`, optional): Имя скрипта. Если не задано - парсит
                имя из параметров. По умолчанию :obj:`None`

        Examples:
            >>> BaseUtils.set_script_name()
            'trassir_script_framework v0.4'

            >>> BaseUtils.set_script_name(fmt="{title}")
            'trassir_script_framework'
        """
        if cls._host_api.stats().parent()["name"] in cls._SCR_DEFAULT_NAMES:
            if script_name is None:
                try:
                    root = ElementTree.fromstring(__doc__)
                except ElementTree.ParseError:
                    root = None

                if root is None:
                    company, title, version = None, None, None
                else:
                    company = root.find("company") if root else None
                    title = root.find("title") if root else None
                    version = root.find("version") if root else None

                if fmt is None:
                    fmt = "{title} v{version}"

                script_name = fmt.format(
                    company="DSSL" if company is None else company.text,
                    title="Script" if title is None else title.text,
                    version="0.1" if version is None else version.text,
                )

            cls._host_api.stats().parent()["name"] = script_name

            return script_name


class Worker(threading.Thread):
    """Thread executing tasks from a given tasks queue"""

    def __init__(self, tasks):
        super(Worker, self).__init__()
        alert("START WORKER")
        self.tasks = tasks
        self.daemon = True
        self.start()

    def run(self):
        while __name__ in sys.modules.keys():
            if not self.tasks.empty():
                func, args, kwargs = self.tasks.get(timeout=1)
                # noinspection PyBroadException
                try:
                    func(*args, **kwargs)
                except:
                    logger.exception("ThreadPool Worker error")
                finally:
                    self.tasks.task_done()


class ThreadPool:
    """Pool of threads consuming tasks from a queue"""

    def __init__(self, num_threads, host_api=host):
        self._host_api = host_api
        self.tasks = Queue()
        self.workers = [Worker(self.tasks) for _ in xrange(num_threads)]

    def add_task(self, func, *args, **kargs):
        """Add a task to the queue"""
        self.tasks.put((func, args, kargs))

    def wait_completion(self):
        """Wait for completion of all the tasks in the queue"""
        self.tasks.join()


class HTTPRequester(py_object):
    """Framework for urllib2

    See Also:
        https://docs.python.org/2/library/urllib2.html#urllib2.build_opener

    Args:
        opener (:obj:`urllib2.OpenerDirector`, optional): Обработчик запросов.
            По умолчанию :obj:`None`
        timeout (:obj:`int`, optional): Время ожидания запроса, в секундах.
            По умолчанию :obj:`timeout=10`

    Examples:
        Пример запроса к SDK Trassir

        >>> # Отключение проверки сертификата
        >>> context = ssl.create_default_context()
        >>> context.check_hostname = False
        >>> context.verify_mode = ssl.CERT_NONE
        >>>
        >>> handler = urllib2.HTTPSHandler(context=context)
        >>> opener = urllib2.build_opener(handler)
        >>>
        >>> requests = HTTPRequester(opener, timeout=20)
        >>> response = requests.get(
        >>>     "https://172.20.0.101:8080/login",
        >>>     params={"username": "Admin", "password": "12345"}
        >>> )
        >>>
        >>> response.code
        200
        >>> response.text
        '{\\n   "sid" : "T6LAAcxg",\\n   "success" : 1\\n}\\n'
        >>> response.json
        {u'success': 1, u'sid': u'T6LAAcxg'}
    """

    class Response(py_object):
        """Класс ответа от сервера

        Attributes:
            code (:obj:`str` | :obj:`int`): Код ответа сервера
            text (:obj:`str`): Текст ответа
            json (:obj:`dict` | :obj:`list`): Создает объект из json ответа
        """

        def __init__(self, *args):
            self.code, self.text = args

        @property
        def json(self):
            return json.loads(self.text)

    def __init__(self, opener=None, timeout=10):
        if opener is None:
            handler = urllib2.BaseHandler()
            opener = urllib2.build_opener(handler)
        self._opener = opener

        self.timeout = timeout

    @BaseUtils.catch_request_exceptions
    def _get_response(self, request):
        """Returns response

        Args:
            request (:obj:`urllib2.Request`): This class is an abstraction of a URL request
        """
        response = self._opener.open(request, timeout=self.timeout)
        return response.code, response.read()

    @staticmethod
    def _parse_params(**params):
        """Params get string params

        Args:
            **params (dict): Keyword arguments

        Returns:
            str: params string
        """
        return "&".join(
            "{key}={value}".format(key=key, value=value)
            for key, value in params.iteritems()
        )

    @staticmethod
    def _prepare_headers(headers):
        """Prepare headers for request"""
        if headers is None:
            headers = {}

        if "User-Agent" not in headers:
            headers["User-Agent"] = "TrassirScript"
        return headers

    def get(self, url, params=None, headers=None):
        """Создает GET запрос по указанному :obj:`url`

        Args:
            url (:obj:`str`): Url для запроса
            params (:obj:`dict`, optional): Параметры GET запроса
            headers (:obj:`dict`, optional): Заголовки запроса

        Examples:
            >>> requests = HTTPRequester()
            >>> response = requests.get(
            >>>     "http://httpbin.org/get",
            >>>     params={"PARAMETER": "TEST"},
            >>> )
            >>> response.code
            200
            >>> response.text
            '{\\n  "args": {\\n    "PARAMETER": "TEST"\\n  }, \\n ...'
            >>> response.json
            {u'args': {u'PARAMETER': u'TEST'}, ...}

        Returns:
            :class:`HTTPRequester.Response`: Response instance
        """
        if params is not None:
            url += "?{params}".format(params=self._parse_params(**params))

        headers = self._prepare_headers(headers)

        request = urllib2.Request(url, headers=headers)
        response = self._get_response(request)
        return self.Response(*response)

    def post(self, url, data=None, headers=None):
        """Создает POST запрос по указанному :obj:`url`

        Args:
            url (:obj:`str`): Url для запроса
            data (:obj:`dict`, optional): Данные POST запроса
            headers (:obj:`dict`, optional): Заголовки запроса

        Examples:
            >>> requests = HTTPRequester()
            >>> response = requests.post(
            >>>     "http://httpbin.org/post",
            >>>     data={"PARAMETER": "TEST"},
            >>>     headers={"Content-Type": "application/json"},
            >>> )
            >>> response.code
            200
            >>> response.text
            '{\\n  "args": {\\n    "PARAMETER": "TEST"\\n  }, \\n ...'
            >>> response.json
            {u'args': {u'PARAMETER': u'TEST'}, ...}

        Returns:
            :class:`HTTPRequester.Response`: Response instance
        """
        if data is None:
            data = {}

        if isinstance(data, dict):
            data = urllib.urlencode(data)

        headers = self._prepare_headers(headers)

        request = urllib2.Request(url, data=data, headers=headers)
        response = self._get_response(request)
        return self.Response(*response)


class ScriptObject(host.TrassirObject, py_object):
    """Создает объект для генерации событий

    Args:
        name (:obj:`str`, optional): Имя объекта. По умолчанию :obj:`None`
        guid (:obj:`str`, optional): Guid объекта. По умолчанию :obj:`None`
        parent (:obj:`str`, optional): Guid родительского объекта. По умолчанию :obj:`None`

    Note:
        - Имя объекта по умолчанию - :meth:`BaseUtils.get_script_name`
        - Guid объекта по умолчанию строится по шаблноу ``"{script_guid}_object"``
        - Guid родительского объекта по умолчанию -
          :meth:`BaseUtils.get_server_guid`

    Examples:
        >>> # Создаем объект
        >>> scr_obj = ScriptObject()

        >>> # Проверяем текущее состояние объекта
        >>> scr_obj.health
        'OK'

        >>> # Установить флаг возле объекта
        >>> scr_obj.check_me = True

        >>> # Сгенерировать событие с текстом
        >>> scr_obj.fire_event_v2("New event")
    """

    def __init__(self, name=None, guid=None, parent=None, host_api=host):
        super(ScriptObject, self).__init__("Script")

        self._host_api = host_api
        scr_parent = host_api.stats().parent()

        self._name = name or BaseUtils.get_script_name()
        self.set_name(self._name)

        self._guid = guid or "{}-object".format(scr_parent.guid)
        self.set_guid(self._guid)

        self._parent = parent or BaseUtils.get_server_guid()
        self.set_parent(self._parent)

        self._folder = ""

        self._health = "OK"
        self._check_me = True

        self.set_initial_state([self._health, self._check_me])

        host_api.object_add(self)

    @property
    def health(self):
        """:obj:`"OK"` | :obj:`"Error"`: Состояние объекта"""
        return self._health

    @health.setter
    def health(self, value):
        if value in ["OK", "Error"]:
            self.set_state([value, self._check_me])
            self._health = value
        else:
            raise ValueError("Expected 'OK' or 'Error', got '{}'".format(value))

    @property
    def check_me(self):
        """:obj:`bool`: Флаг ``check_me`` объекта"""
        return self._check_me

    @check_me.setter
    def check_me(self, value):
        if isinstance(value, bool) or value in [1, 0]:
            value = 1 - value
            self.set_state([self._health, value])
            self._check_me = value
        else:
            raise ValueError("Expected bool or 1|0, got '{}'".format(value))

    @property
    def name(self):
        """:obj:`str`: Имя объекта"""
        return self._name

    @name.setter
    def name(self, value):
        if isinstance(value, str):
            self.set_name(value)
            self._name = value
        else:
            raise ValueError("Expected str, got {}".format(type(value).__name__))

    @property
    def folder(self):
        """:obj:`str`: Папка объекта"""
        return self._folder

    @folder.setter
    def folder(self, value):
        if not value:
            raise ValueError("Object guid can't be empty")

        if isinstance(value, str):
            if self._folder:
                self.change_folder(value)
            else:
                self.set_folder(value)
            self._folder = value
        else:
            raise ValueError("Expected str, got {}".format(type(value).__name__))

    def fire_event_v2(self, message, channel="", data=""):
        """Создает событие в Trassir

        Args:
            message (:obj:`str`): Сообщение события (``p1``)
            channel (:obj:`str`, optional): Ассоциированный с событием канал (``p2``)
            data (:obj:`str`, optional): Дополнительные данные (``p3``)
        """
        if not isinstance(data, str):
            data = BaseUtils.to_json(data, indent=None)

        self.fire_event("Script: %1", message, channel, data)


class ShotSaverError(ScriptError):
    """Base ShotSaver Exception"""

    pass


class ShotSaver(py_object):
    """Класс для сохранения скриншотов

        Args:
            shot_awaiting_time (:obj:`int`, optional): Время ожидания скриншота, с. По умолчанию :obj:`5`.
            tries_to_make_shot (:obj:`int`, optional): Кол-во попыток сохранить скриншот.
                Если в течении времени `shot_awaiting_time` скриншот не был сохранен - производится
                следующая попытка сохранить скриншот. По умолчанию :obj:`2`
            pool_size (:obj:`int`): Размер пула. По умолчанию :obj:`10`
        """

    _SHOT_NAME_TEMPLATE = (
        "{name} (%Y.%m.%d %H-%M-%S).jpg"
    )  # Template for shot file name

    def __init__(
        self, shot_awaiting_time=5, tries_to_make_shot=2, pool_size=10, host_api=host
    ):
        self._shot_awaiting_time = shot_awaiting_time
        self._tries_to_make_shot = tries_to_make_shot
        self._thread_pool = None
        self._pool_size = pool_size

        self._host_api = host_api
        self._screenshots_folder = BaseUtils.get_screenshot_folder()

    @property
    def pool_size(self):
        """:obj:`int`: Размер пула для метода :obj:`pool_shot`

        Устанавливает размер пула (кол-во одновременно созданных задач
        сохранения скриншотов). По умолчанию :obj:`10`.

        Warnings:
            Изменить данный параметр можно только до первого вызова
            метода :obj:`pool_shot`. После вызовет :obj:`RuntimeError`

        Raises:
            RuntimeError: Если пул уже создан.
        """
        return self._pool_size

    @pool_size.setter
    def pool_size(self, value):
        if self._thread_pool is None:
            self._pool_size = value
        else:
            raise RuntimeError("You can't change pool size when workers created")

    @property
    def pool_queue_size(self):
        """:obj:`int`: Размер текущей очереди в пуле

        Возвращает текущий размер очереди в пуле.

        Note:
            Если пул еще не был созда (метод :obj:`pool_shot`
            не вызывался) данный метод вернет :obj:`-1`
        """
        if self._thread_pool is None:
            return -1
        else:
            return self._thread_pool.tasks.qsize()

    @property
    def screenshots_folder(self):
        """:obj:`str`: Папка для сохранения скриншотов по умолчанию

        Устанавливает новый путь по умолчанию для сохранения скриншотов,
        если папка не существует - создает папку. Или возвращает текущий
        путь для сохранения скриншотов.

        Note:
            По молчанию :obj:`screenshots_folder`  =
            :meth:`BaseUtils.get_screenshot_folder`

        Raises:
            OSError: Если возникает ошибка при создании папки
        """
        return self._screenshots_folder

    @screenshots_folder.setter
    def screenshots_folder(self, folder):
        if not os.path.isdir(folder):
            try:
                os.makedirs(folder)
            except OSError as err:
                raise OSError("Can't make dir '{}': {}".format(folder, err))

        self._screenshots_folder = folder

    def shot(self, channel_full_guid, dt=None, file_name=None, file_path=None):
        """Делает скриншот с указанного канала

        Note:
            По умолчанию:

            - :obj:`dt=datetime.now()`
            - :obj:`file_name="{name} (%Y.%m.%d %H-%M-%S).jpg"`, где ``{name}`` - имя канала

        Args:
            channel_full_guid (:obj:`str`): Полный guid анала. Например: ``"CFsuNBzt_pV4ggECb"``
            dt (:obj:`datetime.datetime`, optional): :obj:`datetime.datetime` для скриншота.
                По умолчанию :obj:`None`
            file_name (:obj:`str`, optional): Имя файла с расширением. По умолчанию :obj:`None`
            file_path (:obj:`str`, optional): Путь для сохранения скриншота. По умолчанию :obj:`None`

        Returns:
            :obj:`str`: Полный путь до скриншота

        Raises:
            ValueError: Если в guid канала отсутствует guid сервера
            TypeError: Если ``isinstance(dt, (datetime, date)) is False``

        Examples:
            >>> ss = ShotSaver()
            >>> ss.shot("e80kgBLh_pV4ggECb")
            '/home/trassir/shots/AC-D2141IR3 Склад (2019.04.03 15-58-26).jpg'
        """
        logger.debug(
            "ShotSaver.shot({channel_full_guid}, dt={dt}, file_name={file_name}, file_path={file_path})".format(
                channel_full_guid=repr(channel_full_guid),
                dt=repr(dt),
                file_name=repr(file_name),
                file_path=repr(file_path),
            )
        )
        if "_" not in channel_full_guid:
            raise ValueError(
                "Expected full channel guid, got {}".format(channel_full_guid)
            )

        if dt is None:
            ts = "0"
            dt = datetime.now()
        else:
            if not isinstance(dt, (datetime, date)):
                raise TypeError("Expected datetime, got {}".format(type(dt).__name__))
            ts = dt.strftime("%Y%m%d_%H%M%S")

        if file_name is None:
            file_name = dt.strftime(
                self._SHOT_NAME_TEMPLATE.format(
                    name=BaseUtils.get_object_name_by_guid(channel_full_guid)
                )
            )
        if file_path is None:
            file_path = self.screenshots_folder

        self._host_api.screenshot_v2_figures(
            channel_full_guid, file_name, file_path, ts
        )

        return os.path.join(file_path, file_name)

    def _async_shot(
        self, channel_full_guid, dt=None, file_name=None, file_path=None, callback=None
    ):
        """Вызывает ``callback`` после сохнанения скриншота

        * Метод работает в отдельном потоке
        * Вызывает функцию :meth:`ShotSaver.shot`
        * Ждет выполнения функции :meth:`BaseUtils.check_file` ``tries=10``
        * Вызвает ``callback`` функцию

        Args:
            channel_full_guid (:obj:`str`): Полный guid канала. Например: ``"CFsuNBzt_pV4ggECb"``
            dt (:obj:`datetime.datetime`, optional): :obj:`datetime.datetime` для скриншота.
                По умолчанию :obj:`None`
            file_name (:obj:`str`, optional): Имя файла с расширением. По умолчанию :obj:`None`
            file_path (:obj:`str`, optional): Путь для сохранения скриншота. По умолчанию :obj:`None`
            callback (:obj:`function`): Callable function
        """
        if callback is None:
            callback = BaseUtils.do_nothing

        shot_file = ""
        for _ in xrange(self._tries_to_make_shot):
            shot_file = self.shot(
                channel_full_guid, dt=dt, file_name=file_name, file_path=file_path
            )
            if BaseUtils.is_file_exists(
                BaseUtils.win_encode_path(shot_file), self._shot_awaiting_time
            ):
                self._host_api.timeout(100, lambda: callback(True, shot_file))
                break
        else:
            self._host_api.timeout(100, lambda: callback(False, shot_file))

    @BaseUtils.run_as_thread
    def async_shot(
        self, channel_full_guid, dt=None, file_name=None, file_path=None, callback=None
    ):
        """async_shot(channel_full_guid, dt=None, file_name=None, file_path=None, callback=None)
        Вызывает ``callback`` после сохнанения скриншота

        * Метод работает в отдельном потоке
        * Вызывает функцию :meth:`ShotSaver.shot`
        * Ждет выполнения функции :meth:`BaseUtils.check_file` ``tries=10``
        * Вызвает ``callback`` функцию

        Args:
            channel_full_guid (:obj:`str`): Полный guid канала. Например: ``"CFsuNBzt_pV4ggECb"``
            dt (:obj:`datetime.datetime`, optional): :obj:`datetime.datetime` для скриншота.
                По умолчанию :obj:`None`
            file_name (:obj:`str`, optional): Имя файла с расширением. По умолчанию :obj:`None`
            file_path (:obj:`str`, optional): Путь для сохранения скриншота. По умолчанию :obj:`None`
            callback (:obj:`function`, optional): Функциюя, которая вызывается после сохранения скриншота.
                В качестве аргументов должна принимать `success`, `shot_path`. По умолчанию :obj:`None`

        Returns:
            :obj:`threading.Thread`: Thread object

        Examples:
            >>> # noinspection PyUnresolvedReferences
            >>> def callback(success, shot_path):
            >>>     # Пример callback функции
            >>>     # Args:
            >>>     #     success (bool): True если скриншот успешно сохранен, иначе False
            >>>     #     shot_path (str): Полный путь до скриншота
            >>>     if success:
            >>>         host.message("Скриншот успешно сохранен<br>%s" % shot_path)
            >>>     else:
            >>>         host.error("Ошибка сохранения скриншота <br>%s" % shot_path)
            >>>
            >>> ss = ShotSaver()
            >>> ss.async_shot("e80kgBLh_pV4ggECb", callback=callback)
        """
        self._async_shot(
            channel_full_guid,
            dt=dt,
            file_name=file_name,
            file_path=file_path,
            callback=callback,
        )

    @BaseUtils.run_as_thread
    def _pool_awaiting(self):
        self._thread_pool.wait_completion()

    # noinspection PyIncorrectDocstring
    def pool_shot(self, *args, **kwargs):
        """pool_shot(channel_full_guid, dt=None, file_name=None, file_path=None, callback=None)
        Сохраняет скриншоты в пуле.

        Одновременно в работе не более :obj:`ShotSaver.pool_size` задач.

        Warnings:
            Данный метод создает :obj:`ShotSaver.pool_size` доп. потоков.
            Потоки удаляются при отключении скрипта.

        Args:
            channel_full_guid (:obj:`str`): Полный guid канала. Например: ``"CFsuNBzt_pV4ggECb"``
            dt (:obj:`datetime.datetime`, optional): :obj:`datetime.datetime` для скриншота.
                По умолчанию :obj:`None`
            file_name (:obj:`str`, optional): Имя файла с расширением. По умолчанию :obj:`None`
            file_path (:obj:`str`, optional): Путь для сохранения скриншота. По умолчанию :obj:`None`
            callback (:obj:`function`, optional): Функциюя, которая вызывается после сохранения скриншота.
                В качестве аргументов должна принимать `success`, `shot_path`. По умолчанию :obj:`None`

        Examples:

            >>> ss = ShotSaver()
            >>> ss.pool_size = 2
            >>>
            >>> ss.pool_shot("e80kgBLh_pV4ggECb")
            >>> ss.pool_shot("e80kgBLh_pV4ggECb")
            >>> ss.pool_shot("e80kgBLh_pV4ggECb")
            >>> ss.pool_shot("e80kgBLh_pV4ggECb")
            >>>
            >>> ss.pool_queue_size
            4
        """
        if self._thread_pool is None:
            self._thread_pool = ThreadPool(self._pool_size)

        self._thread_pool.add_task(self._async_shot, *args, **kwargs)


class VideoExporterError(ScriptError):
    """Base ShotSaver Exception"""

    pass


class VideoExporter(py_object):
    """Класс для экспорта видео

    Examples:
        Смена папки экспорта видео по умолчанию

        >>> ss = VideoExporter()
        >>> ss.export_folder
        '/home/trassir/shots'
        >>> ss.export_folder += "/my_videos"
        >>> ss.export_folder
        '/home/trassir/shots/my_videos'

        | Экспорт видео с вызовом ``callback`` функции после выполнения.
        | Начало экспорта - 120 секунд назад, продолжительность 60 сек.

        >>> # noinspection PyUnresolvedReferences
        >>> def callback(success, file_path, channel_full_guid):
        >>>     # Пример callback функции
        >>>     # Args:
        >>>     #     success (bool): True если видео экспортировано успешно, иначе False
        >>>     #     file_path (str): Полный путь до видеофайла
        >>>     #     channel_full_guid (str) : Полный guid канала
        >>>     if success:
        >>>         host.message("Экспорт успешно завершен<br>%s" % file_path)
        >>>     else:
        >>>         host.error("Ошибка экспорта<br>%s" % file_path)

        >>> ss = VideoExporter()
        >>> dt_start = datetime.now() - timedelta(seconds=120)
        >>> ss.export(callback, "e80kgBLh_pV4ggECb", dt_start)
    """

    _EXPORTED_VIDEO_NAME_TEMPLATE = (
        "{name} ({dt_start} - {dt_end}){sub}.avi"
    )  # Template for shot file name

    def __init__(self, host_api=host):
        self._host_api = host_api
        self._export_folder = BaseUtils.get_screenshot_folder()
        self._now_exporting = False
        self._queue = deque()
        self._default_prebuffer = host_api.settings("archive")["prebuffer"] + 2

    @property
    def export_folder(self):
        """:obj:`str`: Папка для экспорта видео по умолчанию

        Устанавливает новый путь по умолчанию для экспорта видео,
        если папка не существует - создает папку. Или возвращает текущий
        путь для экспорта видео.

        Note:
            По молчанию ``export_folder`` = :meth:`BaseUtils.get_screenshot_folder`

        Raises:
            OSError: Если возникает ошибка при создании папки
        """
        return self._export_folder

    @export_folder.setter
    def export_folder(self, folder):
        if not os.path.isdir(folder):
            try:
                os.makedirs(folder)
            except OSError as err:
                raise OSError("Can't make dir '{}': {}".format(folder, err))

        self._export_folder = folder

    def _get_prebuffer(self, server_guid, dt_end):
        """Get prebuffer delay

        Args:
            server_guid (str): Full channel guid include server guid

        Returns:
            int: Prebuffer delay
        """
        setting_path = "/{}/archive".format(server_guid)

        try:
            prebuffer = self._host_api.settings(setting_path)["prebuffer"] + 2
        except KeyError:
            prebuffer = self._default_prebuffer

        wait_dt_end = (int(time.mktime(dt_end.timetuple())) + prebuffer) * 1000000

        return "%.0f" % wait_dt_end

    def clear_complete_tasks(self):
        for task in self._host_api.archive_export_tasks_get():
            if task["state"] != 1:
                self._host_api.archive_export_task_cancel(
                    task["id"],  # task id from archive_export_tasks_get
                    -1,  # -1 - do not wait for result, 0 - wait forever, > 0 - wait timeout_sec seconds
                    BaseUtils.do_nothing,  # callback_success
                    BaseUtils.do_nothing,  # callback_error
                )

    def _check_queue(self):
        self._host_api.timeout(10, self.clear_complete_tasks)
        if self._queue:
            args, kwargs = self._queue.popleft()
            self._export(*args, **kwargs)

    def _export_checker(self, status, callback, file_path, channel_full_guid):
        if status == 1:
            return
        elif status in [0, 2]:
            """Export failed"""
            self._host_api.timeout(
                100, lambda: callback(False, file_path, channel_full_guid)
            )
        else:
            """Export success"""
            self._host_api.timeout(
                100, lambda: callback(True, file_path, channel_full_guid)
            )

        self._now_exporting = False
        self._check_queue()

    def _export(
        self,
        channel_full_guid,
        dt_start,
        dt_end=None,
        duration=60,
        prefer_substream=False,
        file_name=None,
        file_path=None,
        callback=None,
    ):
        """Exporting file

        Call callback(success: bool, file_path: str, channel_full_guid: str)
        when export finished, and clear tasks in trassir main control panel

        Note:
            Export task adding only when previous task finished
            You can set dt_start, dt_end, or dt_start, duration for export
            if dt_end is None: dt_end = dt_start + timedelta(seconds=duration)

        Args:
            channel_full_guid (str): Full channel guid; example: "CFsuNBzt_pV4ggECb"
            dt_start (datetime): datetime instance for export start
            dt_end (datetime, optional): datetime instance for export end; default: None
            duration (int, optional): Export duration (dt_start + duration seconds) if dt_end is None; default: 10
            prefer_substream (bool, optional): If True - export substream; default: False
            file_name (str, optional): File name with extension; default: _EXPORTED_VIDEO_NAME_TEMPLATE
            file_path (str, optional): Path to save shot; default: screenshots_folder
            callback (function, optional): Function that calling when export finished
        """

        if "_" not in channel_full_guid:
            raise ValueError(
                "Expected full channel guid, got {}".format(channel_full_guid)
            )

        if not isinstance(dt_start, (datetime, date)):
            raise TypeError("Expected datetime, got {}".format(type(dt_start).__name__))

        if dt_end:
            if not isinstance(dt_end, (datetime, date)):
                raise TypeError(
                    "Expected datetime, got {}".format(type(dt_end).__name__)
                )
        else:
            dt_end = dt_start + timedelta(seconds=duration)

        ts_start = "%.0f" % (time.mktime(dt_start.timetuple()) * 1000000)
        ts_end = "%.0f" % (time.mktime(dt_end.timetuple()) * 1000000)

        channel_guid, server_guid = channel_full_guid.split("_")

        options = {
            "prefer_substream": prefer_substream,
            "postponed_until_ts": self._get_prebuffer(server_guid, dt_end),
        }

        if file_name is None:
            file_name = self._EXPORTED_VIDEO_NAME_TEMPLATE.format(
                name=BaseUtils.get_object_name_by_guid(channel_guid),
                dt_start=dt_start.strftime("%Y.%m.%d %H-%M-%S"),
                dt_end=dt_end.strftime("%Y.%m.%d %H-%M-%S"),
                sub="_sub" if prefer_substream else "",
            )

        if file_path is None:
            file_path = self.export_folder

        exporting_path = os.path.join(file_path, file_name)

        if callback is None:
            callback = BaseUtils.do_nothing

        self._now_exporting = True

        def checker(status):
            self._export_checker(status, callback, exporting_path, channel_full_guid)

        self._host_api.archive_export(
            server_guid,
            channel_guid,
            exporting_path,
            ts_start,
            ts_end,
            options,
            checker,
        )

    def export(
        self,
        channel_full_guid,
        dt_start,
        dt_end=None,
        duration=60,
        prefer_substream=False,
        file_name=None,
        file_path=None,
        callback=None,
    ):
        """Запускает экспорт или добавляет задачу экспорта в очередь.

        После завершения экспорта вызывает ``callback`` функцию
        а также очищает список задач экспорта в панеле управления Trassir.

        Note:
            Задача экспорта добавляется только после завершения предыдущей.

        Tip:
            - Вы можете задать время начала и окончания экспорта
              ``dt_start``, ``dt_end``.
            - Или можно задать время начала экспорта ``dt_start`` и
              продолжительность экспорта (в сек.) ``duration``. По умолчнию
              ``duration=60``.
            - Если ``dt_end=None`` фунция использует ``duration`` для вычисления
              времени окончания ``dt_end = dt_start + timedelta(seconds=duration)``.

        Args:
            channel_full_guid (:obj:`str`): Полный guid канала. Например: ``"CFsuNBzt_pV4ggECb"``
            dt_start (:obj:`datetime.datetime`): :obj:`datetime.datetime` начала экспорта
            dt_end (:obj:`datetime.datetime`, optional): :obj:`datetime.datetime` окончания экспорта.
                По умолчанию :obj:`None`
            duration (:obj:`int`, optional): Продолжительность экспорта, в секундах. Используется если
                ``dt_end is None``. По умолчанию ``60``
            prefer_substream (:obj:`bool`, optional): Если ``True`` - Экспортирует субпоток.
                По умолчанию ``False``
            file_name (:obj:`str`, optional): Имя экспортируемого файла. По умолчанию :obj:`None`
            file_path (:obj:`str`, optional): Путь для экспорта. По умолчанию :obj:`None`
            callback (:obj:`function`, optional): Функция, которая вызывается после завершения экспорта.
                По умолчанию :obj:`None`
        """

        args = (channel_full_guid, dt_start)
        kwargs = {
            "dt_end": dt_end,
            "duration": duration,
            "prefer_substream": prefer_substream,
            "file_name": file_name,
            "file_path": file_path,
            "callback": callback,
        }
        if self._now_exporting:
            self._queue.append((args, kwargs))
        else:
            self._export(*args, **kwargs)


class TemplateError(ScriptError):
    """Raised by Template class"""

    pass


class GUITemplate(py_object):
    """Класс для работы с шаблонами Trassir

    При инициализации находит существующий шаблон по имени или создает новый.

    Note:
        Если вручную создать два или большее шаблона с одинаковыми именами
        данный класс выберет первый попавшийся шаблон с заданным именем.

    Warning:
            Работа с контентом шаблона может привести к падениям трассира.
            Используйте данный класс на свой страх и риск!

    Tip:
        Для понимания, как формируется контент отредактируйте любой шаблон
        вручную и посмотрите что получится в скрытых параметрах трассира
        (активируются нажатием клавиши F4 в настройках трассира)
        `Настройки/Шабоны/<Имя шаблона>/content`

        Ниже предсталвены некоторые примеры шаблонов

        - Вывод одного канала ``S0tE8nfg_Or3QZu4D``
          :obj:`gui7(DEWARP_SETTINGS,zwVj07w0,dewarp(),1,S0tE8nfg_Or3QZu4D)`
        - Вывод шаблона 4х4 с каналами двумя ``Kpid6EC0_Or3QZu4D``, ``ZRtXLrgu_Or3QZu4D``
          :obj:`gui7(DEWARP_SETTINGS,zwVj07w0,dewarp(),4,Kpid6EC0_Or3QZu4D,ZRtXLrgu_Or3QZu4D,,)`
        - Вывод шаблон с минибраузером и ссылкой на https://www.google.com/
          :obj:`minibrowser(0,htmltab(,https://www.google.com/))`

    Args:
        template_name (:obj:`str`): Имя шаблон

    Examples:
        >>> # Создаем шаблон с именем "New template" и получаем его guid
        >>> template = Template("New template")
        >>> template.guid
        'Y2YFAkeZ'


        >>> # Устанавливаем на шаблон минибраузер с ссылкой на google
        >>> template.content = "minibrowser(0,htmltab(,https://www.google.com/))"

        >>> # Изменяем имя шаблона на "Google search"
        >>> template.name = "Google search"

        >>> # Открываем шаблон на первом мониторе
        >>> template.show(1)
    """

    _DEFAULT_TEMPLATE = ""

    def __init__(self, template_name, host_api=host):
        self._name = template_name
        self._host_api = host_api
        self._operator_gui = BaseUtils.get_operator_gui()
        try:
            self._guid, self._template_settings = self._find_template_guid(
                template_name
            )
        except KeyError:
            self._guid, self._template_settings = self._init_template(template_name)

    def _find_template_guid(self, name):
        """Find template guid by name

        Args:
            name (str) : Template name

        Raises:
            KeyError if can't find template
        """
        templates = self._host_api.settings("templates")
        for template_ in templates.ls():
            if name == template_.name:
                return (
                    template_.guid,
                    self._host_api.settings("templates/{}".format(template_.guid)),
                )
        raise KeyError

    def _init_template(self, name):
        """Create new template

        Args:
            name (str) : Template name
        """
        self._host_api.object(self._host_api.settings("").guid + "T").create_template(
            name, self._DEFAULT_TEMPLATE
        )
        try:
            return self._find_template_guid(name)
        except KeyError:
            raise TemplateError("Failed to create template {}".format(self._name))

    @property
    def guid(self):
        """:obj:`str`: Guid шаблона"""
        return self._guid

    @guid.setter
    def guid(self, value):
        raise RuntimeError("You can't change object guid")

    @property
    def name(self):
        """:obj:`str`: Имя шаблона"""
        return self._name

    @name.setter
    def name(self, value):
        if isinstance(value, str):
            self._name = value
            self._template_settings["name"] = value
        else:
            raise TypeError("Expected str, got {}".format(type(value).__name__))

    @property
    def content(self):
        """:obj:`str`: Контент шаблона"""
        return self._template_settings["content"]

    @content.setter
    def content(self, value):
        if isinstance(value, str):
            self._template_settings["content"] = value
        else:
            raise TypeError("Expected str, got {}".format(type(value).__name__))

    def delete(self):
        """Удаляет шаблон"""
        obj = BaseUtils.get_object(self.guid)
        if obj is None:
            raise TemplateError("Template object not found!")

        obj.delete_template()

    def show(self, monitor=1):
        """Открывает шаблон на указаном мониторе

        Args:
            monitor (:obj:`int`, optional): Номер монитора. По умолчанию ``monitor=1``
        """
        self._operator_gui.show(self.guid, monitor)


class TrObject(py_object):
    """Вспомогательный класс для работы с объектами Trassir

    Attributes:
        obj (:obj:`SE_Object`): Объект trassir :obj:`object('{guid}')` или :obj:`None`
        obj_methods (List[:obj:`str`]): Список методов объекта :attr:`TrObject.obj`
        name (:obj:`str`): Имя объекта или его guid
        guid (:obj:`str`): Guid объекта
        full_guid (:obj:`str`): Полный guid :obj:`{guid объекта}_{guid сервера}`
            или :obj:`None`
        type (:obj:`str`): Тип объекта, например :obj:`"RemoteServer"`, :obj:`"Channel"`,
            :obj:`"Grabber"`, :obj:`"User"`, и др.
        path (:obj:`str`): Путь в настройках или :obj:`None`
        parent (:obj:`str`): Guid родительского объекта или :obj:`None`
        server (:obj:`str`): Guid сервера или :obj:`None`
        settings (:obj:`SE_Settings`): Объект настроек ``settings('{path}')`` или :obj:`None`

    Raises:
        TypeError: Если неправильные параметры объекта
        ValueError: Если в имени объекта есть запятые
    """

    obj, name, guid, full_guid, type = None, None, None, None, None
    path, parent, server, settings = None, None, None, None

    def __init__(self, obj, host_api=host):
        self._host_api = host_api

        if isinstance(obj, host_api.ScriptHost.SE_Settings):
            self._load_from_settings(obj)
        elif isinstance(obj, tuple):
            if len(obj) == 4:
                self._load_from_tuple(obj)
            else:
                raise TypeError(
                    "Expected tuple(name, guid, type, parent), got tuple'{}'".format(
                        obj
                    )
                )
        else:
            raise TypeError("Unexpected object type '{}'".format(type(obj).__name__))

    @staticmethod
    def _check_object_name(object_name):
        """Check if object name hasn't got commas

        Args:
            object_name (str):

        Returns:
            str: object_name.strip()

        Raises:
            ValueError: If "," found in object name
        """
        if "," in object_name:
            raise ValueError(
                "Please, rename object '{}' without commas".format(object_name)
            )
        return object_name.strip()

    @staticmethod
    def _parse_server_from_path(path):
        """Parse server guid from full path

        Args:
            path (str): Full Trassir settings path;
                example: '/pV4ggECb/_persons/n68LOBhG' returns 'pV4ggECb'
        """
        try:
            server = path.split("/", 2)[1]
        except IndexError:
            server = None

        return server

    def _find_server_guid_for_object(self, object_guid):
        """Find server guid for object

        Args:
            object_guid (str): Object guid

        Returns:
            str: Server guid if server found
            None: If server not found
        """
        all_objects = {
            obj[1]: {"name": obj[0], "guid": obj[1], "type": obj[2], "parent": obj[3]}
            for obj in self._host_api.objects_list("")
        }

        def get_parent(child_guid):
            child = all_objects.get(child_guid, None)
            if child:
                if child["type"] == "Server":
                    return child["guid"]
                else:
                    return get_parent(child["parent"])
            else:
                return None

        return get_parent(object_guid)

    def _get_object_methods(self):
        """Get object methods"""
        if self.obj:
            return [method for method in dir(self.obj) if not method.startswith("__")]
        else:
            return []

    def _load_from_settings(self, obj):
        """Preparing attributes from SE_Settings object"""
        self.obj = BaseUtils.get_object(obj.guid)
        self.obj_methods = self._get_object_methods()

        try:
            obj_name = obj.name
        except KeyError:
            obj_name = obj.guid

        self.name = self._check_object_name(obj_name)
        self.guid = obj.guid
        self.type = obj.type
        self.path = obj.path
        self.server = self._parse_server_from_path(obj.path)
        self.settings = obj

        if self.server and self.server != self.guid:
            self.full_guid = "{0.guid}_{0.server}".format(self)

    def _load_from_tuple(self, obj):
        """Preparing attributes from tuple object"""
        self.obj = BaseUtils.get_object(obj[1])
        self.obj_methods = self._get_object_methods()
        self.name = self._check_object_name(obj[0])
        self.guid = obj[1]
        self.type = obj[2]
        self.parent = obj[3]
        self.server = self._find_server_guid_for_object(obj[1])

        if self.server and self.server != self.guid:
            self.full_guid = "{0.guid}_{0.server}".format(self)

    def __repr__(self):
        return "TrObject('{}')".format(self.name)

    def __str__(self):
        return "{self.type}: {self.name} ({self.guid})".format(self=self)


class ParameterError(ScriptError):
    """Ошибка в параметрах скрипта"""

    pass


class BasicObject(py_object):
    """"""

    def __init__(self, host_api=host):
        self._host_api = host_api
        self.this_server_guid = BaseUtils.get_server_guid()

    class UniqueNameError(ScriptError):
        """Имя объекта не уникально"""

        pass

    class ObjectsNotFoundError(ScriptError):
        """Не найдены объекты с заданными именами"""

        pass

    def _check_unique_name(self, objects, object_names):
        """Check if all objects name are unique

        Args:
            objects (list): Objects list from _get_objects_from_settings

        Raises:
            UniqueNameError: If some object name is not uniques
        """
        unique_names = []
        for obj in objects:
            if obj.name in object_names:
                if obj.name not in unique_names:
                    unique_names.append(obj.name)
                else:
                    raise self.UniqueNameError(
                        "Найдено несколько объектов {obj.type} с одинаковым именем '{obj.name}'! "
                        "Задайте уникальные имена".format(obj=obj)
                    )

    @staticmethod
    def _objects_str_to_list(objects):
        """Split object names if objects is str and strip each name

        Args:
            objects (str|list): Trassir object names in comma spaced string or list

        Returns:
            list: Stripped Trassir object names

        Raises:
            ScriptError: If object name selected more than once
        """
        if isinstance(objects, str):
            objects = objects.split(",")

        names = []
        for name in objects:
            strip_name = name.strip()
            if strip_name in names:
                raise ParameterError("Объект '{}' выбран несколько раз".format(name))
            names.append(strip_name)

        return names

    def _filter_objects_by_name(self, objects, object_names):
        """Filter object by names

        Args:
            objects (list): TrObject objects list
            object_names (str|list): Trassir object names in comma spaced string or list

        Raises:
            ObjectsNotFoundError: If len(object_name) != len(filtered_object)
        """
        object_names = self._objects_str_to_list(object_names)

        self._check_unique_name(objects, object_names)

        filtered_object = [obj for obj in objects if obj.name in object_names]

        if len(filtered_object) != len(object_names):
            channels_not_found = set(object_names) - set(
                obj.name for obj in filtered_object
            )

            try:
                object_type = objects[0].type
            except IndexError:
                object_type = "Unknown"

            raise self.ObjectsNotFoundError(
                "Не найдены объекты {object_type}: {names}".format(
                    object_type=object_type,
                    names=", ".join(name for name in channels_not_found),
                )
            )

        return filtered_object


class ObjectFromSetting(BasicObject):
    """"""

    def __init__(self):
        super(ObjectFromSetting, self).__init__()

    def _load_objects_from_settings(self, settings_path, obj_type, sub_condition=None):
        """Load objects from Trassir settings

        Args:
            settings_path (:obj:`str`): Trassir settings path. Example ``"scripts"``.
                Click F4 in the Trassir settings window to show hidden parameters.
            obj_type (:obj:`str` | :obj:`list`): Loading object type. Example ``"EmailAccount"``
            sub_condition (function, optional): Function with SE_Settings as argument to filter objects

        Returns:
            list: TrObject objects list
                Example [TrObject(...), TrObject(...), ...]
        """
        try:
            settings = self._host_api.settings(settings_path)
        except KeyError:
            settings = None

        objects = []
        if settings is not None:
            if isinstance(obj_type, str):
                obj_type = [obj_type]

            if sub_condition is None:
                sub_condition = BaseUtils.do_nothing

            for obj in settings.ls():
                if obj.type in obj_type:
                    if sub_condition(obj):
                        objects.append(TrObject(obj))
        return objects

    def _get_objects_from_settings(
        self,
        settings_path,
        object_type,
        object_names=None,
        server_guid=None,
        ban_empty_result=False,
        sub_condition=None,
    ):
        """Check if objects exists and returns list from _load_objects_from_settings

        Note:
             If object_names is not None - checking if all object names are unique

        Args:
            settings_path (:obj:`str`): Trassir settings path. Example ``"scripts"``.
                Click F4 in the Trassir settings window to show hidden parameters.
            object_type (:obj:`str` | :obj:`list`): Loading object type. Example ``"EmailAccount"``
            object_names (:obj:`str` | :obj:`list`, optional): Comma spaced string or
                list of object names. Default :obj:`None`
            server_guid (:obj:`str` | :obj:`list`, optional): Server guid. Default :obj:`None`
            ban_empty_result (:obj:`bool`, optional): If True - raise error if no one object found
            sub_condition (:obj:`func`, optional) : Function with SE_Settings as argument to filter objects

        Returns:
            list: Trassir list from _load_objects_from_settings

        Raises:
            ObjectsNotFoundError: If can't find channel
        """
        if object_names == "":
            raise ParameterError("'{}' не выбраны".format(object_type))

        if server_guid is None:
            server_guid = self.this_server_guid

        if isinstance(server_guid, str):
            server_guid = [server_guid]

        objects = []

        for guid in server_guid:
            objects += self._load_objects_from_settings(
                settings_path.format(server_guid=guid), object_type, sub_condition
            )

        if ban_empty_result and not objects:
            raise self.ObjectsNotFoundError(
                "Не найдено ниодного объекта '{}'".format(object_type)
            )

        if object_names is None:
            return objects

        else:
            return self._filter_objects_by_name(objects, object_names)


class Servers(ObjectFromSetting):
    """Класс для работы с серверами

    Examples:
        >>> srvs = Servers()
        >>> local_srv = srvs.get_local()
        [TrObject('Клиент')]
        >>> # Првоерим "Здоровье" локального сервера
        >>> local_srv[0].obj.state("server_health")
        'Health Problem'
    """

    def __init__(self):
        super(Servers, self).__init__()

    def get_local(self):
        """Возвращает локальный сервер (на котором запущен скрипт)

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._load_objects_from_settings("/", ["Client", "LocalServer"])

    def get_remote(self):
        """Возвращает список удаленных серверов

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._load_objects_from_settings("/", "RemoteServer")

    def get_all(self):
        """Возвращает список всех доступных серверов

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._load_objects_from_settings(
            "/", ["Client", "LocalServer", "RemoteServer"]
        )


class Channels(ObjectFromSetting):
    """Класс для работы с каналами

    See Also:
        `Каналы - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-channels-folder.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> channels = Channels()
        >>> selected_channels = channels.get_enabled("AC-D2121IR3W 2,AC-D9141IR2 1")
        >>> selected_channels
        [TrObject('AC-D2121IR3W 2'), TrObject('AC-D9141IR2 1')]
        >>>
        >>> # Включим ручную запись на выбранных каналах
        >>> for channel in selected_channels:
        >>>     channel.obj.manual_record_start()
        >>>
        >>> # Или добавим к имени канала его guid
        >>> for channel in selected_channels:
        >>>     channel.settings["name"] += " ({})".format(channel.guid)
    """

    def __init__(self, server_guid=None):
        super(Channels, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных каналов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            not_zombie = 1 - sett["archive_zombie_flag"]
            if not_zombie:
                try:
                    return self._host_api.settings(sett.cd("info")["grabber_path"])[
                        "grabber_enabled"
                    ]
                except KeyError:
                    return 0
            return 0

        return self._get_objects_from_settings(
            "/{server_guid}/channels",
            "Channel",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных каналов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            zombie = sett["archive_zombie_flag"]
            if not zombie:
                try:
                    return (
                        1
                        - self._host_api.settings(sett.cd("info")["grabber_path"])[
                            "grabber_enabled"
                        ]
                    )
                except KeyError:
                    return 1
            return 1

        return self._get_objects_from_settings(
            "/{server_guid}/channels",
            "Channel",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех каналов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/channels",
            "Channel",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Devices(ObjectFromSetting):
    """Класс для работы с ip устройствами

    See Also:
        `IP-устройства - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-ip-cameras-folder.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> devices = Devices()
        >>> enabled_devices = devices.get_enabled()
        >>> enabled_devices
        [TrObject('AC-D2121IR3W'), TrObject('AC-D5123IR32'), ...]
        >>>
        >>> # Перезагрузим все устройства
        >>> for dev in enabled_devices:
        >>>     dev.settings["reboot"] = 1
    """

    def __init__(self, server_guid=None):
        super(Devices, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных устройств

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["grabber_enabled"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/ip_cameras",
            "Grabber",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных устройств

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["grabber_enabled"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/ip_cameras",
            "Grabber",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех устройств

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/ip_cameras",
            "Grabber",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Scripts(ObjectFromSetting):
    """Класс для работы со скриптами

    See Also:
        `Скрипты - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-script-feature.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> scripts = Scripts()
        >>> all_scripts = scripts.get_all()
        >>> all_scripts
        [TrObject('Новый скрипт'), TrObject('HDD Health Monitor'), TrObject('Password Reminder')]
        >>>
        >>> # Отключим все скрипты
        >>> for script in all_scripts:
        >>>     script.settings["enable"] = 0
    """

    def __init__(self, server_guid=None):
        super(Scripts, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных скриптов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["enable"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Script",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных скриптов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["enable"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Script",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех скриптов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Script",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class StockScripts(ObjectFromSetting):
    """Класс для работы со встроенными скриптами

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> stock_scripts = StockScripts()
        >>> all_scripts = stock_scripts.get_all()
        >>> all_scripts
        [TrObject('MegaRAID Monitor')]
        >>>
        >>> # Отключим все скрипты
        >>> for script in all_scripts:
        >>>     script.settings["enable"] = 0
    """

    def __init__(self, server_guid=None):
        super(StockScripts, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных скриптов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["enable"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "StockScript",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных скриптов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["enable"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "StockScript",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех скриптов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "StockScript",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Rules(ObjectFromSetting):
    """Класс для работы с правилами

    See Also:
        `Правила - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-rule.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> rules = Rules()
        >>> all_rules = rules.get_all()
        >>> all_rules
        [TrObject('!Rule'), TrObject('NEW RULE'), TrObject('Новое правило')]
        >>>
        >>> # Отключим все правила
        >>> for rule in all_rules:
        >>>     rule.settings["enable"] = 0
    """

    def __init__(self, server_guid=None):
        super(Rules, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных правил

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["enable"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Rule",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных правил

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["enable"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Rule",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех правил

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен. По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Rule",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Schedules(ObjectFromSetting):
    """Класс для работы с расписаниями

    See Also:
        `Расписания - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-schedule.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> schedules = Schedules()
        >>> my_schedule = schedules.get_enabled("!Schedule")[0]
        >>> my_schedule.obj.state("color")
        'Red'
    """

    def __init__(self, server_guid=None):
        super(Schedules, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    @BaseUtils.run_as_thread
    def on_load(self, schedule_name, callback, tries=5):
        """on_load(schedule_name, callback, tries=5)
        Вызывает `callback` после загрузки расписания

        Note:
            При загрузке сервера, объект расписания становится не сразу доступен.
            Данный метод помогает предотвратить данную ошибку.

        Args:
            schedule_name (:obj:`str`): Имя расписания
            callback (:obj:`function`): Функция, которая вызывается после
                загрузки расписания.
            tries (:obj:`int`, optional): Кол-во попыток загрузки расписания.
                Каждая попытка производится с интервалом 1 с. По умолчанию :obj:`5`

        Examples
            >>> schedule = None
            >>> # noinspection PyGlobalUndefined,PyUnresolvedReferences
            >>> def on_schedule_loaded(schedule_obj):
            >>>     global schedule
            >>>     schedule = schedule_obj
            >>>
            >>>     message("Schedule '{obj.name}' ({obj.guid}) loaded".format(obj=schedule))
            >>>     schedule.activate_on_state_changes(lambda: alert(schedule.state("color")))
            >>>
            >>> Schedules().on_load("Unnamed Schedule", on_schedule_loaded)
        """
        if not schedule_name:
            raise ParameterError("Empty schedule name")

        tmp_server_guid = self.server_guid
        self.server_guid = BaseUtils.get_server_guid()

        while tries:
            obj = self.get_enabled(schedule_name)[0].obj

            if obj is None:
                tries -= 1
                time.sleep(1)
            else:
                self.server_guid = tmp_server_guid
                self._host_api.timeout(1, lambda: callback(obj))
                break
        else:
            self.server_guid = tmp_server_guid
            raise ScriptError(
                "Ошибка получения объекта расписания '{}'".format(schedule_name)
            )

    def get_enabled(self, names=None):
        """Возвращает список активных расписаний

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["enable"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Schedule",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных расписаний

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["enable"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Schedule",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех расписаний

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Schedule",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class TemplateLoops(ObjectFromSetting):
    """Класс для работы с циклическими просмотрами шаблонов

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> tmplate_loops = TemplateLoops()
        >>> tmplate_loops.get_all()
        [TrObject('Новый циклический просмотр')]
    """

    def __init__(self, server_guid=None):
        super(TemplateLoops, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных циклических просмотров шаблонов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["enable"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "TemplateLoop",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных циклических просмотров шаблонов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["enable"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "TemplateLoop",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех циклических просмотров шаблонов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "TemplateLoop",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class EmailAccounts(ObjectFromSetting):
    """Класс для работы с E-Mail аккаунтами

    See Also:
        `Добавление учетной записи e-mail - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-email-account.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> email_accounts = EmailAccounts()
        >>> email_accounts.get_all()
        [TrObject('Новая учетная запись e-mail'), TrObject('MyAccount')]
    """

    def __init__(self, server_guid=None):
        super(EmailAccounts, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_all(self, names=None):
        """Возвращает список всех E-Mail аккаунтов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "EmailAccount",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class NetworkNodes(ObjectFromSetting):
    """Класс для работы с сетевыми подключениями

    See Also:
        `Сеть - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-network-folder.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> network_nodes = NetworkNodes("client")
        >>> network_nodes.get_enabled()
        [TrObject('QuattroStationPro (172.20.0.101)'), TrObject('NSK-HD-01 (127.0.0.1)')]
    """

    def __init__(self, server_guid=None):
        super(NetworkNodes, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных сетевых подключений

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["should_be_connected"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/network",
            "NetworkNode",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных сетевых подключений

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["should_be_connected"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/network",
            "NetworkNode",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех сетевых подключений

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/network",
            "NetworkNode",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class PosTerminals(ObjectFromSetting):
    """Класс для работы с POS Терминалами

    See Also:
        `Настройка POS-терминалов - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-pos-terminals-folder.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> pos_terminals = PosTerminals()
        >>> pos_terminals.get_disabled()
        [TrObject('Касса (1)')]
    """

    def __init__(self, server_guid=None):
        super(PosTerminals, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных POS Терминалов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["pos_enable"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/pos_folder2/terminals",
            "PosTerminal",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных POS Терминалов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["pos_enable"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/pos_folder2/terminals",
            "PosTerminal",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех POS Терминалов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/pos_folder2/terminals",
            "PosTerminal",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Users(ObjectFromSetting):
    """Класс для работы с пользователями и их группами.

    See Also:
        `Пользователи - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-users-folder.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> users = Users()
        >>> users.get_groups()
        [TrObject('TEST')]
    """

    def __init__(self, server_guid=None):
        super(Users, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_groups(self, names=None):
        """Возвращает список групп пользователей

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_settings(
            "/{server_guid}/users",
            "Group",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_users(self, names=None):
        """Возвращает список пользователей

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_settings(
            "/{server_guid}/users",
            "User",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_users_by_groups(self, group_names):
        """Возвращает список пользователей из указанных групп

        Args:
            group_names (:obj:`str` | :obj:`list`): :obj:`str` - имена групп,
                разделенные запятыми или :obj:`list` - список имен.

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        if group_names is None:
            groups = [""]
        else:
            groups = [group.guid for group in self.get_groups(names=group_names)]

        def sub_condition(sett):
            return sett["group"] in groups

        return self._get_objects_from_settings(
            "/{server_guid}/users",
            "User",
            object_names=None,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )


class Templates(ObjectFromSetting):
    """Класс для работы с существующими шаблонами.

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> templates = Templates(BaseUtils.get_server_guid())
        >>> templates.get_all()
        [TrObject('Parking'), TrObject('FR'), TrObject('AT'), TrObject('AD+')]
    """

    def __init__(self, server_guid=None):
        super(Templates, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_all(self, names=None):
        """Возвращает список шаблонов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_settings(
            "/{server_guid}/templates",
            "Template",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Persons(ObjectFromSetting):
    """Класс для работы с персонами и их папками.

    See Also:
        `Персоны - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-persons-folder.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
            >>> persons = Persons()
            >>> persons.get_folders()
            [TrObject('Мошенники'), TrObject('DSSL'), TrObject('persons')]
            >>> persons.get_persons()
            [
                {
                    'name': 'Leonardo',
                    'guid': 'cJuJYAha',
                    'gender': 0,
                    'birth_date': '1980-01-01',
                    'comment': 'Comment',
                    'contact_info': 'Contact info',
                    'folder_guid': 'n68LOBhG',
                    'image': <image, str>,
                    'image_guid': 'gBHZ2vpz',
                    'effective_rights': 0,
                },
                ...
            ]
            >>> persons.get_person_by_guid("cJuJYAha")
            {
                'name': 'Leonardo',
                'guid': 'cJuJYAha',
                'gender': 0,
                'birth_date': '1980-01-01',
                'comment': 'Comment',
                'contact_info': 'Contact info',
                'folder_guid': 'n68LOBhG',
                'image': <image, str>,
                'image_guid': 'gBHZ2vpz',
                'effective_rights': 0,
            }
    """

    _PERSONS_UPDATE_TIMEOUT = 10 * 60  # Time in sec between update _persons dict

    def __init__(self, server_guid=None):
        super(Persons, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        if isinstance(server_guid, str):
            server_guid = [server_guid]

        self.server_guid = server_guid

        self._persons = None

    def _update_persons_dict(self, timeout=10):
        """Updating self._persons dict"""
        persons = self.get_persons(timeout=timeout)
        by_guid, by_name = {}, {}
        for person in persons:
            by_guid[person["guid"]] = person
            by_name[person["name"]] = person

        self._persons = {
            "update_ts": int(time.time()),
            "by_guid": by_guid,
            "by_name": by_name,
        }

    def _check_loaded_persons(self, timeout=10):
        """This method check if self._persons dict is need to be updated"""
        ts_now = int(time.time())

        if (
            self._persons is None
            or (ts_now - self._persons["update_ts"]) > self._PERSONS_UPDATE_TIMEOUT
        ):
            self._update_persons_dict(timeout=timeout)

    def get_folders(self, names=None):
        """Возвращает список папок персон

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        try:
            folders = self._get_objects_from_settings(
                "/{server_guid}/persons",
                "PersonsSubFolder",
                object_names=names,
                server_guid=self.server_guid,
            )

            if names is None or "persons" in names:
                for guid in self.server_guid:
                    try:
                        settings = self._host_api.settings("/{}/persons".format(guid))
                    except KeyError:
                        continue

                    folders.append(TrObject(settings))

        except self.ObjectsNotFoundError as err:
            folders = []
            names = self._objects_str_to_list(names)

            if names is None or "persons" in names:
                for guid in self.server_guid:
                    try:
                        settings = self._host_api.settings("/{}/persons".format(guid))
                    except KeyError:
                        continue

                    folders.append(TrObject(settings))

            if not folders:
                raise err

        return folders

    def get_persons(self, folder_names=None, timeout=10):
        """Возвращает список персон

        Note:
            Данный метод работает только с локальной БД.

        Args:
            folder_names (:obj:`str` | List[:obj:`str`], optional): :obj:`str` -
                названия папок персон, разделенные запятыми или :obj:`list` -
                список папок персон. По умолчанию :obj:`None`
            timeout (:obj:`int`, optional): Макс. время запроса к БД.
                По умолчанию ``timeout=10``

        Returns:
            List[:obj:`dict`]: Список персон - если персоны найдены

        Raises:
            EnvironmentError: Если произошла ошибка при запросе в БД.
            TrassirError: Если в данной сборке Trassir нет метода :obj:`host.service_persons_get`
        """
        tmp_server_guid = self.server_guid[:]
        self.server_guid = [self.this_server_guid]
        persons_folders = self.get_folders(names=folder_names)
        self.server_guid = tmp_server_guid[:]

        try:
            persons = self._host_api.service_persons_get(
                [folder.guid for folder in persons_folders], True, 0, 0, timeout
            )
        except AttributeError:
            raise TrassirError(
                "Данный функционал не поддерживается вашей сборкой Trassir. "
                "Попробуйте обновить ПО."
            )

        if isinstance(persons, str):
            raise EnvironmentError(persons)

        return persons

    def get_person_by_guid(self, person_guid, timeout=10):
        """Возвращает информацию о персоне по его guid

        Note:
            Для уменьшения кол-ва запросов к БД - метод создает локальную
            копию всех персон при первом запросе и обновляет ее вместе
            с последующими запросами не чаще чем 1 раз в 10 минут.

        Args:
            person_guid (:obj:`str`): Guid персоны
            timeout (:obj:`int`, optional): Макс. время запроса к БД.
                По умолчанию ``timeout=10``

        Returns:
            :obj:`dict`: Даные о персоне или :obj:`None` если персона не найдена
        """
        self._check_loaded_persons(timeout=timeout)
        return self._persons["by_guid"].get(person_guid)

    def get_person_by_name(self, person_name, timeout=10):
        """Возвращает информацию о персоне по его имени

        Note:
            Для уменьшения кол-ва запросов к БД - метод создает локальную
            копию всех персон при первом запросе и обновляет ее вместе
            с последующими запросами не чаще чем 1 раз в 10 минут.

        Args:
            person_name (:obj:`str`): Имя персоны
            timeout (:obj:`int`, optional): Макс. время запроса к БД.
                По умолчанию ``timeout=10``

        Returns:
            :obj:`dict`: Даные о персоне или :obj:`None` если персона не найдена
        """
        self._check_loaded_persons(timeout=timeout)
        return self._persons["by_name"].get(person_name)


class ObjectFromList(BasicObject):
    """"""

    def __init__(self):
        super(ObjectFromList, self).__init__()

    def _load_objects_from_list(self, obj_type, sub_condition=None):
        """Load objects from Trassir objects_list method

        Args:
            obj_type (str | list): Loading object type; example: "EmailAccount"
            sub_condition (function, optional): Function with SE_Settings as argument to filter objects

        Returns:
            list: TrObject objects list
                Example [TrObject(...), TrObject(...), ...]
        """
        if sub_condition is None:
            sub_condition = BaseUtils.do_nothing

        objects = []
        for obj in self._host_api.objects_list(obj_type):
            if sub_condition(obj):
                objects.append(TrObject(obj))

        return objects

    def _get_objects_from_list(
        self,
        object_type,
        object_names=None,
        server_guid=None,
        ban_empty_result=False,
        sub_condition=None,
    ):
        """Check if objects exists and returns list from _load_objects_from_settings

        Note:
             If object_names is not None - checking if all object names are unique

        Args:
            object_type (str|list): Loading object type; example: "EmailAccount"
            object_names (str|list, optional): Comma spaced string or list of object names; default: None
            server_guid (str|list, optional): Server guids; default: None
            ban_empty_result (bool, optional): If True - raise ObjectsNotFoundError if no one object found
            sub_condition (func, optional) : Function with SE_Settings as argument to filter objects

        Returns:
            list: Trassir list from _load_objects_from_settings

        Raises:
            ObjectsNotFoundError: If can't find channel
        """
        if object_names == "":
            raise ParameterError("'{}' не выбраны".format(object_type))

        if server_guid is None:
            server_guid = self.this_server_guid
        else:
            if isinstance(server_guid, str):
                server_guid = [server_guid]

        objects = self._load_objects_from_list(object_type, sub_condition)

        objects = [obj for obj in objects if obj.server in server_guid]

        if ban_empty_result and not objects:
            raise self.ObjectsNotFoundError(
                "Не найдено ниодного объекта '{}'".format(object_type)
            )

        if object_names is None:
            return objects

        else:
            return self._filter_objects_by_name(objects, object_names)

    def _zone_type(self, zone_obj):
        """Возвращает тип зоны для объекта

        Args:
            zone_obj (:obj:`SE_Object`): Объект trassir ``object('{guid}')``

        Returns:
            :obj:`str`: Тип объекта
            :obj:`None`: Если тип зоны неизвестен
        """

        if not isinstance(zone_obj, self._host_api.ScriptHost.SE_Object):
            raise TypeError(
                "Expected SE_Object, got '{}'".format(type(zone_obj).__name__)
            )

        try:
            guid = zone_obj.guid
            channel, server = zone_obj.associated_channel.split("_")
        except (AttributeError, ValueError):
            return None

        try:
            zones_dir = self._host_api.settings(
                "/{}/channels/{}/people_zones".format(server, channel)
            )
            for i in xrange(16):
                if zones_dir["zone%02d_guid" % i] == guid:
                    func_type = zones_dir["zone%02d_func_type" % i]
                    if isinstance(func_type, int):
                        return (
                            ["Queue", "Workplace"][func_type]
                            if func_type in range(2)
                            else "Queue"
                        )
                    else:
                        return func_type
        except KeyError:
            "not a queue or workplace"

        try:
            zones_dir = self._host_api.settings(
                "/{}/channels/{}/workplace_zones".format(server, channel)
            )
            for i in xrange(16):
                if zones_dir["zone%02d_guid" % i] == guid:
                    return "Workplace"
        except KeyError:
            "not a workplace"

        try:
            zones_dir = settings("/%s/channels/%s/deep_people" % (server, channel))
            for i in xrange(16):
                if zones_dir["zone%02d_guid" % i] == guid:
                    if zones_dir["zone%02d_type" % i] in ["border", "border_swapped"]:
                        return "Border"
                    else:
                        return "Queue"
        except KeyError:
            "not a deep people queue"


class GPIO(ObjectFromList):
    """Класс для работы с тревожными входами/выходами

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> gpio = GPIO()
        >>> gpio_door = gpio.get_inputs("Door")[0]
        >>> gpio_door.obj.state("gpio_input_level")
        'Input Low (Normal High)'
        >>> gpio_light = gpio.get_outputs("Light")[0]
        >>> gpio_light.obj.set_output_high()
    """

    def __init__(self, server_guid=None):
        super(GPIO, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_inputs(self, names=None):
        """Возвращает список тревожных входов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "GPIO Input",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_outputs(self, names=None):
        """Возвращает список тревожных выходов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "GPIO Output",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Zones(ObjectFromList):
    """Класс для работы с зонами

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> zones = Zones()
        >>> zones.get_queues("Касса 1")[0].obj.state("zone_queue")
        '5+'
    """

    def __init__(self, server_guid=None):
        super(Zones, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_people(self, names=None):
        """Возвращает список PeopleZones

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "PeopleZone",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_simt(self, names=None):
        """Возвращает список зон SIMT

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "SIMT Zone",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_workplaces(self, names=None):
        """Возвращает список рабочих зон

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        people_zones = self.get_people(names=names)

        return [
            zone
            for zone in people_zones
            if self._zone_type(zone.obj) in ["Workplace", "Рабочее место"]
        ]

    def get_queues(self, names=None):
        """Возвращает список зон очередей

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        people_zones = self.get_people(names=names)

        return [
            zone
            for zone in people_zones
            if self._zone_type(zone.obj) in ["", "Queue", "Очередь"]
        ]

    def get_shelves(self, names=None):
        """Возвращает список зон полок

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "Shelf",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Borders(ObjectFromList):
    """Класс для работы с линиями пересечения

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> borders = Borders()
        >>> borders.get_simt()
        [TrObject('DBOP')]
        >>> borders.get_all()
        [TrObject('Вход в офис'), TrObject('DBOP')]
    """

    def __init__(self, server_guid=None):
        super(Borders, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_head(self, names=None):
        """Возвращает список HeadBorders

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "HeadBorder",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_people(self, names=None):
        """Возвращает список PeopleBorders

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "PeopleBorder",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_simt(self, names=None):
        """Возвращает список SIMT Borders

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "SIMT Border",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_deep_people(self, names=None):
        """Возвращает список DeepPeopleBorders

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        people_zones = self._get_objects_from_list(
            "PeopleZone",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

        return [zone for zone in people_zones if self._zone_type(zone.obj) == "Border"]

    def get_all(self, names=None):
        """Возвращает список всех линий пересечения

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        all_borders = (
            self.get_head()
            + self.get_people()
            + self.get_simt()
            + self.get_deep_people()
        )

        if names is None:
            return all_borders
        else:
            return self._filter_objects_by_name(all_borders, names)


class Sigur(ObjectFromList):
    """Класс для работы со СКУД Sigur

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.
    """

    def __init__(self, server_guid=None):
        super(Sigur, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_access_points(self, names=None):
        """Возвращает список точек доступа

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "Access Point",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class TrassirError(ScriptError):
    """Exception if bad trassir version"""

    pass


class PokaYoke(py_object):
    """Класс для защиты от дурака

    Позволяет блокировать запуск скрипта на ПО, где это
    не предусмотрено (например, на клиенте или TOS).
    А также производить некоторые другие проверки.
    """

    _EMAIL_REGEXP = re.compile(
        r"[^@]+@[^@]+\.[^@]+"
    )  # Default regex to check emails list
    _PHONE_REGEXP = re.compile(r"[^\d,;]")  # Default regex to check phone list

    _host_api = host

    def __init__(self):
        pass

    @staticmethod
    def ban_tos():
        """Блокирует запуск скрипта на `Trassir OS`

        Raises:
            OSError: Если скрипт запускается на `Trassir OS`

        Examples:
            >>> PokaYoke.ban_tos()
            OSError: Скрипт недоступен для TrassirOS
        """
        if os.name != "nt":
            raise OSError("Скрипт недоступен для TrassirOS")

    @staticmethod
    def ban_win():
        """Блокирует запуск скрипта на `Windows OS`

        Raises:
            OSError: Если скрипт запускается на `Windows OS`

        Examples:
            >>> PokaYoke.ban_win()
            OSError: Скрипт недоступен для WindowsOS
        """
        if os.name == "nt":
            raise OSError("Скрипт недоступен для WindowsOS")

    @staticmethod
    def ban_client():
        """Блокирует запуск скрипта на `Trassir Client`

        Raises:
            TrassirError: Если скрипт запускается на `Trassir Client`

        Examples:
            >>> PokaYoke.ban_client()
            TrassirError: Скрипт недоступен для клиентской версии Trassir
        """
        if BaseUtils.get_server_guid() == "client":
            raise TrassirError("Скрипт недоступен для клиентской версии Trassir")

    @classmethod
    def ban_daemon(cls):
        """Блокирует запуск скрипта на сервре Trassir, который запущен как служба

        Raises:
            TrassirError: Если скрипт запускается на сервре Trassir,
                который запущен как служба

        Examples:
            >>> PokaYoke.ban_daemon()
            TrassirError: Скрипт недоступен для Trassir запущенным как служба
        """
        if cls._host_api.settings("system_wide_options")["daemon"]:
            raise TrassirError("Скрипт недоступен для Trassir запущенным как служба")

    @staticmethod
    def check_email_account(account_name):
        """Проверяет существование E-Mail аккаунта

        Args:
            account_name (:obj:`str`): Имя E-Mail аккаунта

        Returns:
             List[:class:`TrObject`]: Список объектов

        Raises:
            ParameterError: Если аккаунт не выбран
            ObjectsNotFoundError: Если аккаунт не найден

        Examples:
            >>> PokaYoke.check_email_account("")
            ParameterError: 'EmailAccount' не выбраны
            >>> PokaYoke.check_email_account("YourAccount")
            ObjectsNotFoundError: Не найдены объекты EmailAccount: YourAccount
            >>> PokaYoke.check_email_account("MyAccount")
            [TrObject('MyAccount')]
        """
        e_accounts = EmailAccounts(BaseUtils.get_server_guid())
        return e_accounts.get_all(account_name)

    @classmethod
    def parse_emails(cls, mailing_list, regex=None):
        """Парсит email дреса из строки

        Каждый email проверяется с помощью regex ``r"[^@]+@[^@]+\.[^@]+"``.

        Args:
            mailing_list (:obj:`str`): Список email адресов, разделенный запятыми
            regex (:obj:`SRE_Pattern`, optional): Новый regex шаблон для проверки.
                По умолчанию :obj:`None`

        Returns:
            List[:obj:`str`]: Список адресов

        Raises:
            ParameterError: Если найден невалидный email

        Examples:
            >>> PokaYoke.parse_emails("a.trubilil!dssl.ru,support@dssl.ru")
            ParameterError: Email 'a.trubilil!dssl.ru' is not valid!
            >>>
            >>> PokaYoke.parse_emails("a.trubilil@dssl.ru,support@dssl.ru")
            ['a.trubilil@dssl.ru', 'support@dssl.ru']
        """
        mailing_list = mailing_list.replace(" ", "")

        if not mailing_list:
            raise ParameterError("No emails to send!")

        if regex is None:
            regex = cls._EMAIL_REGEXP
        else:
            if not isinstance(regex, cls._EMAIL_REGEXP.__class__):
                raise TypeError(
                    "Expected re.compile, got '{}'".format(type(regex).__name__)
                )

        if isinstance(mailing_list, str):
            mailing_list = mailing_list.split(",")

        mailing_list = [mail.strip() for mail in mailing_list]

        for mail in mailing_list:
            if not regex.match(mail):
                raise ParameterError("Email '{}' is not valid!".format(mail))

        return mailing_list

    @classmethod
    def check_phones(cls, phones, regex=None):
        """Проверяет строку на валидность телефонных номеров

        Строка проверяется с помощью regex ``r"[^\d,;]"``.

        Args:
            phones (:obj:`str`): Список телефонов, разделенный запятыми или точкой с запятой
            regex (:obj:`SRE_Pattern`, optional): Новый regex шаблон для проверки.
                По умолчанию :obj:`None`

        Returns:
            :obj:`str`: Список номеров телефона

        Raises:
            ParameterError: Если найден невалидный номер телефона

        Examples:
            >>> PokaYoke.check_phones("79999999999,78888888888A")
            ParameterError: Bad chars in phone list: `A`
            >>>
            >>> PokaYoke.check_phones("a.trubilil@dssl.ru,support@dssl.ru")
            '79999999999,78888888888'
        """
        phones = phones.replace(" ", "")

        if not phones:
            raise ParameterError("No phones!")

        if regex is None:
            regex = cls._PHONE_REGEXP
        else:
            if not isinstance(regex, cls._PHONE_REGEXP.__class__):
                raise TypeError(
                    "Expected re.compile, got '{}'".format(type(regex).__name__)
                )
        bad_chars = regex.findall(phones)
        if bad_chars:
            raise ParameterError(
                "Bad chars in phone list: `{}`".format(", ".join(bad_chars))
            )

        return phones

    @classmethod
    def fire_recognizer_events(cls, enable=True, server_guid=None):
        """Проверяет "Режим для СКУД" настроек распознавания лиц.

        По умолчанию проверяет активирован ли "Режим для СКУД"
        на сервере, где запущен скрипт. По желанию можно указать
        удаленный сервер дял проверки.

        Args:
            enable (:obj:`bool`, optional): Состояние параметра. По умолчанию :obj:`True`.
            server_guid (:obj:`str`, optional): Guid сервера. По умолчанию :obj:`None`.

        Raises:
            RuntimeError: Если указанный сервер недоступен.
            EnvironmentError: Если моудль распознавания или режим для СКУД не доступны.
            TrassirError: Если текущее состояние не соотвествует необходимомому.
        """
        if server_guid is None:
            server_guid = BaseUtils.get_server_guid()

        try:
            srv_sett = cls._host_api.settings("/%s" % server_guid)
        except KeyError:
            raise RuntimeError("Сервер '%s' не доступен" % server_guid)

        fr_sett = srv_sett.cd("face_recognizer")

        if fr_sett is None:
            raise EnvironmentError("Модуль распознавания лиц не доступен на '%s'" % (srv_sett.name or srv_sett.guid))

        try:
            if fr_sett["fire_recognizer_events"] != enable:
                raise TrassirError("Пожалуйста, {} 'Режим для СКУД' в настройках распознавания лиц".format("активируйте" if enable else "отключите"))
        except KeyError:
            raise EnvironmentError("'Режим для СКУД' не доступен. Пожалуйста, обновите сервер trassir.")


class SenderError(Exception):
    """Base Sender Exception"""

    pass


class Sender(py_object):
    _HTML_IMG_TEMPLATE = """<img src="data:image/png;base64,{img}" {attr}>"""

    def __init__(self, host_api=host):
        self._host_api = host_api

    @staticmethod
    def _get_base64(image_path):
        """Returns base64 image

        Args:
            image_path (str): Image full path
        """
        image_path = BaseUtils.win_encode_path(image_path)
        if os.path.isfile(image_path):
            with open(image_path, "rb") as image_file:
                return base64.b64encode(image_file.read())

    @staticmethod
    def _get_html_img(image_base64, **kwargs):
        """Returns html img

        Args:
            image_base64 (str): Base64 image
        """
        return BaseUtils.base64_to_html_img(image_base64, **kwargs)

    def text(self, text):
        """Send text

        Args:
            text (str): Text message
        """
        pass

    def image(self, image_path, text=""):
        """Send image and optional text

        Args:
            image_path (str): Image path
            text (str, optional): Text message; default: ""
        """
        pass

    def files(self, file_paths, text=""):
        """Send file or list of files

        Args:
            file_paths (str|list): File path or list of paths
            text (str, optional): Text message; default: ""
        """
        pass


class PopupSender(Sender):
    """Класс для показа всплывающих окон в правом нижнем углу экрана

    Args:
        width (:obj:`int`, optional): Ширина изображения, px.
            По умолчанию :obj:`width=400`

    Examples:
        >>> sender = PopupSender(300)
        >>> sender.text("Hello World!")

            .. image:: images/popup_sender.text.png

        >>> sender.image(r"manual\en\cloud-devices-16.png")

            .. image:: images/popup_sender.image.png
    """

    def __init__(self, width=400):
        super(PopupSender, self).__init__()
        self._attr = {"width": width}

    def text(self, text, popup_type="message"):
        """Показывает текст во всплывающем окне

        Вызывает один из методов Trassir :obj:`host.alert`,
        :obj:`host.message` или :obj:`host.error` с текстом

        Args:
            text (:obj:`str`): Текст сообщения
            popup_type (:obj:`"message"` | :obj:`"alert"` | :obj:`"error"`, optional)
                Тип сообщения. По умолчанию :obj:`"message"`
        """

        if popup_type == "alert":
            self._host_api.alert(text)
        elif popup_type == "error":
            self._host_api.error(text)
        else:
            self._host_api.message(text)

    def image(self, image_path, text="", popup_type=None):
        """Показывает изображение во всплывающем окне

        Args:
            image_path (:obj:`str`): Полный путь до изображения
            text (:obj:`str`, optional): Текст сообщения. По умолчанию :obj:`""`
            popup_type (:obj:`"message"` | :obj:`"alert"` | :obj:`"error"`, optional)
                Тип сообщения. По умолчанию :obj:`"message"`
        """
        image_base64 = self._get_base64(image_path)

        if not image_base64:
            self.text("<b>File not found</b><br>{}".format(image_path), popup_type)
            return

        html_image = BaseUtils.base64_to_html_img(image_base64, **self._attr)

        html = "{image}"
        if text:
            html = "<b>{text}</b><br>{image}"

        self.text(html.format(text=text, image=html_image), popup_type)


class PopupWithBtnSender(Sender):
    """Класс для показа всплывающих окон с кнопкой `Оk`

    Note:
        | Для закрытия окна необходимо нажать кнопку `Ok` в течении 60 сек.
        | После 60 сек окно закрывается автоматически.

    Args:
        width (:obj:`int`, optional): Ширина изображения, px.
            По умолчанию :obj:`width=800`

    Examples:
        >>> sender = PopupWithBtnSender()
        >>> sender.text("Hello World!")

            .. image:: images/popup_with_btn_sender.text.png

        >>> sender.image(r"manual\en\cloud-devices-16.png")

            .. image:: images/popup_with_btn_sender.image.png
    """

    def __init__(self, width=800):
        super(PopupWithBtnSender, self).__init__()
        self._attr = {"width": width}

    def text(self, text):
        """Показывает текст во всплывающем окне

        Вызывает метод Trassir :obj:`host.question` с текстом

        Args:
            text (:obj:`str`): Текст сообщения
        """
        self._host_api.question(
            "<pre>{}</pre>".format(text), "Ok", BaseUtils.do_nothing
        )

    def image(self, image_path, text=""):
        """Показывает изображение во всплывающем окне

        Args:
            image_path (:obj:`str`): Полный путь до изображения
            text (:obj:`str`, optional): Текст сообщения. По умолчанию :obj:`""`
        """
        image_base64 = self._get_base64(image_path)

        if not image_base64:
            self.text("<b>File not found</b><br>{}".format(image_path))
            return

        html_image = BaseUtils.base64_to_html_img(image_base64, **self._attr)

        html = "{image}"
        if text:
            html = "<b>{text}</b><br>{image}"

        self.text(html.format(text=text, image=html_image))


class EmailSender(Sender):
    """Класс для отправки уведомлений, изображений и файлов на почту

    Note:
        По умолчанию тема сообщений соответствует шаблону
        ``{server_name} -> {script_name}``

    Tip:
        При отправке изображения с текстом предпочтительней использовать метод
        :meth:`EmailSender.image` с необязательным аргументом :obj:`text` чем
        :meth:`EmailSender.text` с необазательным аргументом :obj:`attachments`

    Args:
        account (:obj:`str`): E-Mail аккаунт trassir. Проверяется
            методом :meth:`PokaYoke.check_email_account`
        mailing_list (:obj:`str`): Список email адресов для отправки писем
            разделенный запятыми. Проверяется и парсится в список методом
            :meth:`PokaYoke.parse_emails`
        subject (:obj:`str`, optional): Общая тема для сообщений.
            По умолчанию :obj:`None`
        max_size (:obj:`int`, optional): Максимальный размер вложения, байт.
            По умолчанию 25 * 1024 * 1024

    Examples:
        >>> sender = EmailSender("MyAccount", "my_mail@google.com")
        >>> sender.text("Hello World!")

            .. image:: images/email_sender.text.png

        >>> sender.image(r"manual\en\cloud-devices-16.png")

            .. image:: images/email_sender.image.png

        >>> sender.files([r"manual\en\cloud.html", r"manual\en\cloud.png"])

            .. image:: images/email_sender.files.png
    """

    def __init__(self, account, mailing_list, subject=None, max_size=None):
        super(EmailSender, self).__init__()

        PokaYoke.check_email_account(account)

        self.max_size = max_size or 25 * 1024 * 1024

        self._account = account
        self._mailing_list = PokaYoke.parse_emails(mailing_list)

        self._subject_default = subject or self._generate_subject()

        logger.info(
            "EmailSender({}, {}, subject={}, max_size={})".format(
                repr(account),
                repr(mailing_list),
                repr(self._subject_default),
                repr(self.max_size),
            )
        )

    def _generate_subject(self):
        """Returns `server name` -> `script name`"""
        subject = "{server_name} -> {script_name}".format(
            server_name=self._host_api.settings("").name or "Client",
            script_name=self._host_api.stats().parent()["name"],
        )
        return subject

    def _group_files_by_max_size(self, file_paths, max_size):
        """Split files to groups. Size of each group is less then max_size

        Args:
            file_paths (list): List of files
            max_size (int): Max group size, bytes
        """
        group = []
        cur_size = 0
        for idx, file_path in enumerate(file_paths):
            file_size = os.stat(BaseUtils.win_encode_path(file_path)).st_size
            if not cur_size or (cur_size + file_size) < max_size:
                cur_size += file_size
                group.append(file_path)
            else:
                break
        else:
            return [group]

        return [group] + self._group_files_by_max_size(file_paths[idx:], max_size)

    def text(self, text, subject=None, attachments=None):
        """Отправка текстового сообщения

        Args:
            text (:obj:`str`): Текст сообщения
            subject (:obj:`str`, optional): Новая тема сообщения.
                По умолчанию :obj:`None`
            attachments (:obj:`list`, optional): Список вложений.
                По умолчанию :obj:`None`
        """
        if attachments is None:
            attachments = []
        self._host_api.send_mail_from_account(
            self._account,
            self._mailing_list,
            subject or self._subject_default,
            text,
            attachments,
        )

    def image(self, image_path, text="", subject=None):
        """Отправка изображения

        Args:
            image_path (:obj:`str`): Полный путь до изображения
            text (:obj:`str`, optional): Текст сообщения.
                По умолчанию :obj:`""`
            subject (:obj:`str`, optional): Новая тема сообщения.
                По умолчанию :obj:`None`
        """
        self.files([image_path], text=text, subject=subject)

    def files(self, file_paths, text="", subject=None, callback=None):
        """Отправка файлов

        Note:
            Если отправляется несколько файлов они могут быть разделены на
            несколько сообщений, основываясь на максимальном размере вложений.

        Args:
            file_paths (:obj:`str` | :obj:`list`): Путь до файла или список
                файлов для отправки
            text (:obj:`str`, optional): Текст сообщения.
                По умолчанию :obj:`""`
            subject (:obj:`str`, optional): Новая тема сообщения.
                По умолчанию :obj:`None`
            callback (:obj:`function`, optional): Функция, которая вызывается после
                отправки частей
        """
        logger.debug(
            "EmailSender.files({}, text={})".format(repr(file_paths), repr(text))
        )
        if isinstance(file_paths, str):
            file_paths = [file_paths]

        if callback is None:
            callback = BaseUtils.do_nothing

        files_to_send = []
        for path in file_paths:
            if BaseUtils.is_file_exists(path):
                files_to_send.append(path)
            else:
                text += "\nFile not found: {}".format(path)

        file_groups = self._group_files_by_max_size(files_to_send, self.max_size)

        for grouped_files in file_groups:
            logger.debug(
                "EmailSender.files: grouped_files: {}".format(repr(grouped_files))
            )
            self.text(text, subject=subject, attachments=grouped_files)
            callback(grouped_files)


class TelegramSender(Sender):
    """Работа с телеграм ботом `@trassirbot <https://t.me/trassirbot>`_

    Warnings:
        | Cкрипт должен быть запущен на **сервере** Trassir.
        | На Клиенте скрипт вызовет ошибку ``ServerKeyError``

    Args:
        telegram_ids (:obj:`str`): Id пользователей, через запятую.

    Examples:
        >>> # Можно указать id для рассылки при инициализации
        >>> # класса, для всех уведомлений
        >>> sender = TelegramSender("123456789")
        >>> sender.text("Hello World!")

            .. image:: images/telegram_sender.text.png

        >>> sender.image(r"manual\en\cloud-devices-16.png")

            .. image:: images/telegram_sender.image.png

        >>> sender.files([r"manual\en\cloud.html", r"manual\en\cloud.png"])

            .. image:: images/telegram_sender.files.png

        >>> # Или можно опередовать telegram id при вызове методов
        >>> sender = TelegramSender()
        >>> sender.text("Hello World!", tg_users=[123456789])

            .. image:: images/telegram_sender.text.png

        >>> sender.image(r"manual\en\cloud-devices-16.png", tg_users=[123456789])

            .. image:: images/telegram_sender.image.png

        >>> sender.files([r"manual\en\cloud.html", r"manual\en\cloud.png"], tg_users=[123456789])

            .. image:: images/telegram_sender.files.png
    """

    def __init__(self, telegram_ids=None):
        super(TelegramSender, self).__init__()
        self._host_api.exec_encoded(tbot_service)
        self._tbot_api = TBotAPI()
        if telegram_ids is not None:
            self.telegram_ids = TBotAPI.prepare_users(telegram_ids)
        else:
            self.telegram_ids = None

    def text(self, text, tg_users=None):
        """Отправка текстового сообщения

        Args:
            text (:obj:`str`): Текст сообщения.
            tg_users (List[:obj:`int`], optional): Список id пользователей
                telegram для отправки отдельных сообщений. По умолчанию :obj:`None`
        """
        if tg_users is None:
            tg_users = self.telegram_ids

        self._tbot_api.send_message(tg_users, text)

    def image(self, image_path, text="", tg_users=None, remove=False):
        """Отправка изображения

        Args:
            image_path (:obj:`str` | List[:obj:`str`]): Полный путь до изображения или
                список путей
            text (:obj:`str`, optional): Текст сообщения.
                По умолчанию :obj:`""`
            tg_users (List[:obj:`int`], optional): Список id пользователей
                telegram для отправки отдельных сообщений. По умолчанию :obj:`None`
            remove (bool, optional): Удалить файл после отправки или нет. По умолчанию :obj:`False`
        """
        if tg_users is None:
            tg_users = self.telegram_ids

        if len(text) > 150:
            self.text(text, tg_users=tg_users)
            text = None

        if isinstance(image_path, list):
            self._tbot_api.send_image_album(
                tg_users, image_path, captions=[text] or None, remove=remove
            )

        else:
            if not os.path.isfile(image_path):
                self.text("Image not found: {}".format(image_path))
                return

            self._tbot_api.send_image(tg_users, image_path, caption=text, remove=remove)

    def files(self, file_paths, text="", tg_users=None, remove=False):
        """Отправка файлов

        Args:
            file_paths (:obj:`str` | :obj:`list`): Путь до файла или список
                файлов для отправки
            text (:obj:`str`, optional): Текст сообщения.
                По умолчанию :obj:`""`
            tg_users (List[:obj:`int`], optional): Список id пользователей
                telegram для отправки отдельных сообщений. По умолчанию :obj:`None`
            remove (bool, optional): Удалить файл после отправки или нет. По умолчанию :obj:`False`
        """

        if tg_users is None:
            tg_users = self.telegram_ids

        if isinstance(file_paths, str):
            file_paths = [file_paths]

        if text and len(file_paths) == 1:
            self.text(text, tg_users=tg_users)
            text = ""

        files_not_found_text = ""
        for path in file_paths:
            if os.path.isfile(BaseUtils.win_encode_path(path)):
                self._tbot_api.send_document(
                    tg_users, path, caption=text, remove=remove
                )
            else:
                files_not_found_text += "\nFile not found: {}".format(path)

        if files_not_found_text:
            self.text(files_not_found_text, tg_users=tg_users)


class SMSCSenderError(SenderError):
    """Raises with SMSCSender errors"""

    pass


class SMSCSender(Sender):
    """Класс для отправки сообщений с помощью сервиса smsc.ru

    See Also:
        `https://smsc.ru/api/http/ <https://smsc.ru/api/http/>`_

    Note:
        | Номера проверяются методом
          :meth:`PokaYoke.check_phones`
        | Также при первом запуске скрипт проверяет данные авторизации

    Warnings:
        | По умолчанию сервис smsc.ru отправляет сообщения от своего имени *SMSC.RU.*
          При этом отправка на номера Мегафон/Йота **недоступна** т.к. имя *SMSC.RU*
          заблокировано оператором.
        |
        | Мы настоятельно **НЕ** рекомендуем использовать стандартное имя *SMSC.RU.*
        |
        | Для отправки смс от вашего буквенного имени необходимо его
          создать в разделе - https://smsc.ru/senders/ и зарегистрировать для
          операторов в колонке Действия по кнопке Изменить (после заключения договора
          согласно инструкции - https://smsc.ru/contract/info/ ) а также приложить
          гарантийное письмо на МТС в личный кабинет http://smsc.ru/documents/ и
          отправить на почту inna@smsc.ru

    Args:
        login (:obj:`str`): SMSC Логин
        password (:obj:`str`): SMSC Пароль
        phones (:obj:`str`): Список номеров для отправки смс резделенный
            запятыми или точкой с запятой
        translit(:obj:`bool`, optional): Переводить сообщение в
            транслит. По умолчанию :obj:`True`

    Raises:
        SMSCSenderError: При любых ошибках с отправкой сообщения

    Examples:
        >>> sender = SMSCSender("login", "password", "79999999999")
        >>> sender.text("Hello World!")

            .. image:: images/smsc_sender.text.png
    """

    _BASE_URL = "https://smsc.ru/sys/send.php?{params}"
    _ERROR_CODES = {
        1: "URL Params error",
        2: "Invalid login or password",
        3: "Not enough money",
        4: "Your IP is temporary blocked. More info: https://smsc.ru/faq/99",
        5: "Bad date format",
        6: "Message is denied (by text or sender name)",
        7: "Bad phone format",
        8: "Can't send message to this number",
        9: "Too many requests",
    }

    def __init__(self, login, password, phones, translit=True):
        super(SMSCSender, self).__init__()
        if not login:
            raise SMSCSenderError("Empty login")
        if not password:
            raise SMSCSenderError("Empty password")

        self._params = {
            "login": urllib.quote(login),  # Login
            "psw": urllib.quote(password),  # Password or MD5 hash
            "phones": urllib.quote(
                PokaYoke.check_phones(phones)
            ),  # Comma or semicolon spaced phone list
            "fmt": 3,  # Response format: 0 - string; 1 - integers; 2 - xml; 3 - json
            "translit": 1 if translit else 0,  # If 1 - transliting message
            "charset": "utf-8",  # Message charset: "windows-1251"|"utf-8"|"koi8-r"
            "cost": 3,  # Message cost in response: 0 - msg; 1 - cost; 2 - msg+cost, 3 - msg+cost+balance
        }

        self._check_account()

    def _get_link(self, **kwargs):
        """Returns get link"""
        params = self._params.copy()
        params.update(kwargs)
        url = self._BASE_URL.format(params=urllib.urlencode(params))

        return url

    def _request_callback(self, code, result, error):
        """Callback for async_get"""
        if code != 200:
            raise SMSCSenderError("RequestError [{}]: {}".format(code, error))
        else:
            try:
                data = json.loads(result)
            except ValueError:
                data = {"error_code": 0, "error": "JSON loads error: {}".format(result)}

            error_code = data.get("error_code")
            if error_code is not None:
                error = self._ERROR_CODES.get(error_code)
                if not error:
                    error = data.get("error", "Unknown error")
                raise SMSCSenderError(
                    "ResponseError [{}]: {}".format(error_code, error)
                )

    def _check_account(self):
        """Send test request to smsc server"""
        url = self._get_link(cost=1, mes=urllib.quote("Hello world!"))
        self._host_api.async_get(url, self._request_callback)

    def text(self, text):
        """Отправка текстового сообщения

        Args:
            text (:obj:`str`): Текст сообщения.
        """

        url = self._get_link(mes=text)

        self._host_api.async_get(url, self._request_callback)


class FtpUploadTracker:
    """Upload progress class"""

    size_written = 0.0
    last_shown_percent = 0

    def __init__(self, file_path, callback, host_api=host):
        self._host_api = host_api
        self.total_size = os.path.getsize(BaseUtils.win_encode_path(file_path))
        self.file_path = file_path
        self.callback = callback

    # noinspection PyUnusedLocal
    def handle(self, block):
        """Handler for storbinary

        See Also:
            https://docs.python.org/2/library/ftplib.html#ftplib.FTP.storbinary
        """
        self.size_written += 1024.0
        percent_complete = round((self.size_written / self.total_size) * 100)

        if self.last_shown_percent != percent_complete:
            self.last_shown_percent = percent_complete
            self._host_api.timeout(
                100, lambda: self.callback(self.file_path, int(percent_complete), "")
            )


class FTPSenderError(SenderError):
    """Raises with FTPSender errors"""

    pass


class FTPSender(Sender):
    """Класс для отправки файлов на ftp сервер

    При инициализации проверят подключение к ftp серверу. Файлы отправляет
    по очереди. Максимальный размер очереди можно изменить. Во время
    выполнения передает текущий прогресс отправки файла в callback функцию.

    Note:
        Помимо прогресса в функцию callback может вернуться код ошибки.
            - -1 Файл не существует.
            - -2 Ошибка отправки на ftp, файл будет повторно отправлен.
            - -3 Неизвестная ошибка.


    Args:
        host (:obj:`str`): Адрес ftp сервера.
        port (:obj:`int`, optional): Порт ftp сервера. По умолчанию :obj:`port=21`
        user (:obj:`str`, optional): Имя пользователя. По умолчанию :obj:`"anonymous"`
        passwd (:obj:`str`, optional): Пароль пользователя. По умолчанию :obj:`passwd=""`
        work_dir (:obj:`str`, optional): Директория на сервре для сохранения файлов.
            По умолчанию :obj:`None`
        callback (:obj:`function`, optional): Callable function. По умолчанию :obj:`None`
        queue_maxlen (:obj:`int`, optional): Максимальная длина очереди на отправку.
            По умолчанию :obj:`queue_maxlen=1000`

    Examples:
        >>> # noinspection PyUnresolvedReferences
        >>> def callback(file_path, progress, error):
        >>>     # Пример callback функции, которая отображает
        >>>     # текущий прогресс в счетчике запуска скрипта
        >>>     # Args:
        >>>     #   file_path (str): Путь до файла
        >>>     #   progress (int): Текущий прогресс передачи файла, %
        >>>     #   error (str | Exception): Ошибка при отправке файла, если есть
        >>>     host.stats()["run_count"] = progress
        >>>     if error:
        >>>         host.error(error)
        >>>
        >>>     if progress == 100:
        >>>         host.timeout(3000, lambda: os.remove(BaseUtils.win_encode_path(file_path)))
        >>>
        >>> sender = FTPSender("172.20.0.10", 21, "trassir", "12345", work_dir="/test_dir/", callback=callback)
        >>> sender.files(r"D:\Shots\export_video.avi")
    """

    # noinspection SpellCheckingInspection,PyShadowingNames
    def __init__(
        self,
        host,
        port=21,
        user="anonymous",
        passwd="",
        work_dir=None,
        callback=None,
        queue_maxlen=1000,
    ):
        super(FTPSender, self).__init__()
        self._host = host
        self._port = port
        self._user = user
        self._passwd = passwd
        self._work_dir = work_dir

        self.queue = deque(maxlen=queue_maxlen)

        self._ftp = None

        if callback is None:
            callback = BaseUtils.do_nothing

        self.callback = callback

        self._work_now = False

        self._check_connection()

    def _check_connection(self):
        """Check if it possible to connect"""
        try:
            ftp = ftplib.FTP()
            ftp.connect(self._host, self._port, timeout=10)
            ftp.login(self._user, self._passwd)
        except ftplib.all_errors as err:
            raise FTPSenderError(err)
        if self._work_dir:
            try:
                ftp.cwd(self._work_dir)
            except ftplib.error_perm:
                ftp.mkd(self._work_dir)
                ftp.cwd(self._work_dir)

        ftp.quit()

    def _get_connection(self):
        """Connecting to ftp

        Returns:
            ftplib.FTP: Ftp object
        """
        try:
            ftp = ftplib.FTP()
            ftp.connect(self._host, self._port, timeout=10)
            ftp.login(self._user, self._passwd)
            if self._work_dir:
                try:
                    ftp.cwd(self._work_dir)
                except ftplib.error_perm:
                    ftp.mkd(self._work_dir)
                    ftp.cwd(self._work_dir)
            ftp.encoding = "utf-8"
            return ftp
        except ftplib.all_errors:
            return

    def _close_connection(self):
        """Close ftp connection"""
        try:
            if self._ftp is not None:
                self._ftp.close()
        finally:
            self._ftp = None

    def _send_file(self, file_path, work_dir=None):
        """Storbinary file with self.ftp

        Args:
            file_path (str): Full file path
            work_dir (str): Work dir on ftp
        """
        if work_dir is not None:
            if self._work_dir:
                work_dir = os.path.normpath("{}/{}".format(self._work_dir, work_dir))
            try:
                self._ftp.cwd(work_dir)
            except ftplib.error_perm:
                self._ftp.mkd(work_dir)
                self._ftp.cwd(work_dir)

        file_name = os.path.basename(file_path)
        upload_tracker = FtpUploadTracker(file_path, self.callback)
        with open(BaseUtils.win_encode_path(file_path), "rb") as opened_file:
            self._ftp.storbinary(
                "STOR " + file_name, opened_file, 1024, upload_tracker.handle
            )

    @BaseUtils.run_as_thread
    def _sender(self):
        """Send files in queue"""
        if self.queue:
            if self._ftp is None:
                self._ftp = self._get_connection()

            if self._ftp:
                work_dir = None
                file_path = self.queue.popleft()

                if isinstance(file_path, tuple):
                    file_path, work_dir = file_path

                if BaseUtils.is_file_exists(BaseUtils.win_encode_path(file_path)):
                    try:
                        self._send_file(file_path, work_dir)

                    except ftplib.all_errors as err:
                        self._host_api.timeout(
                            100, lambda: self.callback(file_path, -2, error=err)
                        )
                        self.queue.append(file_path)
                        self._close_connection()

                    except Exception as err:
                        self._host_api.timeout(
                            100, lambda: self.callback(file_path, -3, error=err)
                        )

                else:
                    self._host_api.timeout(
                        100,
                        lambda: self.callback(file_path, -1, error="File not found"),
                    )

            self._host_api.timeout(500, self._sender)
        else:
            self._work_now = False
            self._close_connection()

    def files(self, file_paths, *args):
        """Отправка файлов

        Note:
            Можно указать отдельный путь на ftp сервере для каждого файла.
            Для этого список файлов на отправку должен быть приведен к виду
            ``[(shot_path, ftp_path), ...]`` При этом так же будет учитываться
            глобальная папка :obj:`work_dir` заданная при инициализации класса.

        Args:
            file_paths (:obj:`str` | :obj:`list`): Путь до файла или список
                файлов для отправки
        """
        if not isinstance(file_paths, list):
            file_paths = [file_paths]

        self.queue.extend(file_paths)
        if not self._work_now:
            self._work_now = True
            self._sender()
