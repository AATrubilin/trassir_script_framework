# -*- coding: utf-8 -*-
"""
<parameters>
    <company>AATrubilin</company>
    <title>trassir_script_framework</title>
    <version>0.65</version>
</parameters>
"""

# _SERVICE_VERSION = 0.65
_TBOT_SERVICE = """
    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
    8jsUUoVJ1Q8TwCqvZpWXsfS4NRU2RF5TidI=
"""

import re
import os
import sys
import ssl
import time
import json

import pickle
import base64
import ftplib
import urllib
import urllib2
import httplib
import logging
import threading
import subprocess

if os.name == "nt":
    import winsound

from Queue import Queue
from functools import wraps
from collections import deque
from xml.etree import ElementTree
from __builtin__ import object as py_object
from datetime import datetime, date, timedelta
from logging.handlers import RotatingFileHandler

import host

logger = logging.getLogger()  # pylint: disable=C0103


class ScriptError(Exception):
    """Base script exception"""

    def __init__(self, *args):
        super(ScriptError, self).__init__(*args)
        host.timeout(1, self.rise_from_thread)

    def rise_from_thread(self):
        raise self


class HostLogHandler(logging.Handler):
    """Trassir main log handler"""

    def __init__(self):
        super(HostLogHandler, self).__init__()

    def emit(self, record):
        msg = self.format(record)
        host.log_message(msg)


class PopupHandler(logging.Handler):
    """Trassir popup handler"""

    def __init__(self):
        super(PopupHandler, self).__init__()
        self._popups = {
            "CRITICAL": host.error,
            "FATAL": host.error,
            "ERROR": host.error,
            "WARN": host.alert,
            "WARNING": host.alert,
            "INFO": host.message,
            "DEBUG": host.message,
            "NOTSET": host.message,
        }

    def emit(self, record):
        msg = self.format(record)
        self._popups[record.levelname](msg)


class DuplicateFilter(logging.Filter):  # pylint: disable=R0903
    """Suppressing multiple messages with same content.

    Tracking last logged record and filter out any
    repeated (similar) records. Output something more rsyslog style.

    Example:
        --- The last message repeated 3 times
    """

    def __init__(self):
        super(DuplicateFilter, self).__init__()
        self._last_log = None
        self._last_log_count = 1

    def filter(self, record):
        record.duplicates = ""
        current_log = (record.module, record.levelno, record.msg)
        if current_log == self._last_log:
            self._last_log_count += 1
            return False
        else:
            if self._last_log_count > 1:
                record.duplicates = (
                    "--- The last message repeated %s times\n" % self._last_log_count
                )
            self._last_log = current_log
            self._last_log_count = 1
            return True


class BaseUtils:  # pylint: disable=R0904,C1001
    """Base utils for your scripts"""

    _FOLDERS = {obj[1]: obj[3] for obj in host.objects_list("Folder")}
    _TEXT_FILE_EXTENSIONS = [".txt", ".csv", ".log"]
    _LPR_FLAG_BITS = {
        "LPR_UP": 0x00001,
        "LPR_DOWN": 0x00002,
        "LPR_BLACKLIST": 0x00004,
        "LPR_WHITELIST": 0x00008,
        "LPR_INFO": 0x00010,
        "LPR_FIRST_LANE": 0x01000,
        "LPR_SECOND_LANE": 0x02000,
        "LPR_THIRD_LANE": 0x04000,
        "LPR_EXT_DB_ERROR": 0x00020,
        "LPR_CORRECTED": 0x00040,
    }
    _EVENT_STR_TO_INT = {
        "Border Crossed A -> B": -2010220362,
        "Border Crossed B -> A": 881900680,
        "Border %1 A-B Crossing": 1745631458,
        "Border %1 B-A Crossing": 1382034490,
        "Border %1 Unique Object A-B Crossing": -1764400102,
        "Border %1 Unique Object B-A Crossing": -755097134,
        "Connected To %1 under %2": -567223767,
        "Connection Established": 1689573124,
        "Connection Lost": -1739961019,
        "Deny: %1 (%2)": 1400866841,
        "Disconnected From %1": 854687023,
        "FACS Connected": 928164014,
        "FACS Disconnected": -528751441,
        "Face Detected": -145480902,
        "Face Recognized": 1904675878,
        "Fire Detected": -2095846277,
        "Fire Stopped": 1556160195,
        "HDD Broken": -359176531,
        "HDD Error": -2035571413,
        "HDD Restored": 2054776042,
        "Health Turns Bad": -1338064969,
        "Health Turns Good": 1737407416,
        "Input High to Low": 1260011944,
        "Input Low to High": 108469542,
        "Login Failed, %1 from %2": -1785217387,
        "Login Successful, %1 from %2": 1634136664,
        "Logout, %1 from %2": 334348171,
        "Motion Start": -1960416690,
        "Motion Stop": 452886769,
        "No Connection to Cloud": -1220531757,
        "Object Entered the Zone": -1484834142,
        "Object Left the Zone": 1838034845,
        "Output High to Low": -994975116,
        "Output Low to High": 842360770,
        "Pass: %1 (%2)": 1944146750,
        "Photo Detected": -220640968,
        "Script: %1": 865778551,
        "Shutdown": 390175606,
        "Signal Lost": -997068283,
        "Signal Restored": -1801421619,
        "Slow Down Detected": -438590449,
        "Software update to version %1 succeeded": 1188419157,
        "Startup": -37228692,
        "Tracked Object Left Zone %1": 456308509,
        "Tracked Unique Object Entered Zone %1": -1766980008,
    }
    _EVENT_INT_TO_STR = {v: k for k, v in _EVENT_STR_TO_INT.iteritems()}
    _IMAGE_EXT = [".png", ".jpg", ".jpeg", ".bmp"]
    _HTML_IMG_TEMPLATE = """<img src="data:image/png;base64,{img}" {attr}>"""

    _SCR_DEFAULT_NAMES = [
        "Yeni skript",
        "Unnamed Script",
        "უსახელო სკრიპტი",
        "Жаңа скрипт",
        "Script nou",
        "Новый скрипт",
        "Yeni skript dosyası",
        "Новий скрипт",
        "未命名脚本",
    ]

    def __init__(self):
        pass

    # noinspection PyUnusedLocal
    @staticmethod
    def do_nothing(*args, **kwargs):  # # pylint: disable=W0613
        """Ничего не делает.

        Returns:
            :obj:`bool`: ``True``
        """
        return True

    @staticmethod
    def run_as_thread(func):
        """Декоратор для запуска функций в отдельном потоке.

        Returns:
            :obj:`threading.Thread`: Функция в отдельном потоке

        Examples:
            >>> import time
            >>>
            >>>
            >>> @BaseUtils.run_as_thread
            >>> def run_count_timer():
            ...     time.sleep(1)
            ...     host.stats()["run_count"] += 1
            >>>
            >>>
            >>> run_count_timer()
        """

        @wraps(func)
        def run(*args, **kwargs):
            thread = threading.Thread(target=func, args=args, kwargs=kwargs)
            thread.daemon = True
            thread.start()
            return thread

        return run

    @staticmethod
    def catch_request_exceptions(func):
        """Catch request errors"""

        @wraps(func)
        def wrapped(self, *args, **kwargs):
            try:
                return func(self, *args, **kwargs)
            except urllib2.HTTPError as err:
                return err.code, "HTTPError: {}".format(err.code)
            except urllib2.URLError as err:
                return err.reason, "URLError: {}".format(err.reason)
            except httplib.HTTPException as err:
                return err, "HTTPException: {}".format(err)
            except ssl.SSLError as err:
                return err.errno, "SSLError: {}".format(err)

        return wrapped

    @staticmethod
    def win_encode_path(path):
        """Изменяет кодировку на ``"cp1251"`` для WinOS.

        Args:
            path (:obj:`str`): Путь до файла или папки

        Returns:
            :obj:`str`: Декодированый путь до файла или папки

        Examples:
            >>> path = r"D:/Shots/Скриншот.jpeg"
            >>> os.path.isfile(path)
            False
            >>> os.path.isfile(BaseUtils.win_encode_path(path))
            True
        """
        if os.name == "nt":
            try:
                path = path.decode("utf8")
            except (UnicodeDecodeError, UnicodeEncodeError):
                pass

        return path

    @staticmethod
    def is_file_exists(file_path, tries=1):
        """Проверяет, существует ли файл.

        Проверка происходит в течении ``tries`` секунд.

        Warning:
            | Запускайте функцию только в отдельном потоке если ``tries > 1``
            | Вторая и последующие проверки производятся с ``time.sleep(1)``

        Args:
            file_path (:obj:`str`): Полный путь до файла
            tries (:obj:`int`, optional): Количество проверок. По умолчанию ``tries=1``

        Returns:
            :obj:`bool`: ``True`` if file exists, ``False`` otherwise

        Examples:
            >>> BaseUtils.is_file_exists("_t1server.settings")
            True
        """
        file_path_encoded = BaseUtils.win_encode_path(file_path)
        if os.path.isfile(file_path) or os.path.isfile(file_path_encoded):
            return True
        for _ in xrange(tries - 1):
            time.sleep(1)
            if os.path.isfile(file_path) or os.path.isfile(file_path_encoded):
                return True
        return False

    @staticmethod
    def is_folder_exists(folder):
        """Проверяет существование папки и доступ на запись.

        Args:
            folder (:obj:`str`): Путь к папке.

        Raises:
            IOError: Если папка не существует

        Examples:
            >>> BaseUtils.is_folder_exists("/test_path")
            IOError: Folder '/test_path' is not exists
        """

        if not os.path.isdir(folder):
            raise IOError("Folder '{}' is not exists".format(folder))

        readme_file = os.path.join(folder, "readme.txt")
        with open(readme_file, "w") as opened_file:
            opened_file.write(
                "If you see this file - Trassir script have no access to remove it!"
            )
        os.remove(readme_file)

    @classmethod
    def is_template_exists(cls, template_name):
        """Проверяет существование шаблона

        Args:
            template_name (:obj:`str`): Имя шаблона

        Returns:
            :obj:`bool`: :obj:`True` если шаблон существует, иначе :obj:`False`
        """
        for tmpl_ in host.settings("templates").ls():
            if tmpl_.name == template_name:
                return True
        return False

    @classmethod
    def cat(cls, filepath, check_ext=True):
        """Выводит на отображение текстовую инфомрацию.

        Tip:
            - *WinOS*: открывает файл программой по умолчанию
            - *TrassirOS*: открывает файл в терминале с помощью утилиты `cat`

        Note:
            | Доступные расширения файлов: ``[".txt", ".csv", ".log"]``
            | Если открываете файл с другим расширением установите ``check_ext=False``

        Args:
            filepath (:obj:`str`): Полный путь до файла
            check_ext (:obj:`bool`, optional): Если ``True`` - проверяет расширение файла.
                По умолчанию ``True``

        Examples:
            >>> BaseUtils.cat("/home/trassir/ Trassir 3 License.txt")

                .. image:: images/base_utils.cat.png

        Raises:
            :class:`TypeError`: Если ``check_ext=True`` расширение файла нет в списке :obj:`_TEXT_FILE_EXTENSIONS`
        """

        if check_ext:
            _, ext = os.path.splitext(filepath)
            if ext not in cls._TEXT_FILE_EXTENSIONS:
                raise TypeError(
                    "Bad file extension: {}. To ignore this: set check_ext=False".format(
                        ext
                    )
                )

        if os.name == "nt":
            os.startfile(filepath)
        else:
            subprocess.Popen(
                [
                    "xterm -fg black -bg white -geometry 90x35 -func "
                    "-misc-fixed-medium-r-normal--18-120-100-100-c-90-iso10646-1 -e bash -c \"cat '{}'; "
                    "read -n 1 -s -r -p '\n\nPress any key to exit'; exit\"".format(
                        filepath
                    )
                ],
                shell=True,
                close_fds=True,
            )

    @classmethod
    def _json_serializer(cls, data):
        """JSON serializer for objects not serializable by default"""
        if isinstance(data, (datetime, date)):
            return data.isoformat()

        elif isinstance(data, host.ScriptHost.SE_Settings):
            return "settings('{}')".format(data.path)

        elif isinstance(data, host.ScriptHost.SE_Object):
            return "object('{}')".format(data.guid)

        return type(data).__name__

    @classmethod
    def to_json(cls, data, **kwargs):
        """Сериализация объекта в JSON стрку

        Note:
            Не вызывает ошибку при сериализации объектов :obj:`datetime`,
            :obj:`date`, :obj:`SE_Settings`, :obj:`SE_Object`

        Args:
            data (:obj:`obj`): Объект для сериализации

        Returns:
            :obj:`str`: JSON строка

        Examples:
            >>> obj = {"now": datetime.now()}
            >>> json.dumps(obj)
            TypeError: datetime.datetime(2019, 4, 2, 18, 01, 33, 881000) is not JSON serializable
            >>> BaseUtils.to_json(obj, indent=None)
            '{"now": "2019-04-02T18:01:33.881000"}'
        """

        return json.dumps(data, default=cls._json_serializer, **kwargs)

    @staticmethod
    def ts_to_dt(ts):  # pylint: disable=C0103
        """Конвертирует timestamp в :obj:`datetime` объект

        Args:
            ts (:obj:`int`): Timestamp

        Returns:
            :obj:`datetime`: Datetime объект

        Examples:
            >>> BaseUtils.ts_to_dt(1564109694242000)
            datetime.datetime(2019, 7, 26, 9, 54, 54, 242000)
        """
        if ts > 1e10:
            ts_sec = int(ts / 1e6)
            ts_ms = int(ts - ts_sec * 1e6)
        else:
            ts_sec = int(ts)
            ts_ms = 0

        return datetime.fromtimestamp(ts_sec) + timedelta(microseconds=ts_ms)

    @staticmethod
    def dt_to_ts(dt):  # pylint: disable=C0103
        """Конвертирует :obj:`datetime` объект в trassir timestamp

        Args:
            dt (:obj:`datetime`): Datetime

        Returns:
            :obj:`int`: Trassir timestamp

        Examples:
            >>> BaseUtils.ts_to_dt(datetime(2019, 7, 26, 9, 54, 54, 242000))
            1564109694242000
        """
        return int(int(time.mktime(dt.timetuple())) * 1e6 + dt.microsecond)

    @classmethod
    def lpr_flags_decode(cls, flags):
        """Преобразует флаги события AutoTrassir

        Приводит флаги события человекочитаемый список

        Note:
            Список доступных флагов:

            - ``LPR_UP`` - Направление движения вверх
            - ``LPR_DOWN`` - Направление движения вниз

            - ``LPR_BLACKLIST`` - Номер в черном списке
            - ``LPR_WHITELIST`` - Номер в черном списке
            - ``LPR_INFO`` - Номер в информационном списке

            - ``LPR_FIRST_LANE`` - Автомобиль двигается по первой полосе
            - ``LPR_SECOND_LANE`` - Автомобиль двигается по второй полосе
            - ``LPR_THIRD_LANE`` - Автомобиль двигается по третей полосе

            - ``LPR_EXT_DB_ERROR`` - Ошибка во внешнем списке
            - ``LPR_CORRECTED`` - Номер исправлен оператором

        Args:
            flags (:obj:`int`): Биты LPR события. Как правило аргумент :obj:`ev.flags`
                события :obj:`SE_LprEvent` AutoTrassir. Например :obj:`536870917`

        Returns:
            List[:obj:`str`]: Список флагов

        Examples:
            >>> BaseUtils.lpr_flags_decode(536870917)
            ['LPR_UP', 'LPR_BLACKLIST']
        """
        return [bit for bit, code in cls._LPR_FLAG_BITS.iteritems() if flags & code]

    @classmethod
    def event_type_encode(cls, event_type):
        """Преобразует тип события :obj:`str` -> :obj:`int`

        Note:
            События в БД хранятся в :obj:`int`, в скриптах
            приходят в человекочитаемом, строковом формате.

        Args:
            event_type (:obj:`str`): Тип события как в скриптах.

        Examples:
            >>> BaseUtils.event_type_encode("Border Crossed A -> B")
            -2010220362

        Returns:
            :obj:`int`: Тип события как в БД
        """
        if not isinstance(event_type, str):
            raise TypeError("Expected str, got {}".format(type(event_type).__name__))
        return cls._EVENT_STR_TO_INT.get(event_type)

    @classmethod
    def event_type_decode(cls, event_type):
        """Преобразует тип события :obj:`int` -> :obj:`str`

        Note:
            События в БД хранятся в :obj:`int`, в скриптах
            приходят в человекочитаемом, строковом формате.

        Args:
            event_type (:obj:`int`): Тип события как в БД.

        Examples:
            >>> BaseUtils.event_type_encode(-2010220362)
            "Border Crossed A -> B"

        Returns:
            :obj:`str`: Тип события как в скриптах
        """
        if not isinstance(event_type, int):
            raise TypeError("Expected int, got {}".format(type(event_type).__name__))
        return cls._EVENT_INT_TO_STR.get(event_type)

    @classmethod
    def image_to_base64(cls, image):
        """Создает base64 из изображения

        Args:
            image (:obj:`str`): Путь к изображению или изображение

        Returns:
            :obj:`str`: Base64 image

        Examples:
            >>> BaseUtils.image_to_base64(r"manual/en/cloud-devices-16.png")
            'iVBORw0KGgoAAAANSUhEUgAAB1MAAAH0CAYAAABo5wRhAAAACXBIWXMAAC4jA...'
            >>> BaseUtils.image_to_base64(open(r"manual/en/cloud-devices-16.png", "rb").read())
            'iVBORw0KGgoAAAANSUhEUgAAB1MAAAH0CAYAAABo5wRhAAAACXBIWXMAAC4jA...'
        """
        _, ext = os.path.splitext(image)

        if ext.lower() in cls._IMAGE_EXT:
            image = cls.win_encode_path(image)
            if not BaseUtils.is_file_exists(image):
                return ""

            with open(image, "rb") as image_file:
                image = image_file.read()

        return base64.b64encode(image)

    @classmethod
    def base64_to_html_img(cls, image_base64, **kwargs):
        """Возвращает base64 изображение в `<img>` html теге

        Args:
            image_base64 (:obj:`str`): Base64 image
            **kwargs: HTML `<img>` tag attributes. Подробнее на `html.com
                <https://html.com/tags/img/#Attributes_of_img>`_

        Returns:
            :obj:`str`: html image

        Examples:
            >>> base64_image = BaseUtils.image_to_base64(r"manual/en/cloud-devices-16.png")
            >>> html_image = BaseUtils.base64_to_html_img(base64_image, width=280, height=75)
            >>> html_image
            '<img src="data:image/png;base64,iVBORw0KGgoAA...Jggg==" width="280" height="75">'
            >>> host.message(html_image)

                .. image:: images/popup_sender.image.png
        """
        html_img = cls._HTML_IMG_TEMPLATE.format(
            img=image_base64,
            attr=" ".join(
                '%s="%s"' % (key, value) for key, value in kwargs.iteritems()
            ),
        )
        return html_img

    @staticmethod
    def save_pkl(file_path, data):
        """Сохраняет данные в `.pkl` файл

        Args:
            file_path (:obj:`str`): Путь до файла
            data: Данные для сохранения

        Returns:
            :obj:`str`: Абсолютный путь до файла

        Examples:
            >>> data = {"key": "value"}
            >>> BaseUtils.save_pkl("saved_data.pkl", data)
            'D:\\DSSL\\Trassir-4.1-Client\\saved_data.pkl'

        """
        if not file_path.endswith(".pkl"):
            file_path = file_path + ".pkl"

        with open(file_path, "wb") as opened_file:
            pickle.dump(data, opened_file)

        return os.path.abspath(file_path)

    @staticmethod
    def load_pkl(file_path, default_type=dict):
        """Загружает данные из `.pkl` файла

        Args:
            file_path (:obj:`str`): Путь до файла
            default_type (optional):
                Тип данных, возвращаемый при неудачной загрузке данных из файла.
                По умолчанию :obj:`dict`

        Returns:
            Данные из файла или :obj:`default_type()`

        Examples:
            >>> BaseUtils.load_pkl("fake_saved_data.pkl")
            {}
            >>> BaseUtils.load_pkl("fake_saved_data.pkl", default_type=list)
            []
            >>> BaseUtils.load_pkl("fake_saved_data.pkl", default_type=int)
            0
            >>> BaseUtils.load_pkl("fake_saved_data.pkl", default_type=str)
            ''
            >>> BaseUtils.load_pkl("saved_data.pkl")
            {'key': 'value'}
        """

        if not file_path.endswith(".pkl"):
            file_path = file_path + ".pkl"

        data = default_type()

        if os.path.isfile(file_path):
            try:
                with open(file_path, "rb") as opened_file:
                    data = pickle.load(opened_file)
            except (EOFError, IndexError, ValueError, TypeError):
                # dump file is empty or broken
                pass

        return data

    @classmethod
    def get_object(cls, obj_id):
        """Возвращает объект Trassir, если он доступен, иначе ``None``

        Args:
            obj_id (:obj:`str`): Guid объекта или его имя

        Returns:
            :obj:`ScriptHost.SE_Object`: Объект Trassir или ``None``

        Examples:
            >>> obj = BaseUtils.get_object("EZJ4QnbC")
            >>> if obj is None:
            ...     host.error("Object not found")
            ... else:
            ...     host.message("Object name is {0.name}".format(obj))
        """
        if not isinstance(obj_id, (str, unicode)):
            raise TypeError(
                "Expected str or unicode, got '{}'".format(type(obj_id).__name__)
            )
        obj = host.object(obj_id)
        try:
            obj.name
        except EnvironmentError:
            # Object not found
            obj = None
        return obj

    @classmethod
    def get_object_name_by_guid(cls, guid):
        """Возвращает имя объекта Trassir по его guid

        Tip:
            Можно использовать:

            - guid объекта ``"CFsuNBzt"``
            - guid объекта + guid сервера ``"CFsuNBzt_pV4ggECb"``

        Args:
            guid (:obj:`str`): Guid объекта Trassir

        Returns:
            :obj:`str`: Имя объекта, если объект найден, иначе ``guid``

        Examples:
            >>> BaseUtils.get_object_name_by_guid("EZJ4QnbC")
            'AC-D2141IR3'
            >>> BaseUtils.get_object_name_by_guid("EZJ4QnbC-")
            'EZJ4QnbC-'
        """
        guid = guid.split("_", 1)[0]
        obj = cls.get_object(guid)
        if obj is None:
            name = guid
        else:
            name = obj.name
        return name

    @classmethod
    def get_full_guid(cls, obj_id):
        """Возвращает полный guid объекта

        Args:
            obj_id (:obj:`str`): Guid объекта или его имя

        Returns:
            :obj:`str`: Полный guid объекта
        """

        tr_obj = cls.get_object(obj_id)
        full_guid = None
        if tr_obj is not None:
            for obj in host.objects_list(""):
                if tr_obj.guid == obj[1]:
                    full_guid = "{}_{}".format(obj[1], cls._FOLDERS.get(obj[3], obj[3]))
                    break
        return full_guid

    @classmethod
    def get_operator_gui(cls):
        """Возвращает объект интерфейса оператора

        Returns:
            :obj:`OperatorGUI`: Объект интерфейса оператора

        Raises:
            ScriptError: Если не удается загрузить интерфейс

        Examples:
            Открыть интерфейс Trassir а мониторе №1

            >>> operator_gui = BaseUtils.get_operator_gui()
            >>> operator_gui.raise_monitor(1)
        """
        obj = cls.get_object("operatorgui_{}".format(host.settings("").guid))
        if obj is None:
            raise ScriptError("Failed to load operator gui")
        return obj

    @classmethod
    def get_server_guid(cls):
        """Возвращает guid текущего сервра

        Returns:
            :obj:`str`: Guid сервера

        Examples:
            >>> BaseUtils.get_server_guid()
            'client'
        """
        return host.settings("").guid

    @classmethod
    def get_script_name(cls):
        """Возвращает имя текущего скрипта

        Returns:
            :obj:`str`: Имя скрипта

        Examples:
            >>> BaseUtils.get_script_name()
            'Новый скрипт'
        """
        return host.stats().parent()["name"] or __name__

    @classmethod
    def get_screenshot_folder(cls):
        """Возвращает путь до папки скриншотов

        При этом производит проверку папки методом
        :meth:`BaseUtils.is_folder_exists`

        Returns:

            :obj:`str`: Полный путь к папке скриншотов

        Examples:
            >>> BaseUtils.get_screenshot_folder()
            '/home/trassir/shots'
        """
        folder = host.settings("system_wide_options")["screenshots_folder"]
        cls.is_folder_exists(folder)
        return folder

    @classmethod
    def get_logger(  # pylint: disable=R0913,R0914
        cls,
        host_log="WARNING",
        popup_log="ERROR",
        file_log=None,
        file_name=None,
        file_max_bytes=5 * 1024 * 1024,
        file_backup_count=2,
    ):
        """Возвращает логгер с предустановленными хэндлерами

        Доступные хэндлеры:
            - *host_log*: Пишет сообщения в основной лог сервера _t1server.log
            - *popup_log*: Показывает всплывающие сообщения ``message/alert/error``
            - *file_log*: Пишет сообщения в отдельный файл в папку скриншотов

        Для каждого хэндлера можно установить разный уровень логирования

        По умолчанию ``host_log="WARNING"`` и ``popup_log="ERROR"``

        Note:
            Имя файла лога можно указать с расширение ".log" или без.

        See Also:
            `Logging levels на сайте docs.python.org
            <https://docs.python.org/2/library/logging.html#logging-levels>`_

        Args:
            host_log (:obj:`str`, optional): Уровень логирования в основной лог.
                По умолчанию ``"WARNING"``
            popup_log (:obj:`str`, optional): Уровень логирования во всплывающих
                сообщениях. По умолчанию ``"ERROR"``
            file_log (:obj:`str`, optional): Уровень логирования в отдельный файл
                По умолчанию :obj:`None`
            file_name (:obj:`str`, optional): Имя файла для логирования.
                По умолчанию :obj:`None` и равно ``<имени скрипта>.log``
            file_max_bytes (:obj:`int`, optional): Максимальный размер файла лога
                в байтах. По умолчанию :obj:`5 * 1024 * 1024`
            file_backup_count (:obj:`int`, optional): Макссимальное кол-во бэкапов лога.
                По умолчанию :obj:`2`

        Returns:
            :obj:`logging.logger`: Логгер

        Examples:
            >>> logger = BaseUtils.get_logger()
            >>> logger.warning("My warning message")
            >>> try:
            ...     # noinspection PyUnresolvedReferences
            ...     do_something()
            ... except NameError:
            ...     logger.error("Function is not defined", exc_info=True)
        """
        logger_ = logging.getLogger(__name__)
        logger_.setLevel("DEBUG")

        def _remove_handlers():
            """Close and remove handlers on disable script"""
            logger_.info("Remove %s handlers...", len(logger_.handlers))
            for handler in logger_.handlers[:]:
                handler.close()
                logger_.removeHandler(handler)

        host.register_finalizer(_remove_handlers)

        if host_log:
            host_handler = HostLogHandler()
            host_handler.setLevel(host_log)
            host_formatter = logging.Formatter(
                "[%(levelname)-8s] %(lineno)-4s <%(funcName)s> - %(message)s"
            )
            host_handler.setFormatter(host_formatter)
            logger_.addHandler(host_handler)

        if popup_log:
            popup_handler = PopupHandler()
            popup_handler.setLevel(popup_log)
            popup_formatter = logging.Formatter(
                fmt="<b>[%(levelname)s]</b> Line: %(lineno)s<br><i>%(message).630s</i>"
            )
            popup_handler.setFormatter(popup_formatter)
            logger_.addHandler(popup_handler)

        if file_log:
            if file_name is None:
                file_name = cls.get_script_name()

            if not file_name.endswith(".log"):
                file_name = "{}.log".format(file_name)

            file_path = os.path.join(cls.get_screenshot_folder(), file_name)
            file_path = cls.win_encode_path(file_path)

            file_handler = RotatingFileHandler(
                file_path, maxBytes=file_max_bytes, backupCount=file_backup_count
            )
            file_handler.setLevel(file_log)
            file_formatter = logging.Formatter(
                fmt="%(duplicates)s%(asctime)s [%(levelname)-8s] %(lineno)-4s <%(funcName)s> - %(message)s",
                datefmt="%Y/%m/%d %H:%M:%S",
            )
            file_handler.setFormatter(file_formatter)
            file_handler.addFilter(DuplicateFilter())
            logger_.addHandler(file_handler)

        return logger_

    @classmethod
    def set_script_name(cls, fmt=None, script_name=None):
        """Автоматически изменяет имя скрипта

        Новое имя скрипта создается на основе `параметров
        <https://www.dssl.ru/files/trassir/manual/ru/setup-script-parameters.html>`_
        скрипта. По желанию можно изменить шаблон имени. По умолчанию
        :obj:`"{title} v{version}"`

        Note:
            Имя изменяется только если сейчас у скрипта стандартное имя,
            например :obj:`"Новый скрипт"` или :obj:`"Unnamed Script"` и др.

        Args:
            fmt (:obj:`str`, optional): Шаблон имени скрипта. По умолчанию :obj:`None`
            script_name (:obj:`str`, optional): Имя скрипта. Если не задано - парсит
                имя из параметров. По умолчанию :obj:`None`

        Examples:
            >>> BaseUtils.set_script_name()
            'trassir_script_framework v0.4'

            >>> BaseUtils.set_script_name(fmt="{title}")
            'trassir_script_framework'
        """
        if host.stats().parent()["name"] in cls._SCR_DEFAULT_NAMES:
            if script_name is None:
                try:
                    root = ElementTree.fromstring(__doc__)
                except ElementTree.ParseError:
                    root = None

                if root is None:
                    company, title, version = None, None, None
                else:
                    company = root.find("company") if root else None
                    title = root.find("title") if root else None
                    version = root.find("version") if root else None

                if fmt is None:
                    fmt = "{title} v{version}"

                script_name = fmt.format(
                    company="DSSL" if company is None else company.text,
                    title="Script" if title is None else title.text,
                    version="0.1" if version is None else version.text,
                )

            host.stats().parent()["name"] = script_name

            return script_name
        return ""


if globals().get("DEBUG", False):
    logger = BaseUtils.get_logger(  # pylint: disable=C0103
        host_log="DEBUG", popup_log="WARNING", file_log="DEBUG"
    )
else:
    logger = BaseUtils.get_logger()  # pylint: disable=C0103


class Worker(threading.Thread):
    """Thread executing tasks from a given tasks queue"""

    def __init__(self, tasks):
        super(Worker, self).__init__()
        self.tasks = tasks
        self.daemon = True
        self.start()

        self.task_working = False

    def run(self):
        while __name__ in sys.modules.keys():
            if not self.tasks.empty():
                self.task_working = True
                func, args, kwargs = self.tasks.get(timeout=1)
                # noinspection PyBroadException
                try:
                    func(*args, **kwargs)
                except:  # # pylint: disable=W0702
                    logger.exception("ThreadPool Worker error")
                finally:
                    self.tasks.task_done()
            else:
                self.task_working = False


class ThreadPool:  # pylint: disable=C1001
    """Pool of threads consuming tasks from a queue"""

    def __init__(self, num_threads):
        self.tasks = Queue()
        self.workers = [Worker(self.tasks) for _ in xrange(num_threads)]

    @property
    def working(self):
        for worker in self.workers:
            if worker.task_working:
                return True
        return False

    def add_task(self, func, *args, **kargs):
        """Add a task to the queue"""
        self.tasks.put((func, args, kargs))

    def wait_completion(self):
        """Wait for completion of all the tasks in the queue"""
        self.tasks.join()


class HTTPRequester(py_object):
    """Framework for urllib2

    See Also:
        https://docs.python.org/2/library/urllib2.html#urllib2.build_opener

    Args:
        opener (:obj:`urllib2.OpenerDirector`, optional): Обработчик запросов.
            По умолчанию :obj:`None`
        timeout (:obj:`int`, optional): Время ожидания запроса, в секундах.
            По умолчанию :obj:`timeout=10`

    Examples:
        Пример запроса к SDK Trassir

        >>> # Отключение проверки сертификата
        >>> context = ssl.create_default_context()
        >>> context.check_hostname = False
        >>> context.verify_mode = ssl.CERT_NONE
        >>>
        >>> handler = urllib2.HTTPSHandler(context=context)
        >>> opener = urllib2.build_opener(handler)
        >>>
        >>> requests = HTTPRequester(opener, timeout=20)
        >>> response = requests.get(
        ...     "https://172.20.0.101:8080/login",
        ...     params={"username": "Admin", "password": "12345"}
        ... )
        >>>
        >>> response.code
        200
        >>> response.text
        '{\\n   "sid" : "T6LAAcxg",\\n   "success" : 1\\n}\\n'
        >>> response.json
        {u'success': 1, u'sid': u'T6LAAcxg'}
    """

    class Response(py_object):  # pylint: disable=R0903
        """Класс ответа от сервера

        Attributes:
            code (:obj:`str` | :obj:`int`): Код ответа сервера
            text (:obj:`str`): Текст ответа
            json (:obj:`dict` | :obj:`list`): Создает объект из json ответа
        """

        def __init__(self, *args):
            self.code, self.text = args

        @property
        def json(self):
            return json.loads(self.text)

    def __init__(self, opener=None, timeout=10):
        if opener is None:
            handler = urllib2.BaseHandler()
            opener = urllib2.build_opener(handler)
        self._opener = opener

        self.timeout = timeout

    @BaseUtils.catch_request_exceptions
    def _get_response(self, request):
        """Returns response

        Args:
            request (:obj:`urllib2.Request`): This class is an abstraction of a URL request
        """
        response = self._opener.open(request, timeout=self.timeout)
        return response.code, response.read()

    @staticmethod
    def _parse_params(**params):
        """Params get string params

        Args:
            **params (dict): Keyword arguments

        Returns:
            str: params string
        """
        return "&".join(
            "{key}={value}".format(key=key, value=value)
            for key, value in params.iteritems()
        )

    @staticmethod
    def _prepare_headers(headers):
        """Prepare headers for request"""
        if headers is None:
            headers = {}

        if "User-Agent" not in headers:
            headers["User-Agent"] = "TrassirScript"
        return headers

    def get(self, url, params=None, headers=None):
        """Создает GET запрос по указанному :obj:`url`

        Args:
            url (:obj:`str`): Url для запроса
            params (:obj:`dict`, optional): Параметры GET запроса
            headers (:obj:`dict`, optional): Заголовки запроса

        Examples:
            >>> requests = HTTPRequester()
            >>> response = requests.get(
            ...     "http://httpbin.org/get",
            ...     params={"PARAMETER": "TEST"},
            ... )
            >>> response.code
            200
            >>> response.text
            '{\\n  "args": {\\n    "PARAMETER": "TEST"\\n  }, \\n ...'
            >>> response.json
            {u'args': {u'PARAMETER': u'TEST'}, ...}

        Returns:
            :class:`HTTPRequester.Response`: Response instance
        """
        if params is not None:
            url += "?{params}".format(params=self._parse_params(**params))

        headers = self._prepare_headers(headers)

        request = urllib2.Request(url, headers=headers)
        response = self._get_response(request)
        return self.Response(*response)

    def post(self, url, data=None, headers=None):
        """Создает POST запрос по указанному :obj:`url`

        Args:
            url (:obj:`str`): Url для запроса
            data (:obj:`dict`, optional): Данные POST запроса
            headers (:obj:`dict`, optional): Заголовки запроса

        Examples:
            >>> requests = HTTPRequester()
            >>> response = requests.post(
            ...     "http://httpbin.org/post",
            ...     data={"PARAMETER": "TEST"},
            ...     headers={"Content-Type": "application/json"},
            ... )
            >>> response.code
            200
            >>> response.text
            '{\\n  "args": {\\n    "PARAMETER": "TEST"\\n  }, \\n ...'
            >>> response.json
            {u'args': {u'PARAMETER': u'TEST'}, ...}

        Returns:
            :class:`HTTPRequester.Response`: Response instance
        """
        if data is None:
            data = {}

        if isinstance(data, dict):
            data = urllib.urlencode(data)

        headers = self._prepare_headers(headers)

        request = urllib2.Request(url, data=data, headers=headers)
        response = self._get_response(request)
        return self.Response(*response)


class ScriptObject(host.TrassirObject, py_object):
    """Создает объект для генерации событий

    Args:
        name (:obj:`str`, optional): Имя объекта. По умолчанию :obj:`None`
        guid (:obj:`str`, optional): Guid объекта. По умолчанию :obj:`None`
        parent (:obj:`str`, optional): Guid родительского объекта. По умолчанию :obj:`None`

    Note:
        - Имя объекта по умолчанию - :meth:`BaseUtils.get_script_name`
        - Guid объекта по умолчанию строится по шаблноу ``"{script_guid}_object"``
        - Guid родительского объекта по умолчанию -
          :meth:`BaseUtils.get_server_guid`

    Examples:
        >>> # Создаем объект
        >>> scr_obj = ScriptObject()

        >>> # Проверяем текущее состояние объекта
        >>> scr_obj.health
        'OK'

        >>> # Установить флаг возле объекта
        >>> scr_obj.check_me = True

        >>> # Сгенерировать событие с текстом
        >>> scr_obj.fire_event_v2("New event")
    """

    def __init__(self, name=None, guid=None, parent=None):
        super(ScriptObject, self).__init__("Script")

        scr_parent = host.stats().parent()

        self._name = name or BaseUtils.get_script_name()
        self.set_name(self._name)

        self._guid = guid or "{}-object".format(scr_parent.guid)
        self.set_guid(self._guid)

        self._parent = parent or BaseUtils.get_server_guid()
        self.set_parent(self._parent)

        self._folder = ""

        self._health = "OK"
        self._check_me = True

        self.set_initial_state([self._health, self._check_me])

        host.object_add(self)

        self.context_menu = []

    @property
    def health(self):
        """:obj:`"OK"` | :obj:`"Error"`: Состояние объекта"""
        return self._health

    @health.setter
    def health(self, value):
        if value in ["OK", "Error"]:
            self.set_state([value, self._check_me])
            self._health = value
        else:
            raise ValueError("Expected 'OK' or 'Error', got '{}'".format(value))

    @property
    def check_me(self):
        """:obj:`bool`: Флаг ``check_me`` объекта"""
        return bool(1 - self._check_me)

    @check_me.setter
    def check_me(self, value):
        if isinstance(value, bool) or value in [1, 0]:
            value = 1 - value
            self.set_state([self._health, value])
            self._check_me = value
        else:
            raise ValueError("Expected bool or 1|0, got '{}'".format(value))

    @property
    def name(self):
        """:obj:`str`: Имя объекта"""
        return self._name

    @name.setter
    def name(self, value):
        if isinstance(value, str):
            self.set_name(value)
            self._name = value
        else:
            raise ValueError("Expected str, got {}".format(type(value).__name__))

    @property
    def folder(self):
        """:obj:`str`: Папка объекта"""
        return self._folder

    @folder.setter
    def folder(self, value):
        if not value:
            raise ValueError("Object guid can't be empty")

        if isinstance(value, str):
            if self._folder:
                self.change_folder(value)
            else:
                self.set_folder(value)
            self._folder = value
        else:
            raise ValueError("Expected str, got {}".format(type(value).__name__))

    def context_menu_button(self, text, callback):
        """Добавляет кнопку в контекстное меню объекта

        Args:
            text (:obj:`str`): Текст кнопки
            callback (:obj:`function`): Функция, которая вызывается при нажатии
                на кнопку. В качестве единственного аргумента функция приимает
                текущий объект (:obj:`host_ip.object(self.guid)`).

        Returns:
            :obj:`SE_ContextCatcher`: Хендлер контекстного меню

        Raises:
            ValueError: Если пустой текст кнопки.
            TypeError: Если callback нельзя вызвать в качестве функции.

        Examples:
            >>> scr = ScriptObject()
            >>>
            >>> def switch(obj):
            ...     scr.check_me = not scr.check_me
            ...     btn.set_name("OFF" if scr.check_me else "ON")
            >>>
            >>> btn = scr.context_menu_button("ON", switch)

                .. image:: images/context_menu_button.png

            >>> btn
            <host_ip.SE_ContextCatcher object at 0x17B01A98>
            >>> scr.context_menu
            [('ON', 'switch', <host_ip.SE_ContextCatcher object at 0x17B01A98>)]
        """
        if not text:
            raise ValueError("No text")

        if not callable(callback):
            raise TypeError("Callback function is not callable")

        btn = host.activate_on_context_menu(self._guid, text, callback)
        self.context_menu.append((text, callback.__name__, btn))
        return btn

    def fire_event_v2(self, message, channel="", data=""):
        """Создает событие в Trassir

        Args:
            message (:obj:`str`): Сообщение события (``p1``)
            channel (:obj:`str`, optional): Ассоциированный с событием канал (``p2``)
            data (:obj:`str`, optional): Дополнительные данные (``p3``)

        Examples:
            >>> scr = ScriptObject()
            >>> scr.fire_event_v2("Hello world")

                .. image:: images/fire_event_v2.png
        """
        if not isinstance(data, str):
            data = BaseUtils.to_json(data, indent=None)

        self.fire_event("Script: %1", message, channel, data)


class ShotSaverError(ScriptError):
    """Base ShotSaver Exception"""

    pass


class ShotSaver(py_object):
    """Класс для сохранения скриншотов

        Args:
            shot_awaiting_time (:obj:`int`, optional): Время ожидания скриншота, с. По умолчанию :obj:`5`.
            tries_to_make_shot (:obj:`int`, optional): Кол-во попыток сохранить скриншот.
                Если в течении времени `shot_awaiting_time` скриншот не был сохранен - производится
                следующая попытка сохранить скриншот. По умолчанию :obj:`2`
            pool_size (:obj:`int`): Размер пула. По умолчанию :obj:`10`
        """

    _SHOT_NAME_TEMPLATE = (
        "{name} (%Y.%m.%d %H-%M-%S).jpg"
    )  # Template for shot file name

    def __init__(self, shot_awaiting_time=5, tries_to_make_shot=2, pool_size=10):
        self._shot_awaiting_time = shot_awaiting_time
        self._tries_to_make_shot = tries_to_make_shot
        self._thread_pool = None
        self._pool_size = pool_size

        self._screenshots_folder = BaseUtils.get_screenshot_folder()

    @property
    def pool_size(self):
        """:obj:`int`: Размер пула для метода :obj:`pool_shot`

        Устанавливает размер пула (кол-во одновременно созданных задач
        сохранения скриншотов). По умолчанию :obj:`10`.

        Warnings:
            Изменить данный параметр можно только до первого вызова
            метода :obj:`pool_shot`. После вызовет :obj:`RuntimeError`

        Raises:
            RuntimeError: Если пул уже создан.
        """
        return self._pool_size

    @pool_size.setter
    def pool_size(self, value):
        if self._thread_pool is None:
            self._pool_size = value
        else:
            raise RuntimeError("You can't change pool size when workers created")

    @property
    def pool_queue_size(self):
        """:obj:`int`: Размер текущей очереди в пуле

        Возвращает текущий размер очереди в пуле.

        Note:
            Если пул еще не был созда (метод :obj:`pool_shot`
            не вызывался) данный метод вернет :obj:`-1`
        """
        if self._thread_pool is None:
            return -1
        return self._thread_pool.tasks.qsize()

    @property
    def pool_working(self):
        """:obj:`bool`: :obj:`True` если в пуле есть не законченные задачи

        Note:
            Если пул еще не был созда (метод :obj:`pool_shot`
            не вызывался) данный метод вернет :obj:`None`
        """
        if self._thread_pool is None:
            return None
        return self._thread_pool.working

    @property
    def screenshots_folder(self):
        """:obj:`str`: Папка для сохранения скриншотов по умолчанию

        Устанавливает новый путь по умолчанию для сохранения скриншотов,
        если папка не существует - создает папку. Или возвращает текущий
        путь для сохранения скриншотов.

        Note:
            По молчанию :obj:`screenshots_folder`  =
            :meth:`BaseUtils.get_screenshot_folder`

        Raises:
            OSError: Если возникает ошибка при создании папки
        """
        return self._screenshots_folder

    @screenshots_folder.setter
    def screenshots_folder(self, folder):
        if not os.path.isdir(folder):
            try:
                os.makedirs(folder)
            except OSError as err:
                raise OSError("Can't make dir '{}': {}".format(folder, err))

        self._screenshots_folder = folder

    def shot(
        self, channel_full_guid, dt=None, file_name=None, file_path=None
    ):  # pylint: disable=C0103
        """Делает скриншот с указанного канала

        Note:
            По умолчанию:

            - :obj:`dt=datetime.now()`
            - :obj:`file_name="{name} (%Y.%m.%d %H-%M-%S).jpg"`, где ``{name}`` - имя канала

        Args:
            channel_full_guid (:obj:`str`): Полный guid анала. Например: ``"CFsuNBzt_pV4ggECb"``
            dt (:obj:`datetime.datetime`, optional): :obj:`datetime.datetime` для скриншота.
                По умолчанию :obj:`None`
            file_name (:obj:`str`, optional): Имя файла с расширением. По умолчанию :obj:`None`
            file_path (:obj:`str`, optional): Путь для сохранения скриншота. По умолчанию :obj:`None`

        Returns:
            :obj:`str`: Полный путь до скриншота

        Raises:
            ValueError: Если в guid канала отсутствует guid сервера
            TypeError: Если ``isinstance(dt, (datetime, date)) is False``

        Examples:
            >>> ss = ShotSaver()
            >>> ss.shot("e80kgBLh_pV4ggECb")
            '/home/trassir/shots/AC-D2141IR3 Склад (2019.04.03 15-58-26).jpg'
        """
        logger.debug(
            "ShotSaver.shot(%s, dt=%s, file_name=%s, file_path=%s)",
            repr(channel_full_guid),
            repr(dt),
            repr(file_name),
            repr(file_path),
        )
        if "_" not in channel_full_guid:
            raise ValueError(
                "Expected full channel guid, got {}".format(channel_full_guid)
            )

        if dt is None:
            ts = "0"  # pylint: disable=C0103
            dt = datetime.now()
        else:
            if not isinstance(dt, (datetime, date)):
                raise TypeError("Expected datetime, got {}".format(type(dt).__name__))
            ts = BaseUtils.dt_to_ts(dt)

        if file_name is None:
            file_name = dt.strftime(
                self._SHOT_NAME_TEMPLATE.format(
                    name=BaseUtils.get_object_name_by_guid(channel_full_guid)
                )
            )
        if file_path is None:
            file_path = self.screenshots_folder

        host.screenshot_v2_figures(channel_full_guid, file_name, file_path, ts)

        return os.path.join(file_path, file_name)

    def _async_shot(  # pylint: disable=R0913,C0103
        self, channel_full_guid, dt=None, file_name=None, file_path=None, callback=None
    ):
        """Вызывает ``callback`` после сохнанения скриншота

        * Метод работает в отдельном потоке
        * Вызывает функцию :meth:`ShotSaver.shot`
        * Ждет выполнения функции :meth:`BaseUtils.check_file` ``tries=10``
        * Вызвает ``callback`` функцию

        Args:
            channel_full_guid (:obj:`str`): Полный guid канала. Например: ``"CFsuNBzt_pV4ggECb"``
            dt (:obj:`datetime.datetime`, optional): :obj:`datetime.datetime` для скриншота.
                По умолчанию :obj:`None`
            file_name (:obj:`str`, optional): Имя файла с расширением. По умолчанию :obj:`None`
            file_path (:obj:`str`, optional): Путь для сохранения скриншота. По умолчанию :obj:`None`
            callback (:obj:`function`): Callable function
        """
        if callback is None:
            callback = BaseUtils.do_nothing

        shot_file = ""
        for _ in xrange(self._tries_to_make_shot):
            shot_file = self.shot(
                channel_full_guid, dt=dt, file_name=file_name, file_path=file_path
            )
            if BaseUtils.is_file_exists(
                BaseUtils.win_encode_path(shot_file), self._shot_awaiting_time
            ):
                host.timeout(100, lambda: callback(True, shot_file))
                break
        else:
            host.timeout(100, lambda: callback(False, shot_file))

    @BaseUtils.run_as_thread
    def async_shot(  # pylint: disable=R0913,C0103
        self, channel_full_guid, dt=None, file_name=None, file_path=None, callback=None
    ):
        """async_shot(channel_full_guid, dt=None, file_name=None, file_path=None, callback=None)
        Вызывает ``callback`` после сохнанения скриншота

        * Метод работает в отдельном потоке
        * Вызывает функцию :meth:`ShotSaver.shot`
        * Ждет выполнения функции :meth:`BaseUtils.check_file` ``tries=10``
        * Вызвает ``callback`` функцию

        Args:
            channel_full_guid (:obj:`str`): Полный guid канала. Например: ``"CFsuNBzt_pV4ggECb"``
            dt (:obj:`datetime.datetime`, optional): :obj:`datetime.datetime` для скриншота.
                По умолчанию :obj:`None`
            file_name (:obj:`str`, optional): Имя файла с расширением. По умолчанию :obj:`None`
            file_path (:obj:`str`, optional): Путь для сохранения скриншота. По умолчанию :obj:`None`
            callback (:obj:`function`, optional): Функциюя, которая вызывается после сохранения скриншота.
                В качестве аргументов должна принимать `success`, `shot_path`. По умолчанию :obj:`None`

        Returns:
            :obj:`threading.Thread`: Thread object

        Examples:
            >>> # noinspection PyUnresolvedReferences
            >>> def callback(success, shot_path):
            ...     # Пример callback функции
            ...     # Args:
            ...     #     success (bool): True если скриншот успешно сохранен, иначе False
            ...     #     shot_path (str): Полный путь до скриншота
            ...     if success:
            ...         host_ip.message("Скриншот успешно сохранен<br>%s" % shot_path)
            ...     else:
            ...         host_ip.error("Ошибка сохранения скриншота <br>%s" % shot_path)
            >>>
            >>> ss = ShotSaver()
            >>> ss.async_shot("e80kgBLh_pV4ggECb", callback=callback)
        """
        self._async_shot(
            channel_full_guid,
            dt=dt,
            file_name=file_name,
            file_path=file_path,
            callback=callback,
        )

    @BaseUtils.run_as_thread
    def _pool_awaiting(self):
        self._thread_pool.wait_completion()

    # noinspection PyIncorrectDocstring
    def pool_shot(self, *args, **kwargs):  # pylint: disable=C0103
        """pool_shot(channel_full_guid, dt=None, file_name=None, file_path=None, callback=None)
        Сохраняет скриншоты в пуле.

        Одновременно в работе не более :obj:`ShotSaver.pool_size` задач.

        Warnings:
            Данный метод создает :obj:`ShotSaver.pool_size` доп. потоков.
            Потоки удаляются при отключении скрипта.

        Args:
            channel_full_guid (:obj:`str`): Полный guid канала. Например: ``"CFsuNBzt_pV4ggECb"``
            dt (:obj:`datetime.datetime`, optional): :obj:`datetime.datetime` для скриншота.
                По умолчанию :obj:`None`
            file_name (:obj:`str`, optional): Имя файла с расширением. По умолчанию :obj:`None`
            file_path (:obj:`str`, optional): Путь для сохранения скриншота. По умолчанию :obj:`None`
            callback (:obj:`function`, optional): Функциюя, которая вызывается после сохранения скриншота.
                В качестве аргументов должна принимать `success`, `shot_path`. По умолчанию :obj:`None`

        Examples:

            >>> ss = ShotSaver()
            >>> ss.pool_size = 2
            >>>
            >>> ss.pool_shot("e80kgBLh_pV4ggECb")
            >>> ss.pool_shot("e80kgBLh_pV4ggECb")
            >>> ss.pool_shot("e80kgBLh_pV4ggECb")
            >>> ss.pool_shot("e80kgBLh_pV4ggECb")
            >>>
            >>> ss.pool_queue_size
            4
        """
        if self._thread_pool is None:
            self._thread_pool = ThreadPool(self._pool_size)

        self._thread_pool.add_task(self._async_shot, *args, **kwargs)


class VideoExporterError(ScriptError):
    """Base ShotSaver Exception"""

    pass


class VideoExporter(py_object):
    """Класс для экспорта видео

    Examples:
        Смена папки экспорта видео по умолчанию

        >>> ss = VideoExporter()
        >>> ss.export_folder
        '/home/trassir/shots'
        >>> ss.export_folder += "/my_videos"
        >>> ss.export_folder
        '/home/trassir/shots/my_videos'

        | Экспорт видео с вызовом ``callback`` функции после выполнения.
        | Начало экспорта - 120 секунд назад, продолжительность 60 сек.

        >>> # noinspection PyUnresolvedReferences
        >>> def callback(success, file_path, channel_full_guid):
        ...     # Пример callback функции
        ...     # Args:
        ...     #     success (bool): True если видео экспортировано успешно, иначе False
        ...     #     file_path (str): Полный путь до видеофайла
        ...     #     channel_full_guid (str) : Полный guid канала
        ...     if success:
        ...         host_ip.message("Экспорт успешно завершен<br>%s" % file_path)
        ...     else:
        ...         host_ip.error("Ошибка экспорта<br>%s" % file_path)

        >>> ss = VideoExporter()
        >>> dt_start = datetime.now() - timedelta(seconds=120)
        >>> ss.export(callback, "e80kgBLh_pV4ggECb", dt_start)
    """

    _EXPORTED_VIDEO_NAME_TEMPLATE = (
        "{name} ({dt_start} - {dt_end}){sub}.avi"
    )  # Template for shot file name

    def __init__(self):
        self._export_folder = BaseUtils.get_screenshot_folder()
        self._now_exporting = False
        self._queue = deque()
        self._default_prebuffer = host.settings("archive")["prebuffer"] + 2

    @property
    def export_folder(self):
        """:obj:`str`: Папка для экспорта видео по умолчанию

        Устанавливает новый путь по умолчанию для экспорта видео,
        если папка не существует - создает папку. Или возвращает текущий
        путь для экспорта видео.

        Note:
            По молчанию ``export_folder`` = :meth:`BaseUtils.get_screenshot_folder`

        Raises:
            OSError: Если возникает ошибка при создании папки
        """
        return self._export_folder

    @export_folder.setter
    def export_folder(self, folder):
        if not os.path.isdir(folder):
            try:
                os.makedirs(folder)
            except OSError as err:
                raise OSError("Can't make dir '{}': {}".format(folder, err))

        self._export_folder = folder

    def _get_prebuffer(self, server_guid, dt_end):
        """Get prebuffer delay

        Args:
            server_guid (str): Full channel guid include server guid

        Returns:
            int: Prebuffer delay
        """
        setting_path = "/{}/archive".format(server_guid)

        try:
            prebuffer = host.settings(setting_path)["prebuffer"] + 2
        except KeyError:
            prebuffer = self._default_prebuffer

        wait_dt_end = (int(time.mktime(dt_end.timetuple())) + prebuffer) * 1000000

        return "%.0f" % wait_dt_end

    @staticmethod
    def clear_complete_tasks():
        for task in host.archive_export_tasks_get():
            if task["state"] != 1:
                host.archive_export_task_cancel(
                    task["id"],  # task id from archive_export_tasks_get
                    -1,  # -1 - do not wait for result, 0 - wait forever, > 0 - wait timeout_sec seconds
                    BaseUtils.do_nothing,  # callback_success
                    BaseUtils.do_nothing,  # callback_error
                )

    def _check_queue(self):
        host.timeout(10, self.clear_complete_tasks)
        if self._queue:
            args, kwargs = self._queue.popleft()
            self._export(*args, **kwargs)

    def _export_checker(self, status, callback, file_path, channel_full_guid):
        if status == 1:
            return
        elif status in [0, 2]:
            # Export failed
            host.timeout(100, lambda: callback(False, file_path, channel_full_guid))
        else:
            # Export success
            host.timeout(100, lambda: callback(True, file_path, channel_full_guid))

        self._now_exporting = False
        self._check_queue()

    def _export(  # pylint: disable=R0913,R0914
        self,
        channel_full_guid,
        dt_start,
        dt_end=None,
        duration=60,
        prefer_substream=False,
        file_name=None,
        file_path=None,
        callback=None,
    ):
        """Exporting file

        Call callback(success: bool, file_path: str, channel_full_guid: str)
        when export finished, and clear tasks in trassir main control panel

        Note:
            Export task adding only when previous task finished
            You can set dt_start, dt_end, or dt_start, duration for export
            if dt_end is None: dt_end = dt_start + timedelta(seconds=duration)

        Args:
            channel_full_guid (str): Full channel guid; example: "CFsuNBzt_pV4ggECb"
            dt_start (datetime): datetime instance for export start
            dt_end (datetime, optional): datetime instance for export end; default: None
            duration (int, optional): Export duration (dt_start + duration seconds) if dt_end is None; default: 10
            prefer_substream (bool, optional): If True - export substream; default: False
            file_name (str, optional): File name with extension; default: _EXPORTED_VIDEO_NAME_TEMPLATE
            file_path (str, optional): Path to save shot; default: screenshots_folder
            callback (function, optional): Function that calling when export finished
        """

        if "_" not in channel_full_guid:
            raise ValueError(
                "Expected full channel guid, got {}".format(channel_full_guid)
            )

        if not isinstance(dt_start, (datetime, date)):
            raise TypeError("Expected datetime, got {}".format(type(dt_start).__name__))

        if dt_end:
            if not isinstance(dt_end, (datetime, date)):
                raise TypeError(
                    "Expected datetime, got {}".format(type(dt_end).__name__)
                )
        else:
            dt_end = dt_start + timedelta(seconds=duration)

        ts_start = "%.0f" % (time.mktime(dt_start.timetuple()) * 1000000)
        ts_end = "%.0f" % (time.mktime(dt_end.timetuple()) * 1000000)

        channel_guid, server_guid = channel_full_guid.split("_")

        options = {
            "prefer_substream": prefer_substream,
            "postponed_until_ts": self._get_prebuffer(server_guid, dt_end),
        }

        if file_name is None:
            file_name = self._EXPORTED_VIDEO_NAME_TEMPLATE.format(
                name=BaseUtils.get_object_name_by_guid(channel_guid),
                dt_start=dt_start.strftime("%Y.%m.%d %H-%M-%S"),
                dt_end=dt_end.strftime("%Y.%m.%d %H-%M-%S"),
                sub="_sub" if prefer_substream else "",
            )

        if file_path is None:
            file_path = self.export_folder

        exporting_path = os.path.join(file_path, file_name)

        if callback is None:
            callback = BaseUtils.do_nothing

        self._now_exporting = True

        def checker(status):
            self._export_checker(status, callback, exporting_path, channel_full_guid)

        host.archive_export(
            server_guid,
            channel_guid,
            exporting_path,
            ts_start,
            ts_end,
            options,
            checker,
        )

    def export(  # pylint: disable=R0913
        self,
        channel_full_guid,
        dt_start,
        dt_end=None,
        duration=60,
        prefer_substream=False,
        file_name=None,
        file_path=None,
        callback=None,
    ):
        """Запускает экспорт или добавляет задачу экспорта в очередь.

        После завершения экспорта вызывает ``callback`` функцию
        а также очищает список задач экспорта в панеле управления Trassir.

        Note:
            Задача экспорта добавляется только после завершения предыдущей.

        Tip:
            - Вы можете задать время начала и окончания экспорта
              ``dt_start``, ``dt_end``.
            - Или можно задать время начала экспорта ``dt_start`` и
              продолжительность экспорта (в сек.) ``duration``. По умолчнию
              ``duration=60``.
            - Если ``dt_end=None`` фунция использует ``duration`` для вычисления
              времени окончания ``dt_end = dt_start + timedelta(seconds=duration)``.

        Args:
            channel_full_guid (:obj:`str`): Полный guid канала. Например: ``"CFsuNBzt_pV4ggECb"``
            dt_start (:obj:`datetime.datetime`): :obj:`datetime.datetime` начала экспорта
            dt_end (:obj:`datetime.datetime`, optional): :obj:`datetime.datetime` окончания экспорта.
                По умолчанию :obj:`None`
            duration (:obj:`int`, optional): Продолжительность экспорта, в секундах. Используется если
                ``dt_end is None``. По умолчанию ``60``
            prefer_substream (:obj:`bool`, optional): Если ``True`` - Экспортирует субпоток.
                По умолчанию ``False``
            file_name (:obj:`str`, optional): Имя экспортируемого файла. По умолчанию :obj:`None`
            file_path (:obj:`str`, optional): Путь для экспорта. По умолчанию :obj:`None`
            callback (:obj:`function`, optional): Функция, которая вызывается после завершения экспорта.
                По умолчанию :obj:`None`
        """

        args = (channel_full_guid, dt_start)
        kwargs = {
            "dt_end": dt_end,
            "duration": duration,
            "prefer_substream": prefer_substream,
            "file_name": file_name,
            "file_path": file_path,
            "callback": callback,
        }
        if self._now_exporting:
            self._queue.append((args, kwargs))
        else:
            self._export(*args, **kwargs)


class TemplateError(ScriptError):
    """Raised by Template class"""

    pass


class GUITemplate(py_object):
    """Класс для работы с шаблонами Trassir

    При инициализации находит существующий шаблон по имени или создает новый.

    Note:
        Если вручную создать два или большее шаблона с одинаковыми именами
        данный класс выберет первый попавшийся шаблон с заданным именем.

    Warning:
            Работа с контентом шаблона может привести к падениям трассира.
            Используйте данный класс на свой страх и риск!

    Tip:
        Для понимания, как формируется контент отредактируйте любой шаблон
        вручную и посмотрите что получится в скрытых параметрах трассира
        (активируются нажатием клавиши F4 в настройках трассира)
        `Настройки/Шабоны/<Имя шаблона>/content`

        Ниже предсталвены некоторые примеры шаблонов

        - Вывод одного канала ``S0tE8nfg_Or3QZu4D``
          :obj:`gui7(DEWARP_SETTINGS,zwVj07w0,dewarp(),1,S0tE8nfg_Or3QZu4D)`
        - Вывод шаблона 4х4 с каналами двумя ``Kpid6EC0_Or3QZu4D``, ``ZRtXLrgu_Or3QZu4D``
          :obj:`gui7(DEWARP_SETTINGS,zwVj07w0,dewarp(),4,Kpid6EC0_Or3QZu4D,ZRtXLrgu_Or3QZu4D,,)`
        - Вывод шаблон с минибраузером и ссылкой на https://www.google.com/
          :obj:`minibrowser(0,htmltab(,https://www.google.com/))`

    Args:
        template_name (:obj:`str`): Имя шаблон

    Examples:
        >>> # Создаем шаблон с именем "New template" и получаем его guid
        >>> template = GUITemplate("New template")
        >>> template.guid
        'Y2YFAkeZ'


        >>> # Устанавливаем на шаблон минибраузер с ссылкой на google
        >>> template.content = "minibrowser(0,htmltab(,https://www.google.com/))"

        >>> # Изменяем имя шаблона на "Google search"
        >>> template.name = "Google search"

        >>> # Открываем шаблон на первом мониторе
        >>> template.show(1)
    """

    _DEFAULT_TEMPLATE = ""

    def __init__(self, template_name):
        self._name = template_name
        self._operator_gui = BaseUtils.get_operator_gui()
        try:
            self._guid, self._template_settings = self._find_template_guid(
                template_name
            )
        except KeyError:
            self._guid, self._template_settings = self._init_template(template_name)

    @staticmethod
    def _find_template_guid(name):
        """Find template guid by name

        Args:
            name (str) : Template name

        Raises:
            KeyError if can't find template
        """
        templates = host.settings("templates")
        for template_ in templates.ls():
            if name == template_.name:
                return (
                    template_.guid,
                    host.settings("templates/{}".format(template_.guid)),
                )
        raise KeyError

    def _init_template(self, name):
        """Create new template

        Args:
            name (str) : Template name
        """
        host.object(host.settings("").guid + "T").create_template(
            name, self._DEFAULT_TEMPLATE
        )
        try:
            return self._find_template_guid(name)
        except KeyError:
            raise TemplateError("Failed to create template {}".format(self._name))

    @property
    def guid(self):
        """:obj:`str`: Guid шаблона"""
        return self._guid

    @guid.setter
    def guid(self, value):  # pylint: disable=W0613,R0201
        raise RuntimeError("You can't change object guid")

    @property
    def name(self):
        """:obj:`str`: Имя шаблона"""
        return self._name

    @name.setter
    def name(self, value):
        if isinstance(value, str):
            self._name = value
            self._template_settings["name"] = value
        else:
            raise TypeError("Expected str, got {}".format(type(value).__name__))

    @property
    def content(self):
        """:obj:`str`: Контент шаблона"""
        return self._template_settings["content"]

    @content.setter
    def content(self, value):
        if isinstance(value, str):
            self._template_settings["content"] = value
        else:
            raise TypeError("Expected str, got {}".format(type(value).__name__))

    def delete(self):
        """Удаляет шаблон"""
        obj = BaseUtils.get_object(self.guid)
        if obj is None:
            raise TemplateError("Template object not found!")

        obj.delete_template()

    def show(self, monitor=1):
        """Открывает шаблон на указаном мониторе

        Args:
            monitor (:obj:`int`, optional): Номер монитора. По умолчанию ``monitor=1``
        """
        self._operator_gui.show(self.guid, monitor)


class TrObject(py_object):  # pylint: disable=R0902
    """Вспомогательный класс для работы с объектами Trassir

    Attributes:
        obj (:obj:`SE_Object`): Объект trassir :obj:`object('{guid}')` или :obj:`None`
        obj_methods (List[:obj:`str`]): Список методов объекта :attr:`TrObject.obj`
        name (:obj:`str`): Имя объекта или его guid
        guid (:obj:`str`): Guid объекта
        full_guid (:obj:`str`): Полный guid :obj:`{guid объекта}_{guid сервера}`
            или :obj:`None`
        type (:obj:`str`): Тип объекта, например :obj:`"RemoteServer"`, :obj:`"Channel"`,
            :obj:`"Grabber"`, :obj:`"User"`, и др.
        path (:obj:`str`): Путь в настройках или :obj:`None`
        parent (:obj:`str`): Guid родительского объекта или :obj:`None`
        server (:obj:`str`): Guid сервера или :obj:`None`
        settings (:obj:`SE_Settings`): Объект настроек ``settings('{path}')`` или :obj:`None`

    Raises:
        TypeError: Если неправильные параметры объекта
        ValueError: Если в имени объекта есть запятые
    """

    obj, name, guid, full_guid, type = None, None, None, None, None
    path, parent, server, settings = None, None, None, None

    def __init__(self, obj):

        if isinstance(obj, host.ScriptHost.SE_Settings):
            self._load_from_settings(obj)
        elif isinstance(obj, tuple):
            if len(obj) == 4:
                self._load_from_tuple(obj)
            else:
                raise TypeError(
                    "Expected tuple(name, guid, type, parent), got tuple'{}'".format(
                        obj
                    )
                )
        else:
            raise TypeError("Unexpected object type '{}'".format(type(obj).__name__))

    @staticmethod
    def _check_object_name(object_name):
        """Check if object name hasn't got commas

        Args:
            object_name (str):

        Returns:
            str: object_name.strip()

        Raises:
            ValueError: If "," found in object name
        """
        if "," in object_name:
            raise ValueError(
                "Please, rename object '{}' without commas".format(object_name)
            )
        return object_name.strip()

    @staticmethod
    def _parse_server_from_path(path):
        """Parse server guid from full path

        Args:
            path (str): Full Trassir settings path;
                example: '/pV4ggECb/_persons/n68LOBhG' returns 'pV4ggECb'
        """
        try:
            server = path.split("/", 2)[1]
        except IndexError:
            server = None

        return server

    @staticmethod
    def _find_server_guid_for_object(object_guid):
        """Find server guid for object

        Args:
            object_guid (str): Object guid

        Returns:
            str: Server guid if server found
            None: If server not found
        """
        all_objects = {
            obj[1]: {"name": obj[0], "guid": obj[1], "type": obj[2], "parent": obj[3]}
            for obj in host.objects_list("")
        }

        def get_parent(child_guid):
            child = all_objects.get(child_guid, None)
            if child:
                if child["type"] == "Server":
                    return child["guid"]
                return get_parent(child["parent"])
            return ""

        return get_parent(object_guid)

    def _get_object_methods(self):
        """Get object methods"""
        if self.obj:
            return [method for method in dir(self.obj) if not method.startswith("__")]
        return []

    def _load_from_settings(self, obj):
        """Preparing attributes from SE_Settings object"""
        self.obj = BaseUtils.get_object(obj.guid)
        self.obj_methods = self._get_object_methods()

        try:
            obj_name = obj.name
        except KeyError:
            obj_name = obj.guid

        self.name = self._check_object_name(obj_name)
        self.guid = obj.guid
        self.type = obj.type
        self.path = obj.path
        self.server = self._parse_server_from_path(obj.path)
        self.settings = obj

        if self.server and self.server != self.guid:
            self.full_guid = "{0.guid}_{0.server}".format(self)

    def _load_from_tuple(self, obj):
        """Preparing attributes from tuple object"""
        self.obj = BaseUtils.get_object(obj[1])
        self.obj_methods = self._get_object_methods()
        self.name = self._check_object_name(obj[0])
        self.guid = obj[1]
        self.type = obj[2]
        self.parent = obj[3]
        self.server = self._find_server_guid_for_object(obj[1])

        if self.server and self.server != self.guid:
            self.full_guid = "{0.guid}_{0.server}".format(self)

    def __repr__(self):
        return "TrObject('{}')".format(self.name)

    def __str__(self):
        return "{self.type}: {self.name} ({self.guid})".format(self=self)


class ParameterError(ScriptError):
    """Ошибка в параметрах скрипта"""

    pass


class BasicObject(py_object):  # pylint: disable=R0903
    """Basic object class"""

    def __init__(self):
        self.this_server_guid = BaseUtils.get_server_guid()

    class UniqueNameError(ScriptError):
        """Имя объекта не уникально"""

        pass

    class ObjectsNotFoundError(ScriptError):
        """Не найдены объекты с заданными именами"""

        pass

    def _check_unique_name(self, objects, object_names):
        """Check if all objects name are unique

        Args:
            objects (list): Objects list from _get_objects_from_settings

        Raises:
            UniqueNameError: If some object name is not uniques
        """
        unique_names = []
        for obj in objects:
            if obj.name in object_names:
                if obj.name not in unique_names:
                    unique_names.append(obj.name)
                else:
                    raise self.UniqueNameError(
                        "Найдено несколько объектов {obj.type} с одинаковым именем '{obj.name}'! "
                        "Задайте уникальные имена".format(obj=obj)
                    )

    @staticmethod
    def _objects_str_to_list(objects):
        """Split object names if objects is str and strip each name

        Args:
            objects (str|list): Trassir object names in comma spaced string or list

        Returns:
            list: Stripped Trassir object names

        Raises:
            ScriptError: If object name selected more than once
        """
        if isinstance(objects, str):
            objects = objects.split(",")

        names = []
        for name in objects:
            strip_name = name.strip()
            if strip_name in names:
                raise ParameterError("Объект '{}' выбран несколько раз".format(name))
            names.append(strip_name)

        return names

    def _filter_objects_by_name(self, objects, object_names):
        """Filter object by names

        Args:
            objects (list): TrObject objects list
            object_names (str|list): Trassir object names in comma spaced string or list

        Raises:
            ObjectsNotFoundError: If len(object_name) != len(filtered_object)
        """
        object_names = self._objects_str_to_list(object_names)

        self._check_unique_name(objects, object_names)

        filtered_object = [obj for obj in objects if obj.name in object_names]

        if len(filtered_object) != len(object_names):
            channels_not_found = set(object_names) - set(
                obj.name for obj in filtered_object
            )

            try:
                object_type = objects[0].type
            except IndexError:
                object_type = "Unknown"

            raise self.ObjectsNotFoundError(
                "Не найдены объекты {object_type}: {names}".format(
                    object_type=object_type,
                    names=", ".join(name for name in channels_not_found),
                )
            )

        return filtered_object


class ObjectFromSetting(BasicObject):  # pylint: disable=R0903
    """Base class for setting objects"""

    def __init__(self):  # pylint: disable=W0235
        super(ObjectFromSetting, self).__init__()

    @staticmethod
    def _load_objects_from_settings(settings_path, obj_type, sub_condition=None):
        """Load objects from Trassir settings

        Args:
            settings_path (:obj:`str`): Trassir settings path. Example ``"scripts"``.
                Click F4 in the Trassir settings window to show hidden parameters.
            obj_type (:obj:`str` | :obj:`list`): Loading object type. Example ``"EmailAccount"``
            sub_condition (function, optional): Function with SE_Settings as argument to filter objects

        Returns:
            list: TrObject objects list
                Example [TrObject(...), TrObject(...), ...]
        """
        try:
            settings = host.settings(settings_path)
        except KeyError:
            settings = None

        objects = []
        if settings is not None:
            if isinstance(obj_type, str):
                obj_type = [obj_type]

            if sub_condition is None:
                sub_condition = BaseUtils.do_nothing

            for obj in settings.ls():
                if obj.type in obj_type:
                    if sub_condition(obj):
                        objects.append(TrObject(obj))
        return objects

    def _get_objects_from_settings(  # pylint: disable=R0913
        self,
        settings_path,
        object_type,
        object_names=None,
        server_guid=None,
        ban_empty_result=False,
        sub_condition=None,
    ):
        """Check if objects exists and returns list from _load_objects_from_settings

        Note:
             If object_names is not None - checking if all object names are unique

        Args:
            settings_path (:obj:`str`): Trassir settings path. Example ``"scripts"``.
                Click F4 in the Trassir settings window to show hidden parameters.
            object_type (:obj:`str` | :obj:`list`): Loading object type. Example ``"EmailAccount"``
            object_names (:obj:`str` | :obj:`list`, optional): Comma spaced string or
                list of object names. Default :obj:`None`
            server_guid (:obj:`str` | :obj:`list`, optional): Server guid. Default :obj:`None`
            ban_empty_result (:obj:`bool`, optional): If True - raise error if no one object found
            sub_condition (:obj:`func`, optional) : Function with SE_Settings as argument to filter objects

        Returns:
            list: Trassir list from _load_objects_from_settings

        Raises:
            ObjectsNotFoundError: If can't find channel
        """
        if object_names == "":
            raise ParameterError("'{}' не выбраны".format(object_type))

        if server_guid is None:
            server_guid = self.this_server_guid

        if isinstance(server_guid, str):
            server_guid = [server_guid]

        objects = []

        for guid in server_guid:
            objects += self._load_objects_from_settings(
                settings_path.format(server_guid=guid), object_type, sub_condition
            )

        if ban_empty_result and not objects:
            raise self.ObjectsNotFoundError(
                "Не найдено ниодного объекта '{}'".format(object_type)
            )

        if object_names is None:
            return objects
        return self._filter_objects_by_name(objects, object_names)


class Servers(ObjectFromSetting):
    """Класс для работы с серверами

    Examples:
        >>> srvs = Servers()
        >>> local_srv = srvs.get_local()
        [TrObject('Клиент')]
        >>> # Првоерим "Здоровье" локального сервера
        >>> local_srv[0].obj.state("server_health")
        'Health Problem'
    """

    def __init__(self):  # pylint: disable=W0235
        super(Servers, self).__init__()

    def get_local(self):
        """Возвращает локальный сервер (на котором запущен скрипт)

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._load_objects_from_settings("/", ["Client", "LocalServer"])

    def get_remote(self):
        """Возвращает список удаленных серверов

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._load_objects_from_settings("/", "RemoteServer")

    def get_all(self):
        """Возвращает список всех доступных серверов

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._load_objects_from_settings(
            "/", ["Client", "LocalServer", "RemoteServer"]
        )


class Channels(ObjectFromSetting):
    """Класс для работы с каналами

    See Also:
        `Каналы - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-channels-folder.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> channels = Channels()
        >>> selected_channels = channels.get_enabled("AC-D2121IR3W 2,AC-D9141IR2 1")
        >>> selected_channels
        [TrObject('AC-D2121IR3W 2'), TrObject('AC-D9141IR2 1')]
        >>>
        >>> # Включим ручную запись на выбранных каналах
        >>> for channel in selected_channels:
        ...     channel.obj.manual_record_start()
        >>>
        >>> # Или добавим к имени канала его guid
        >>> for channel in selected_channels:
        ...     channel.settings["name"] += " ({})".format(channel.guid)
    """

    def __init__(self, server_guid=None):
        super(Channels, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных каналов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            not_zombie = 1 - sett["archive_zombie_flag"]
            if not_zombie:
                try:
                    return host.settings(sett.cd("info")["grabber_path"])[
                        "grabber_enabled"
                    ]
                except KeyError:
                    return 0
            return 0

        return self._get_objects_from_settings(
            "/{server_guid}/channels",
            "Channel",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных каналов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            zombie = sett["archive_zombie_flag"]
            if not zombie:
                try:
                    return (
                        1
                        - host.settings(sett.cd("info")["grabber_path"])[
                            "grabber_enabled"
                        ]
                    )
                except KeyError:
                    return 1
            return 1

        return self._get_objects_from_settings(
            "/{server_guid}/channels",
            "Channel",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех каналов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/channels",
            "Channel",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Devices(ObjectFromSetting):
    """Класс для работы с ip устройствами

    See Also:
        `IP-устройства - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-ip-cameras-folder.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> devices = Devices()
        >>> enabled_devices = devices.get_enabled()
        >>> enabled_devices
        [TrObject('AC-D2121IR3W'), TrObject('AC-D5123IR32'), ...]
        >>>
        >>> # Перезагрузим все устройства
        >>> for dev in enabled_devices:
        ...     dev.settings["reboot"] = 1
    """

    def __init__(self, server_guid=None):
        super(Devices, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных устройств

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["grabber_enabled"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/ip_cameras",
            "Grabber",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных устройств

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["grabber_enabled"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/ip_cameras",
            "Grabber",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех устройств

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/ip_cameras",
            "Grabber",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Scripts(ObjectFromSetting):
    """Класс для работы со скриптами

    See Also:
        `Скрипты - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-script-feature.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> scripts = Scripts()
        >>> all_scripts = scripts.get_all()
        >>> all_scripts
        [TrObject('Новый скрипт'), TrObject('HDD Health Monitor'), TrObject('Password Reminder')]
        >>>
        >>> # Отключим все скрипты
        >>> for script in all_scripts:
        ...     script.settings["enable"] = 0
    """

    def __init__(self, server_guid=None):
        super(Scripts, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных скриптов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["enable"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Script",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных скриптов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["enable"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Script",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех скриптов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Script",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class StockScripts(ObjectFromSetting):
    """Класс для работы со встроенными скриптами

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> stock_scripts = StockScripts()
        >>> all_scripts = stock_scripts.get_all()
        >>> all_scripts
        [TrObject('MegaRAID Monitor')]
        >>>
        >>> # Отключим все скрипты
        >>> for script in all_scripts:
        ...     script.settings["enable"] = 0
    """

    def __init__(self, server_guid=None):
        super(StockScripts, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных скриптов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["enable"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "StockScript",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных скриптов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["enable"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "StockScript",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех скриптов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "StockScript",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Rules(ObjectFromSetting):
    """Класс для работы с правилами

    See Also:
        `Правила - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-rule.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> rules = Rules()
        >>> all_rules = rules.get_all()
        >>> all_rules
        [TrObject('!Rule'), TrObject('NEW RULE'), TrObject('Новое правило')]
        >>>
        >>> # Отключим все правила
        >>> for rule in all_rules:
        ...     rule.settings["enable"] = 0
    """

    def __init__(self, server_guid=None):
        super(Rules, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных правил

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["enable"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Rule",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных правил

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["enable"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Rule",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех правил

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен. По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Rule",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Schedules(ObjectFromSetting):
    """Класс для работы с расписаниями

    See Also:
        `Расписания - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-schedule.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> schedules = Schedules()
        >>> my_schedule = schedules.get_enabled("!Schedule")[0]
        >>> my_schedule.obj.state("color")
        'Red'
    """

    def __init__(self, server_guid=None):
        super(Schedules, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    @BaseUtils.run_as_thread
    def on_load(self, schedule_name, callback, tries=5):
        """on_load(schedule_name, callback, tries=5)
        Вызывает `callback` после загрузки расписания

        Note:
            При загрузке сервера, объект расписания становится не сразу доступен.
            Данный метод помогает предотвратить данную ошибку.

        Args:
            schedule_name (:obj:`str`): Имя расписания
            callback (:obj:`function`): Функция, которая вызывается после
                загрузки расписания.
            tries (:obj:`int`, optional): Кол-во попыток загрузки расписания.
                Каждая попытка производится с интервалом 1 с. По умолчанию :obj:`5`

        Examples
            >>> schedule = None
            >>> # noinspection PyGlobalUndefined,PyUnresolvedReferences
            >>> def on_schedule_loaded(schedule_obj):
            ...     global schedule
            ...     schedule = schedule_obj
            ...
            ...     message("Schedule '{obj.name}' ({obj.guid}) loaded".format(obj=schedule))
            ...     schedule.activate_on_state_changes(lambda: alert(schedule.state("color")))
            >>>
            >>> Schedules().on_load("Unnamed Schedule", on_schedule_loaded)
        """
        if not schedule_name:
            raise ParameterError("Empty schedule name")

        tmp_server_guid = self.server_guid
        self.server_guid = BaseUtils.get_server_guid()

        while tries:
            obj = self.get_enabled(schedule_name)[0].obj

            if obj is None:
                tries -= 1
                time.sleep(1)
            else:
                self.server_guid = tmp_server_guid
                host.timeout(1, lambda: callback(obj))
                break
        else:
            self.server_guid = tmp_server_guid
            raise ScriptError(
                "Ошибка получения объекта расписания '{}'".format(schedule_name)
            )

    def get_enabled(self, names=None):
        """Возвращает список активных расписаний

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["enable"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Schedule",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных расписаний

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["enable"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Schedule",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех расписаний

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Schedule",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class TemplateLoops(ObjectFromSetting):
    """Класс для работы с циклическими просмотрами шаблонов

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> tmplate_loops = TemplateLoops()
        >>> tmplate_loops.get_all()
        [TrObject('Новый циклический просмотр')]
    """

    def __init__(self, server_guid=None):
        super(TemplateLoops, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных циклических просмотров шаблонов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["enable"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "TemplateLoop",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных циклических просмотров шаблонов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["enable"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "TemplateLoop",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех циклических просмотров шаблонов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "TemplateLoop",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class EmailAccounts(ObjectFromSetting):  # pylint: disable=R0903
    """Класс для работы с E-Mail аккаунтами

    See Also:
        `Добавление учетной записи e-mail - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-email-account.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> email_accounts = EmailAccounts()
        >>> email_accounts.get_all()
        [TrObject('Новая учетная запись e-mail'), TrObject('MyAccount')]
    """

    def __init__(self, server_guid=None):
        super(EmailAccounts, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_all(self, names=None):
        """Возвращает список всех E-Mail аккаунтов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "EmailAccount",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class NetworkNodes(ObjectFromSetting):
    """Класс для работы с сетевыми подключениями

    See Also:
        `Сеть - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-network-folder.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> network_nodes = NetworkNodes("client")
        >>> network_nodes.get_enabled()
        [TrObject('QuattroStationPro (172.20.0.101)'), TrObject('NSK-HD-01 (127.0.0.1)')]
    """

    def __init__(self, server_guid=None):
        super(NetworkNodes, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных сетевых подключений

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["should_be_connected"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/network",
            "NetworkNode",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных сетевых подключений

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["should_be_connected"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/network",
            "NetworkNode",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех сетевых подключений

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/network",
            "NetworkNode",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class PosTerminals(ObjectFromSetting):
    """Класс для работы с POS Терминалами

    See Also:
        `Настройка POS-терминалов - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-pos-terminals-folder.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> pos_terminals = PosTerminals()
        >>> pos_terminals.get_disabled()
        [TrObject('Касса (1)')]
    """

    def __init__(self, server_guid=None):
        super(PosTerminals, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных POS Терминалов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["pos_enable"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/pos_folder2/terminals",
            "PosTerminal",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных POS Терминалов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["pos_enable"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/pos_folder2/terminals",
            "PosTerminal",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех POS Терминалов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/pos_folder2/terminals",
            "PosTerminal",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Users(ObjectFromSetting):
    """Класс для работы с пользователями и их группами.

    See Also:
        `Пользователи - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-users-folder.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> users = Users()
        >>> users.get_groups()
        [TrObject('TEST')]
    """

    def __init__(self, server_guid=None):
        super(Users, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_groups(self, names=None):
        """Возвращает список групп пользователей

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_settings(
            "/{server_guid}/users",
            "Group",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_users(self, names=None):
        """Возвращает список пользователей

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_settings(
            "/{server_guid}/users",
            "User",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_users_by_groups(self, group_names):
        """Возвращает список пользователей из указанных групп

        Args:
            group_names (:obj:`str` | :obj:`list`): :obj:`str` - имена групп,
                разделенные запятыми или :obj:`list` - список имен.

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        if group_names is None:
            groups = [""]
        else:
            groups = [group.guid for group in self.get_groups(names=group_names)]

        def sub_condition(sett):
            return sett["group"] in groups

        return self._get_objects_from_settings(
            "/{server_guid}/users",
            "User",
            object_names=None,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )


class Templates(ObjectFromSetting):  # pylint: disable=R0903
    """Класс для работы с существующими шаблонами.

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> templates = Templates(BaseUtils.get_server_guid())
        >>> templates.get_all()
        [TrObject('Parking'), TrObject('FR'), TrObject('AT'), TrObject('AD+')]
    """

    def __init__(self, server_guid=None):
        super(Templates, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_all(self, names=None):
        """Возвращает список шаблонов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_settings(
            "/{server_guid}/templates",
            "Template",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Persons(ObjectFromSetting):
    """Класс для работы с персонами и их папками.

    See Also:
        `Персоны - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-persons-folder.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
            >>> persons = Persons()
            >>> persons.get_folders()
            [TrObject('Мошенники'), TrObject('DSSL'), TrObject('persons')]
            >>> persons.get_persons()
            [
                {
                    'name': 'Leonardo',
                    'guid': 'cJuJYAha',
                    'gender': 0,
                    'birth_date': '1980-01-01',
                    'comment': 'Comment',
                    'contact_info': 'Contact info',
                    'folder_guid': 'n68LOBhG',
                    'image': <image, str>,
                    'image_guid': 'gBHZ2vpz',
                    'effective_rights': 0,
                },
                ...
            ]
            >>> persons.get_person_by_guid("cJuJYAha")
            {
                'name': 'Leonardo',
                'guid': 'cJuJYAha',
                'gender': 0,
                'birth_date': '1980-01-01',
                'comment': 'Comment',
                'contact_info': 'Contact info',
                'folder_guid': 'n68LOBhG',
                'image': <image, str>,
                'image_guid': 'gBHZ2vpz',
                'effective_rights': 0,
            }
    """

    _PERSONS_UPDATE_TIMEOUT = 10 * 60  # Time in sec between update _persons dict

    def __init__(self, server_guid=None):
        super(Persons, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        if isinstance(server_guid, str):
            server_guid = [server_guid]

        self.server_guid = server_guid

        self._persons = None

    def _update_persons_dict(self, timeout=10):
        """Updating self._persons dict"""
        persons = self.get_persons(timeout=timeout)
        by_guid, by_name = {}, {}
        for person in persons:
            by_guid[person["guid"]] = person
            by_name[person["name"]] = person

        self._persons = {
            "update_ts": int(time.time()),
            "by_guid": by_guid,
            "by_name": by_name,
        }

    def _check_loaded_persons(self, timeout=10):
        """This method check if self._persons dict is need to be updated"""
        ts_now = int(time.time())

        if (
            self._persons is None
            or (ts_now - self._persons["update_ts"]) > self._PERSONS_UPDATE_TIMEOUT
        ):
            self._update_persons_dict(timeout=timeout)

    def get_folders(self, names=None):
        """Возвращает список папок персон

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        try:
            folders = self._get_objects_from_settings(
                "/{server_guid}/persons",
                "PersonsSubFolder",
                object_names=names,
                server_guid=self.server_guid,
            )

            if names is None or "persons" in names:
                for guid in self.server_guid:
                    try:
                        settings = host.settings("/{}/persons".format(guid))
                    except KeyError:
                        continue

                    folders.append(TrObject(settings))

        except self.ObjectsNotFoundError as err:
            folders = []
            names = self._objects_str_to_list(names)

            if names is None or "persons" in names:
                for guid in self.server_guid:
                    try:
                        settings = host.settings("/{}/persons".format(guid))
                    except KeyError:
                        continue

                    folders.append(TrObject(settings))

            if not folders:
                raise err

        return folders

    def get_persons(self, folder_names=None, timeout=10):
        """Возвращает список персон

        Note:
            Данный метод работает только с локальной БД.

        Args:
            folder_names (:obj:`str` | List[:obj:`str`], optional): :obj:`str` -
                названия папок персон, разделенные запятыми или :obj:`list` -
                список папок персон. По умолчанию :obj:`None`
            timeout (:obj:`int`, optional): Макс. время запроса к БД.
                По умолчанию ``timeout=10``

        Returns:
            List[:obj:`dict`]: Список персон - если персоны найдены

        Raises:
            EnvironmentError: Если произошла ошибка при запросе в БД.
            TrassirError: Если в данной сборке Trassir нет метода :obj:`host_ip.service_persons_get`
        """
        tmp_server_guid = self.server_guid[:]
        self.server_guid = [self.this_server_guid]
        persons_folders = self.get_folders(names=folder_names)
        self.server_guid = tmp_server_guid[:]

        try:
            persons = host.service_persons_get(
                [folder.guid for folder in persons_folders], True, 0, 0, timeout
            )
        except AttributeError:
            raise TrassirError(
                "Данный функционал не поддерживается вашей сборкой Trassir. "
                "Попробуйте обновить ПО."
            )

        if isinstance(persons, str):
            raise EnvironmentError(persons)

        return persons

    def get_person_by_guid(self, person_guid, timeout=10):
        """Возвращает информацию о персоне по его guid

        Note:
            Для уменьшения кол-ва запросов к БД - метод создает локальную
            копию всех персон при первом запросе и обновляет ее вместе
            с последующими запросами не чаще чем 1 раз в 10 минут.

        Args:
            person_guid (:obj:`str`): Guid персоны
            timeout (:obj:`int`, optional): Макс. время запроса к БД.
                По умолчанию ``timeout=10``

        Returns:
            :obj:`dict`: Даные о персоне или :obj:`None` если персона не найдена
        """
        self._check_loaded_persons(timeout=timeout)
        return self._persons["by_guid"].get(person_guid)

    def get_person_by_name(self, person_name, timeout=10):
        """Возвращает информацию о персоне по его имени

        Note:
            Для уменьшения кол-ва запросов к БД - метод создает локальную
            копию всех персон при первом запросе и обновляет ее вместе
            с последующими запросами не чаще чем 1 раз в 10 минут.

        Args:
            person_name (:obj:`str`): Имя персоны
            timeout (:obj:`int`, optional): Макс. время запроса к БД.
                По умолчанию ``timeout=10``

        Returns:
            :obj:`dict`: Даные о персоне или :obj:`None` если персона не найдена
        """
        self._check_loaded_persons(timeout=timeout)
        return self._persons["by_name"].get(person_name)


class ObjectFromList(BasicObject):  # pylint: disable=R0903
    """Base class for object from objscts list"""

    def __init__(self):  # pylint: disable=W0235
        super(ObjectFromList, self).__init__()

    @staticmethod
    def _load_objects_from_list(obj_type, sub_condition=None):
        """Load objects from Trassir objects_list method

        Args:
            obj_type (str | list): Loading object type; example: "EmailAccount"
            sub_condition (function, optional): Function with SE_Settings as argument to filter objects

        Returns:
            list: TrObject objects list
                Example [TrObject(...), TrObject(...), ...]
        """
        if sub_condition is None:
            sub_condition = BaseUtils.do_nothing

        objects = []
        for obj in host.objects_list(obj_type):
            if sub_condition(obj):
                objects.append(TrObject(obj))

        return objects

    def _get_objects_from_list(  # pylint: disable=R0913
        self,
        object_type,
        object_names=None,
        server_guid=None,
        ban_empty_result=False,
        sub_condition=None,
    ):
        """Check if objects exists and returns list from _load_objects_from_settings

        Note:
             If object_names is not None - checking if all object names are unique

        Args:
            object_type (str|list): Loading object type; example: "EmailAccount"
            object_names (str|list, optional): Comma spaced string or list of object names; default: None
            server_guid (str|list, optional): Server guids; default: None
            ban_empty_result (bool, optional): If True - raise ObjectsNotFoundError if no one object found
            sub_condition (func, optional) : Function with SE_Settings as argument to filter objects

        Returns:
            list: Trassir list from _load_objects_from_settings

        Raises:
            ObjectsNotFoundError: If can't find channel
        """
        if object_names == "":
            raise ParameterError("'{}' не выбраны".format(object_type))

        if server_guid is None:
            server_guid = self.this_server_guid
        else:
            if isinstance(server_guid, str):
                server_guid = [server_guid]

        objects = self._load_objects_from_list(object_type, sub_condition)

        objects = [obj for obj in objects if obj.server in server_guid]

        if ban_empty_result and not objects:
            raise self.ObjectsNotFoundError(
                "Не найдено ниодного объекта '{}'".format(object_type)
            )

        if object_names is None:
            return objects
        return self._filter_objects_by_name(objects, object_names)

    @staticmethod
    def _zone_type(zone_obj):  # pylint: disable=R0911,R0912,R1710
        """Возвращает тип зоны для объекта

        Args:
            zone_obj (:obj:`SE_Object`): Объект trassir ``object('{guid}')``

        Returns:
            :obj:`str`: Тип объекта
            :obj:`None`: Если тип зоны неизвестен
        """

        if not isinstance(zone_obj, host.ScriptHost.SE_Object):
            raise TypeError(
                "Expected SE_Object, got '{}'".format(type(zone_obj).__name__)
            )

        try:
            guid = zone_obj.guid
            channel, server = zone_obj.associated_channel.split("_")
        except (AttributeError, ValueError):
            return

        try:
            zones_dir = host.settings(
                "/{}/channels/{}/people_zones".format(server, channel)
            )
            for i in xrange(16):
                if zones_dir["zone%02d_guid" % i] == guid:
                    func_type = zones_dir["zone%02d_func_type" % i]
                    if isinstance(func_type, int):
                        return (
                            ["Queue", "Workplace"][func_type]
                            if func_type in range(2)
                            else "Queue"
                        )
                    return func_type
        except KeyError:
            # not a queue or workplace
            pass

        try:
            zones_dir = host.settings(
                "/{}/channels/{}/workplace_zones".format(server, channel)
            )
            for i in xrange(16):
                if zones_dir["zone%02d_guid" % i] == guid:
                    return "Workplace"
        except KeyError:
            # not a workplace
            pass

        try:
            zones_dir = host.settings("/%s/channels/%s/deep_people" % (server, channel))
            for i in xrange(16):
                if zones_dir["zone%02d_guid" % i] == guid:
                    if zones_dir["zone%02d_type" % i] in ["border", "border_swapped"]:
                        return "Border"
                    return "Queue"
        except KeyError:
            # not a deep people queue
            pass


class GPIO(ObjectFromList):
    """Класс для работы с тревожными входами/выходами

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> gpio = GPIO()
        >>> gpio_door = gpio.get_inputs("Door")[0]
        >>> gpio_door.obj.state("gpio_input_level")
        'Input Low (Normal High)'
        >>> gpio_light = gpio.get_outputs("Light")[0]
        >>> gpio_light.obj.set_output_high()
    """

    def __init__(self, server_guid=None):
        super(GPIO, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_inputs(self, names=None):
        """Возвращает список тревожных входов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "GPIO Input",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_outputs(self, names=None):
        """Возвращает список тревожных выходов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "GPIO Output",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Zones(ObjectFromList):
    """Класс для работы с зонами

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> zones = Zones()
        >>> zones.get_queues("Касса 1")[0].obj.state("zone_queue")
        '5+'
    """

    def __init__(self, server_guid=None):
        super(Zones, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_people(self, names=None):
        """Возвращает список PeopleZones

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "PeopleZone",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_simt(self, names=None):
        """Возвращает список зон SIMT

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "SIMT Zone",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_workplaces(self, names=None):
        """Возвращает список рабочих зон

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        people_zones = self.get_people(names=names)

        return [
            zone
            for zone in people_zones
            if self._zone_type(zone.obj) in ["Workplace", "Рабочее место"]
        ]

    def get_queues(self, names=None):
        """Возвращает список зон очередей

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        people_zones = self.get_people(names=names)

        return [
            zone
            for zone in people_zones
            if self._zone_type(zone.obj) in ["", "Queue", "Очередь"]
        ]

    def get_shelves(self, names=None):
        """Возвращает список зон полок

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "Shelf",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Borders(ObjectFromList):
    """Класс для работы с линиями пересечения

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> borders = Borders()
        >>> borders.get_simt()
        [TrObject('DBOP')]
        >>> borders.get_all()
        [TrObject('Вход в офис'), TrObject('DBOP')]
    """

    def __init__(self, server_guid=None):
        super(Borders, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_head(self, names=None):
        """Возвращает список HeadBorders

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "HeadBorder",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_people(self, names=None):
        """Возвращает список PeopleBorders

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "PeopleBorder",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_simt(self, names=None):
        """Возвращает список SIMT Borders

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "SIMT Border",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_deep_people(self, names=None):
        """Возвращает список DeepPeopleBorders

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        people_zones = self._get_objects_from_list(
            "PeopleZone",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

        return [zone for zone in people_zones if self._zone_type(zone.obj) == "Border"]

    def get_all(self, names=None):
        """Возвращает список всех линий пересечения

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        all_borders = (
            self.get_head()
            + self.get_people()
            + self.get_simt()
            + self.get_deep_people()
        )

        if names is None:
            return all_borders
        return self._filter_objects_by_name(all_borders, names)


class Sigur(ObjectFromList):  # pylint: disable=R0903
    """Класс для работы со СКУД Sigur

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.
    """

    def __init__(self, server_guid=None):
        super(Sigur, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_access_points(self, names=None):
        """Возвращает список точек доступа

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "Access Point",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class TrassirError(ScriptError):
    """Exception if bad trassir version"""

    pass


class PokaYoke(py_object):
    """Класс для защиты от дурака

    Позволяет блокировать запуск скрипта на ПО, где это
    не предусмотрено (например, на клиенте или TOS).
    А также производить некоторые другие проверки.
    """

    _EMAIL_REGEXP = re.compile(
        r"[^@]+@[^@]+\.[^@]+"
    )  # Default regex to check emails list
    _PHONE_REGEXP = re.compile(r"[^\d,;]")  # Default regex to check phone list

    def __init__(self):
        pass

    @staticmethod
    def ban_tos():
        """Блокирует запуск скрипта на `Trassir OS`

        Raises:
            OSError: Если скрипт запускается на `Trassir OS`

        Examples:
            >>> PokaYoke.ban_tos()
            OSError: Скрипт недоступен для TrassirOS
        """
        if os.name != "nt":
            raise OSError("Скрипт недоступен для TrassirOS")

    @staticmethod
    def ban_win():
        """Блокирует запуск скрипта на `Windows OS`

        Raises:
            OSError: Если скрипт запускается на `Windows OS`

        Examples:
            >>> PokaYoke.ban_win()
            OSError: Скрипт недоступен для WindowsOS
        """
        if os.name == "nt":
            raise OSError("Скрипт недоступен для WindowsOS")

    @staticmethod
    def ban_client():
        """Блокирует запуск скрипта на `Trassir Client`

        Raises:
            TrassirError: Если скрипт запускается на `Trassir Client`

        Examples:
            >>> PokaYoke.ban_client()
            TrassirError: Скрипт недоступен для клиентской версии Trassir
        """
        if BaseUtils.get_server_guid() == "client":
            raise TrassirError("Скрипт недоступен для клиентской версии Trassir")

    @classmethod
    def ban_daemon(cls):
        """Блокирует запуск скрипта на сервре Trassir, который запущен как служба

        Raises:
            TrassirError: Если скрипт запускается на сервре Trassir,
                который запущен как служба

        Examples:
            >>> PokaYoke.ban_daemon()
            TrassirError: Скрипт недоступен для Trassir запущенным как служба
        """
        if host.settings("system_wide_options")["daemon"]:
            raise TrassirError("Скрипт недоступен для Trassir запущенным как служба")

    @staticmethod
    def check_email_account(account_name):
        """Проверяет существование E-Mail аккаунта

        Args:
            account_name (:obj:`str`): Имя E-Mail аккаунта

        Returns:
             List[:class:`TrObject`]: Список объектов

        Raises:
            ParameterError: Если аккаунт не выбран
            ObjectsNotFoundError: Если аккаунт не найден

        Examples:
            >>> PokaYoke.check_email_account("")
            ParameterError: 'EmailAccount' не выбраны
            >>> PokaYoke.check_email_account("YourAccount")
            ObjectsNotFoundError: Не найдены объекты EmailAccount: YourAccount
            >>> PokaYoke.check_email_account("MyAccount")
            [TrObject('MyAccount')]
        """
        e_accounts = EmailAccounts(BaseUtils.get_server_guid())
        return e_accounts.get_all(account_name)

    @classmethod
    def parse_emails(cls, mailing_list, regex=None):
        """Парсит email дреса из строки и проверяет с помощью regex.

        Args:
            mailing_list (:obj:`str`): Список email адресов, разделенный запятыми
            regex (:obj:`SRE_Pattern`, optional): Новый regex шаблон для проверки.
                По умолчанию :obj:`None`

        Returns:
            List[:obj:`str`]: Список адресов

        Raises:
            ParameterError: Если найден невалидный email

        Examples:
            >>> PokaYoke.parse_emails("a.trubilil!dssl.ru,support@dssl.ru")
            ParameterError: Email 'a.trubilil!dssl.ru' is not valid!
            >>>
            >>> PokaYoke.parse_emails("a.trubilil@dssl.ru,support@dssl.ru")
            ['a.trubilil@dssl.ru', 'support@dssl.ru']
        """
        mailing_list = mailing_list.replace(" ", "")

        if not mailing_list:
            raise ParameterError("No emails to send!")

        if regex is None:
            regex = cls._EMAIL_REGEXP
        else:
            if not isinstance(regex, cls._EMAIL_REGEXP.__class__):
                raise TypeError(
                    "Expected re.compile, got '{}'".format(type(regex).__name__)
                )

        if isinstance(mailing_list, str):
            mailing_list = mailing_list.split(",")

        mailing_list = [mail.strip() for mail in mailing_list]

        for mail in mailing_list:
            if not regex.match(mail):
                raise ParameterError("Email '{}' is not valid!".format(mail))

        return mailing_list

    @classmethod
    def check_phones(cls, phones, regex=None):
        """Проверяет строку на валидность телефонных номеров с помощью regex.

        Args:
            phones (:obj:`str`): Список телефонов, разделенный запятыми или точкой с запятой
            regex (:obj:`SRE_Pattern`, optional): Новый regex шаблон для проверки.
                По умолчанию :obj:`None`

        Returns:
            :obj:`str`: Список номеров телефона

        Raises:
            ParameterError: Если найден невалидный номер телефона

        Examples:
            >>> PokaYoke.check_phones("79999999999,78888888888A")
            ParameterError: Bad chars in phone list: `A`
            >>>
            >>> PokaYoke.check_phones("a.trubilil@dssl.ru,support@dssl.ru")
            '79999999999,78888888888'
        """
        phones = phones.replace(" ", "")

        if not phones:
            raise ParameterError("No phones!")

        if regex is None:
            regex = cls._PHONE_REGEXP
        else:
            if not isinstance(regex, cls._PHONE_REGEXP.__class__):
                raise TypeError(
                    "Expected re.compile, got '{}'".format(type(regex).__name__)
                )
        bad_chars = regex.findall(phones)
        if bad_chars:
            raise ParameterError(
                "Bad chars in phone list: `{}`".format(", ".join(bad_chars))
            )

        return phones

    @classmethod
    def fire_recognizer_events(cls, enable=True, server_guid=None):
        """Проверяет "Режим для СКУД" настроек распознавания лиц.

        По умолчанию проверяет активирован ли "Режим для СКУД"
        на сервере, где запущен скрипт. По желанию можно указать
        удаленный сервер дял проверки.

        Args:
            enable (:obj:`bool`, optional): Состояние параметра. По умолчанию :obj:`True`.
            server_guid (:obj:`str`, optional): Guid сервера. По умолчанию :obj:`None`.

        Raises:
            RuntimeError: Если указанный сервер недоступен.
            EnvironmentError: Если моудль распознавания или режим для СКУД не доступны.
            TrassirError: Если текущее состояние не соотвествует необходимомому.

        Examples:
            >>> PokaYoke.fire_recognizer_events()
            TrassirError: Пожалуйста, активируйте 'Режим для СКУД' в настройках распознавания лиц
        """
        if server_guid is None:
            server_guid = BaseUtils.get_server_guid()

        try:
            srv_sett = host.settings("/%s" % server_guid)
        except KeyError:
            raise RuntimeError("Сервер '%s' не доступен" % server_guid)

        fr_sett = srv_sett.cd("face_recognizer")

        if fr_sett is None:
            raise EnvironmentError(
                "Модуль распознавания лиц не доступен на '%s'"
                % (srv_sett.name or srv_sett.guid)
            )

        try:
            if fr_sett["fire_recognizer_events"] != enable:
                raise TrassirError(
                    "Пожалуйста, {} 'Режим для СКУД' в настройках распознавания лиц".format(
                        "активируйте" if enable else "отключите"
                    )
                )
        except KeyError:
            raise EnvironmentError(
                "'Режим для СКУД' не доступен. Пожалуйста, обновите сервер trassir."
            )


class SoundPlayer(py_object):  # pylint: disable=R0903
    """Класс для проигрывания выбранной мелодии.

    Можно указать один из стандартных зуков или
    указать полный путь до своего файла.

    Note:
        Список стандартных файлов

        .. raw:: html

            <audio controls="controls" style="height: 20px; margin-bottom: -5px;">
              <source src="https://github.com/aatrubilin/trassir_script_framework/raw/master/docs/source/sounds/SNES-startup.wav" type="audio/wav">
              Your browser does not support the <code>audio</code> element.
            </audio>
            <code class="xref py py-obj docutils literal notranslate">
                <span class="pre">"SNES-startup.wav"</span>
            </code>
            <br>
            <audio controls="controls" style="height: 20px; margin-bottom: -5px;">
              <source src="https://github.com/aatrubilin/trassir_script_framework/raw/master/docs/source/sounds/alarm.wav" type="audio/wav">
              Your browser does not support the <code>audio</code> element.
            </audio>
            <code class="xref py py-obj docutils literal notranslate">
                <span class="pre">"alarm.wav"</span>
            </code>
            <br>
            <audio controls="controls" style="height: 20px; margin-bottom: -5px;">
              <source src="https://github.com/aatrubilin/trassir_script_framework/raw/master/docs/source/sounds/bell.wav" type="audio/wav">
              Your browser does not support the <code>audio</code> element.
            </audio>
            <code class="xref py py-obj docutils literal notranslate">
                <span class="pre">"bell.wav"</span>
            </code>
            <br>
            <audio controls="controls" style="height: 20px; margin-bottom: -5px;">
              <source src="https://github.com/aatrubilin/trassir_script_framework/raw/master/docs/source/sounds/boxing-bell-1.wav" type="audio/wav">
              Your browser does not support the <code>audio</code> element.
            </audio>
            <code class="xref py py-obj docutils literal notranslate">
                <span class="pre">"boxing-bell-1.wav"</span>
            </code>
            <br>
            <audio controls="controls" style="height: 20px; margin-bottom: -5px;">
              <source src="https://github.com/aatrubilin/trassir_script_framework/raw/master/docs/source/sounds/boxing-bell-3.wav" type="audio/wav">
              Your browser does not support the <code>audio</code> element.
            </audio>
            <code class="xref py py-obj docutils literal notranslate">
                <span class="pre">"boxing-bell-3.wav"</span>
            </code>
            <br>
            <audio controls="controls" style="height: 20px; margin-bottom: -5px;">
              <source src="https://github.com/aatrubilin/trassir_script_framework/raw/master/docs/source/sounds/cardlock-open.wav" type="audio/wav">
              Your browser does not support the <code>audio</code> element.
            </audio>
            <code class="xref py py-obj docutils literal notranslate">
                <span class="pre">"cardlock-open.wav"</span>
            </code>
            <br>
            <audio controls="controls" style="height: 20px; margin-bottom: -5px;">
              <source src="https://github.com/aatrubilin/trassir_script_framework/raw/master/docs/source/sounds/chime.wav" type="audio/wav">
              Your browser does not support the <code>audio</code> element.
            </audio>
            <code class="xref py py-obj docutils literal notranslate">
                <span class="pre">"chime.wav"</span>
            </code>
            <br>
            <audio controls="controls" style="height: 20px; margin-bottom: -5px;">
              <source src="https://github.com/aatrubilin/trassir_script_framework/raw/master/docs/source/sounds/chip001.wav" type="audio/wav">
              Your browser does not support the <code>audio</code> element.
            </audio>
            <code class="xref py py-obj docutils literal notranslate">
                <span class="pre">"chip001.wav"</span>
            </code>
            <br>
            <audio controls="controls" style="height: 20px; margin-bottom: -5px;">
              <source src="https://github.com/aatrubilin/trassir_script_framework/raw/master/docs/source/sounds/chip019.wav" type="audio/wav">
              Your browser does not support the <code>audio</code> element.
            </audio>
            <code class="xref py py-obj docutils literal notranslate">
                <span class="pre">"chip019.wav"</span>
            </code>
            <br>
            <audio controls="controls" style="height: 20px; margin-bottom: -5px;">
              <source src="https://github.com/aatrubilin/trassir_script_framework/raw/master/docs/source/sounds/chip069.wav" type="audio/wav">
              Your browser does not support the <code>audio</code> element.
            </audio>
            <code class="xref py py-obj docutils literal notranslate">
                <span class="pre">"chip069.wav"</span>
            </code>
            <br>
            <audio controls="controls" style="height: 20px; margin-bottom: -5px;">
              <source src="https://github.com/aatrubilin/trassir_script_framework/raw/master/docs/source/sounds/cordless-phone-ring.wav" type="audio/wav">
              Your browser does not support the <code>audio</code> element.
            </audio>
            <code class="xref py py-obj docutils literal notranslate">
                <span class="pre">"cordless-phone-ring.wav"</span>
            </code>
            <br>
            <audio controls="controls" style="height: 20px; margin-bottom: -5px;">
              <source src="https://github.com/aatrubilin/trassir_script_framework/raw/master/docs/source/sounds/countdown.wav" type="audio/wav">
              Your browser does not support the <code>audio</code> element.
            </audio>
            <code class="xref py py-obj docutils literal notranslate">
                <span class="pre">"countdown.wav"</span>
            </code>
            <br>
            <audio controls="controls" style="height: 20px; margin-bottom: -5px;">
              <source src="https://github.com/aatrubilin/trassir_script_framework/raw/master/docs/source/sounds/dialtone.wav" type="audio/wav">
              Your browser does not support the <code>audio</code> element.
            </audio>
            <code class="xref py py-obj docutils literal notranslate">
                <span class="pre">"dialtone.wav"</span>
            </code>
            <br>
            <audio controls="controls" style="height: 20px; margin-bottom: -5px;">
              <source src="https://github.com/aatrubilin/trassir_script_framework/raw/master/docs/source/sounds/ding.wav" type="audio/wav">
              Your browser does not support the <code>audio</code> element.
            </audio>
            <code class="xref py py-obj docutils literal notranslate">
                <span class="pre">"ding.wav"</span>
            </code>
            <br>
            <audio controls="controls" style="height: 20px; margin-bottom: -5px;">
              <source src="https://github.com/aatrubilin/trassir_script_framework/raw/master/docs/source/sounds/horn-beep.wav" type="audio/wav">
              Your browser does not support the <code>audio</code> element.
            </audio>
            <code class="xref py py-obj docutils literal notranslate">
                <span class="pre">"horn-beep.wav"</span>
            </code>
            <br>
            <audio controls="controls" style="height: 20px; margin-bottom: -5px;">
              <source src="https://github.com/aatrubilin/trassir_script_framework/raw/master/docs/source/sounds/phone-beep.wav" type="audio/wav">
              Your browser does not support the <code>audio</code> element.
            </audio>
            <code class="xref py py-obj docutils literal notranslate">
                <span class="pre">"phone-beep.wav"</span>
            </code>
            <br>
            <audio controls="controls" style="height: 20px; margin-bottom: -5px;">
              <source src="https://github.com/aatrubilin/trassir_script_framework/raw/master/docs/source/sounds/police2.wav" type="audio/wav">
              Your browser does not support the <code>audio</code> element.
            </audio>
            <code class="xref py py-obj docutils literal notranslate">
                <span class="pre">"police2.wav"</span>
            </code>
            <br>
            <audio controls="controls" style="height: 20px; margin-bottom: -5px;">
              <source src="https://github.com/aatrubilin/trassir_script_framework/raw/master/docs/source/sounds/ship-on-fog.wav" type="audio/wav">
              Your browser does not support the <code>audio</code> element.
            </audio>
            <code class="xref py py-obj docutils literal notranslate">
                <span class="pre">"ship-on-fog.wav"</span>
            </code>
            <br>
            <audio controls="controls" style="height: 20px; margin-bottom: -5px;">
              <source src="https://github.com/aatrubilin/trassir_script_framework/raw/master/docs/source/sounds/ships-bell.wav" type="audio/wav">
              Your browser does not support the <code>audio</code> element.
            </audio>
            <code class="xref py py-obj docutils literal notranslate">
                <span class="pre">"ships-bell.wav"</span>
            </code>
            <br>
            <audio controls="controls" style="height: 20px; margin-bottom: -5px;">
              <source src="https://github.com/aatrubilin/trassir_script_framework/raw/master/docs/source/sounds/spin-up.wav" type="audio/wav">
              Your browser does not support the <code>audio</code> element.
            </audio>
            <code class="xref py py-obj docutils literal notranslate">
                <span class="pre">"spin-up.wav"</span>
            </code>
            <br>
            <audio controls="controls" style="height: 20px; margin-bottom: -5px;">
              <source src="https://github.com/aatrubilin/trassir_script_framework/raw/master/docs/source/sounds/tada1.wav" type="audio/wav">
              Your browser does not support the <code>audio</code> element.
            </audio>
            <code class="xref py py-obj docutils literal notranslate">
                <span class="pre">"tada1.wav"</span>
            </code>
            <br>
            <audio controls="controls" style="height: 20px; margin-bottom: -5px;">
              <source src="https://github.com/aatrubilin/trassir_script_framework/raw/master/docs/source/sounds/tape-slow9.wav" type="audio/wav">
              Your browser does not support the <code>audio</code> element.
            </audio>
            <code class="xref py py-obj docutils literal notranslate">
                <span class="pre">"tape-slow9.wav"</span>
            </code>
            <br>

    Args:
        sound_file (:obj:`str`): Имя файла с расширением
    """

    _DEFAULT_SOUNDS = {
        "SNES-startup.wav",
        "alarm.wav",
        "bell.wav",
        "boxing-bell-1.wav",
        "boxing-bell-3.wav",
        "cardlock-open.wav",
        "chime.wav",
        "chip001.wav",
        "chip019.wav",
        "chip069.wav",
        "cordless-phone-ring.wav",
        "countdown.wav",
        "dialtone.wav",
        "ding.wav",
        "horn-beep.wav",
        "phone-beep.wav",
        "police2.wav",
        "ship-on-fog.wav",
        "ships-bell.wav",
        "spin-up.wav",
        "tada1.wav",
        "tape-slow9.wav",
    }

    def __init__(self, sound_file):
        self._play = self._get_player(sound_file)

    def _check_file(self, sound_file):
        _, ext = os.path.splitext(sound_file)

        if ext.lower() != ".wav":
            raise RuntimeError("Expected *.wav file, got {!r}".format(ext))

        if sound_file in self._DEFAULT_SOUNDS:
            if os.name == "nt":
                base_path = "sounds"
            else:
                base_path = "/opt/trassir/tech1/sounds"

            sound_file = os.path.join(base_path, sound_file)

        if not os.path.isfile(sound_file):
            raise IOError("File {} not found".format(sound_file))

        return sound_file

    def _get_player(self, sound_file):
        sound_file = self._check_file(sound_file)

        if os.name == "nt":

            def player():
                winsound.PlaySound(
                    sound_file,
                    winsound.SND_FILENAME | winsound.SND_ASYNC | winsound.SND_NOWAIT,
                )

        else:

            def player():
                os.system('aplay -D "sysdefault:CARD=PCH" %s &' % sound_file)

        return player

    def play(self):
        """Проигрывает выбранный файл

        Examples:
            >>> player = SoundPlayer("alarm.wav")
            >>> player.play()
        """
        self._play()


class SenderError(Exception):
    """Base Sender Exception"""

    pass


class Sender(py_object):
    _HTML_IMG_TEMPLATE = """<img src="data:image/png;base64,{img}" {attr}>"""

    def __init__(self):
        pass

    @staticmethod
    def _get_base64(image_path):
        """Returns base64 image

        Args:
            image_path (str): Image full path
        """
        base64_image = ""
        image_path = BaseUtils.win_encode_path(image_path)
        if os.path.isfile(image_path):
            with open(image_path, "rb") as image_file:
                base64_image = base64.b64encode(image_file.read())

        return base64_image

    @staticmethod
    def _get_html_img(image_base64, **kwargs):
        """Returns html img

        Args:
            image_base64 (str): Base64 image
        """
        return BaseUtils.base64_to_html_img(image_base64, **kwargs)

    def text(self, text, **kwargs):
        """Send text

        Args:
            text (str): Text message
        """
        pass

    def image(self, image_path, text="", **kwargs):
        """Send image and optional text

        Args:
            image_path (str | List[str]): Image path or paths
            text (str, optional): Text message; default: ""
        """
        pass

    def files(self, file_paths, text="", **kwargs):
        """Send file or list of files

        Args:
            file_paths (str | List[str]): File path or list of paths
            text (str, optional): Text message; default: ""
        """
        pass


class PopupSender(Sender):
    """Класс для показа всплывающих окон в правом нижнем углу экрана

    Args:
        width (:obj:`int`, optional): Ширина изображения, px.
            По умолчанию :obj:`width=400`

    Examples:
        >>> sender = PopupSender(300)
        >>> sender.text("Hello World!")

            .. image:: images/popup_sender.text.png

        >>> sender.image(r"manual/en/cloud-devices-16.png")

            .. image:: images/popup_sender.image.png
    """

    def __init__(self, width=400):
        super(PopupSender, self).__init__()
        self._attr = {"width": width}

    def text(self, text, popup_type="message", **kwargs):  # pylint: disable=W0221
        """Показывает текст во всплывающем окне

        Вызывает один из методов Trassir :obj:`host_ip.alert`,
        :obj:`host_ip.message` или :obj:`host_ip.error` с текстом

        Args:
            text (:obj:`str`): Текст сообщения
            popup_type (:obj:`"message"` | :obj:`"alert"` | :obj:`"error"`, optional)
                Тип сообщения. По умолчанию :obj:`"message"`
        """

        if popup_type == "alert":
            host.alert(text)
        elif popup_type == "error":
            host.error(text)
        else:
            host.message(text)

    def image(
        self, image_path, text="", popup_type=None, **kwargs
    ):  # pylint: disable=W0221
        """Показывает изображение во всплывающем окне

        Args:
            image_path (:obj:`str` | :obj:`List[str]`): Полный путь до изображения
                или список путей.
            text (:obj:`str`, optional): Текст сообщения. По умолчанию :obj:`""`
            popup_type (:obj:`"message"` | :obj:`"alert"` | :obj:`"error"`, optional)
                Тип сообщения. По умолчанию :obj:`"message"`
        """
        if not isinstance(image_path, list):
            image_path = [image_path]

        images_base64 = [self._get_base64(img_path) for img_path in image_path]

        for image_base64, img_path in zip(images_base64, image_path):
            if not image_base64:
                self.text("<b>File not found</b><br>{}".format(img_path), popup_type)
                return

            html_image = BaseUtils.base64_to_html_img(image_base64, **self._attr)

            html = "{image}"
            if text:
                html = "<b>{text}</b><br>{image}"

            self.text(html.format(text=text, image=html_image), popup_type)


class PopupWithBtnSender(Sender):
    """Класс для показа всплывающих окон с кнопкой `Оk`

    Note:
        | Для закрытия окна необходимо нажать кнопку `Ok` в течении 60 сек.
        | После 60 сек окно закрывается автоматически.

    Args:
        width (:obj:`int`, optional): Ширина изображения, px.
            По умолчанию :obj:`width=800`

    Examples:
        >>> sender = PopupWithBtnSender()
        >>> sender.text("Hello World!")

            .. image:: images/popup_with_btn_sender.text.png

        >>> sender.image(r"manual/en/cloud-devices-16.png")

            .. image:: images/popup_with_btn_sender.image.png
    """

    def __init__(self, width=800):
        super(PopupWithBtnSender, self).__init__()
        self._attr = {"width": width}

    def text(self, text, **kwargs):
        """Показывает текст во всплывающем окне

        Вызывает метод Trassir :obj:`host_ip.question` с текстом

        Args:
            text (:obj:`str`): Текст сообщения
        """
        host.question("<pre>{}</pre>".format(text), "Ok", BaseUtils.do_nothing)

    def image(self, image_path, text="", **kwargs):
        """Показывает изображение во всплывающем окне

        Args:
            image_path (:obj:`str` | :obj:`List[str]`): Полный путь до изображения
                или список путей.
            text (:obj:`str`, optional): Текст сообщения. По умолчанию :obj:`""`
        """
        if not isinstance(image_path, list):
            image_path = [image_path]

        images_base64 = [self._get_base64(img_path) for img_path in image_path]

        for image_base64, img_path in zip(images_base64, image_path):
            if not image_base64:
                self.text("<b>File not found</b><br>{}".format(image_path))
                return

            html_image = BaseUtils.base64_to_html_img(image_base64, **self._attr)

            html = "{image}"
            if text:
                html = "<b>{text}</b><br>{image}"

            self.text(html.format(text=text, image=html_image))


class EmailSender(Sender):
    """Класс для отправки уведомлений, изображений и файлов на почту

    Note:
        По умолчанию тема сообщений соответствует шаблону
        ``{server_name} -> {script_name}``

    Tip:
        При отправке изображения с текстом предпочтительней использовать метод
        :meth:`EmailSender.image` с необязательным аргументом :obj:`text` чем
        :meth:`EmailSender.text` с необазательным аргументом :obj:`attachments`

    Args:
        account (:obj:`str`): E-Mail аккаунт trassir. Проверяется
            методом :meth:`PokaYoke.check_email_account`
        mailing_list (:obj:`str`): Список email адресов для отправки писем
            разделенный запятыми. Проверяется и парсится в список методом
            :meth:`PokaYoke.parse_emails`
        subject (:obj:`str`, optional): Общая тема для сообщений.
            По умолчанию :obj:`None`
        max_size (:obj:`int`, optional): Максимальный размер вложения, байт.
            По умолчанию 25 * 1024 * 1024

    Examples:
        >>> sender = EmailSender("MyAccount", "my_mail@google.com")
        >>> sender.text("Hello World!")

            .. image:: images/email_sender.text.png

        >>> sender.image(r"manual/en/cloud-devices-16.png")

            .. image:: images/email_sender.image.png

        >>> sender.files([r"manual/en/cloud.html", r"manual/en/cloud.png"])

            .. image:: images/email_sender.files.png
    """

    def __init__(self, account, mailing_list, subject=None, max_size=None):
        super(EmailSender, self).__init__()

        PokaYoke.check_email_account(account)

        self.max_size = max_size or 25 * 1024 * 1024

        self._account = account
        self._mailing_list = PokaYoke.parse_emails(mailing_list)

        self._subject_default = subject or self._generate_subject()

        logger.info(
            "EmailSender(%s, %s, subject=%s, max_size=%s)",
            repr(account),
            repr(mailing_list),
            repr(self._subject_default),
            repr(self.max_size),
        )

    @staticmethod
    def _generate_subject():
        """Returns `server name` -> `script name`"""
        subject = "{server_name} -> {script_name}".format(
            server_name=host.settings("").name or "Client",
            script_name=host.stats().parent().name,
        )
        return subject

    def _group_files_by_max_size(self, file_paths, max_size):
        """Split files to groups. Size of each group is less then max_size

        Args:
            file_paths (list): List of files
            max_size (int): Max group size, bytes
        """
        group = []
        cur_size = 0
        for idx, file_path in enumerate(file_paths):
            file_size = os.stat(BaseUtils.win_encode_path(file_path)).st_size
            if not cur_size or (cur_size + file_size) < max_size:
                cur_size += file_size
                group.append(file_path)
            else:
                break
        else:
            return [group]

        return [group] + self._group_files_by_max_size(
            file_paths[idx:], max_size  # pylint: disable=W0631
        )

    def text(
        self, text, subject=None, attachments=None, **kwargs
    ):  # pylint: disable=W0221
        """Отправка текстового сообщения

        Args:
            text (:obj:`str`): Текст сообщения
            subject (:obj:`str`, optional): Новая тема сообщения.
                По умолчанию :obj:`None`
            attachments (:obj:`list`, optional): Список вложений.
                По умолчанию :obj:`None`
        """
        if attachments is None:
            attachments = []
        host.send_mail_from_account(
            self._account,
            self._mailing_list,
            subject or self._subject_default,
            text,
            attachments,
        )

    def image(
        self, image_path, text="", subject=None, **kwargs
    ):  # pylint: disable=W0221
        """Отправка изображения

        Args:
            image_path (:obj:`str` | :obj:`List[str]`): Полный путь до изображения
                или список путей.
            text (:obj:`str`, optional): Текст сообщения.
                По умолчанию :obj:`""`
            subject (:obj:`str`, optional): Новая тема сообщения.
                По умолчанию :obj:`None`
        """
        if not isinstance(image_path, list):
            image_path = [image_path]
        self.files(image_path, text=text, subject=subject)

    def files(
        self, file_paths, text="", subject=None, callback=None, **kwargs
    ):  # pylint: disable=W0221
        """Отправка файлов

        Note:
            Если отправляется несколько файлов они могут быть разделены на
            несколько сообщений, основываясь на максимальном размере вложений.

        Args:
            file_paths (:obj:`str` | :obj:`list`): Путь до файла или список
                файлов для отправки
            text (:obj:`str`, optional): Текст сообщения.
                По умолчанию :obj:`""`
            subject (:obj:`str`, optional): Новая тема сообщения.
                По умолчанию :obj:`None`
            callback (:obj:`function`, optional): Функция, которая вызывается после
                отправки частей
        """
        logger.debug("EmailSender.files(%s, text=%s)", repr(file_paths), repr(text))
        if isinstance(file_paths, str):
            file_paths = [file_paths]

        if callback is None:
            callback = BaseUtils.do_nothing

        files_to_send = []
        for path in file_paths:
            if BaseUtils.is_file_exists(path):
                files_to_send.append(path)
            else:
                text += "\nFile not found: {}".format(path)

        file_groups = self._group_files_by_max_size(files_to_send, self.max_size)

        for grouped_files in file_groups:
            logger.debug("EmailSender.files: grouped_files: %s", repr(grouped_files))
            self.text(text, subject=subject, attachments=grouped_files)
            callback(grouped_files)


class TelegramSender(Sender):
    """Работа с телеграм ботом `@trassirbot <https://t.me/trassirbot>`_

    Warnings:
        | Cкрипт должен быть запущен на **сервере** Trassir.
        | На Клиенте скрипт вызовет ошибку ``ServerKeyError``

    Args:
        telegram_ids (:obj:`str`): Id пользователей, через запятую.

    Examples:
        >>> # Можно указать id для рассылки при инициализации
        >>> # класса, для всех уведомлений
        >>> sender = TelegramSender("123456789")
        >>> sender.text("Hello World!")

            .. image:: images/telegram_sender.text.png

        >>> sender.image(r"manual/en/cloud-devices-16.png")

            .. image:: images/telegram_sender.image.png

        >>> sender.files([r"manual/en/cloud.html", r"manual/en/cloud.png"])

            .. image:: images/telegram_sender.files.png

        >>> # Или можно опередовать telegram id при вызове методов
        >>> sender = TelegramSender()
        >>> sender.text("Hello World!", tg_users=[123456789])

            .. image:: images/telegram_sender.text.png

        >>> sender.image(r"manual/en/cloud-devices-16.png", tg_users=[123456789])

            .. image:: images/telegram_sender.image.png

        >>> sender.files([r"manual/en/cloud.html", r"manual/en/cloud.png"], tg_users=[123456789])

            .. image:: images/telegram_sender.files.png
    """

    def __init__(self, telegram_ids=None):
        super(TelegramSender, self).__init__()
        host.exec_encoded(_TBOT_SERVICE)
        self._tbot_api = TBotAPI()  # pylint: disable=E0602
        if telegram_ids is not None:
            self.telegram_ids = TBotAPI.prepare_users(  # pylint: disable=E0602
                telegram_ids
            )
        else:
            self.telegram_ids = None

    def text(self, text, tg_users=None, **kwargs):  # pylint: disable=W0221
        """Отправка текстового сообщения

        Args:
            text (:obj:`str`): Текст сообщения.
            tg_users (List[:obj:`int`], optional): Список id пользователей
                telegram для отправки отдельных сообщений. По умолчанию :obj:`None`
        """
        if tg_users is None:
            tg_users = self.telegram_ids

        self._tbot_api.send_message(tg_users, text)

    def image(
        self, image_path, text="", tg_users=None, remove=False, **kwargs
    ):  # pylint: disable=W0221
        """Отправка изображения

        Args:
            image_path (:obj:`str` | List[:obj:`str`]): Полный путь до изображения или
                список путей
            text (:obj:`str`, optional): Текст сообщения.
                По умолчанию :obj:`""`
            tg_users (List[:obj:`int`], optional): Список id пользователей
                telegram для отправки отдельных сообщений. По умолчанию :obj:`None`
            remove (bool, optional): Удалить файл после отправки или нет. По умолчанию :obj:`False`
        """
        if tg_users is None:
            tg_users = self.telegram_ids

        if len(text) > 150:
            self.text(text, tg_users=tg_users)
            text = None

        if isinstance(image_path, list):
            self._tbot_api.send_image_album(
                tg_users, image_path, captions=[text] or None, remove=remove
            )

        else:
            if not os.path.isfile(image_path):
                self.text("Image not found: {}".format(image_path))
                return

            self._tbot_api.send_image(tg_users, image_path, caption=text, remove=remove)

    def files(
        self, file_paths, text="", tg_users=None, remove=False, **kwargs
    ):  # pylint: disable=W0221
        """Отправка файлов

        Args:
            file_paths (:obj:`str` | :obj:`list`): Путь до файла или список
                файлов для отправки
            text (:obj:`str`, optional): Текст сообщения.
                По умолчанию :obj:`""`
            tg_users (List[:obj:`int`], optional): Список id пользователей
                telegram для отправки отдельных сообщений. По умолчанию :obj:`None`
            remove (bool, optional): Удалить файл после отправки или нет. По умолчанию :obj:`False`
        """

        if tg_users is None:
            tg_users = self.telegram_ids

        if isinstance(file_paths, str):
            file_paths = [file_paths]

        if text and len(file_paths) == 1:
            self.text(text, tg_users=tg_users)
            text = ""

        files_not_found_text = ""
        for path in file_paths:
            if os.path.isfile(BaseUtils.win_encode_path(path)):
                self._tbot_api.send_document(
                    tg_users, path, caption=text, remove=remove
                )
            else:
                files_not_found_text += "\nFile not found: {}".format(path)

        if files_not_found_text:
            self.text(files_not_found_text, tg_users=tg_users)


class SMSCSenderError(SenderError):
    """Raises with SMSCSender errors"""

    pass


class SMSCSender(Sender):
    """Класс для отправки сообщений с помощью сервиса smsc.ru

    See Also:
        `https://smsc.ru/api/http/ <https://smsc.ru/api/http/>`_

    Note:
        | Номера проверяются методом
          :meth:`PokaYoke.check_phones`
        | Также при первом запуске скрипт проверяет данные авторизации

    Warnings:
        | По умолчанию сервис smsc.ru отправляет сообщения от своего имени *SMSC.RU.*
          При этом отправка на номера Мегафон/Йота **недоступна** т.к. имя *SMSC.RU*
          заблокировано оператором.
        |
        | Мы настоятельно **НЕ** рекомендуем использовать стандартное имя *SMSC.RU.*
        |
        | Для отправки смс от вашего буквенного имени необходимо его
          создать в разделе - https://smsc.ru/senders/ и зарегистрировать для
          операторов в колонке Действия по кнопке Изменить (после заключения договора
          согласно инструкции - https://smsc.ru/contract/info/ ) а также приложить
          гарантийное письмо на МТС в личный кабинет http://smsc.ru/documents/ и
          отправить на почту inna@smsc.ru

    Args:
        login (:obj:`str`): SMSC Логин
        password (:obj:`str`): SMSC Пароль
        phones (:obj:`str`): Список номеров для отправки смс резделенный
            запятыми или точкой с запятой
        translit(:obj:`bool`, optional): Переводить сообщение в
            транслит. По умолчанию :obj:`True`

    Raises:
        SMSCSenderError: При любых ошибках с отправкой сообщения

    Examples:
        >>> sender = SMSCSender("login", "password", "79999999999")
        >>> sender.text("Hello World!")

            .. image:: images/smsc_sender.text.png
    """

    _BASE_URL = "https://smsc.ru/sys/send.php?{params}"
    _ERROR_CODES = {
        1: "URL Params error",
        2: "Invalid login or password",
        3: "Not enough money",
        4: "Your IP is temporary blocked. More info: https://smsc.ru/faq/99",
        5: "Bad date format",
        6: "Message is denied (by text or sender name)",
        7: "Bad phone format",
        8: "Can't send message to this number",
        9: "Too many requests",
    }

    def __init__(self, login, password, phones, translit=True):
        super(SMSCSender, self).__init__()
        if not login:
            raise SMSCSenderError("Empty login")
        if not password:
            raise SMSCSenderError("Empty password")

        self._params = {
            "login": urllib.quote(login),  # Login
            "psw": urllib.quote(password),  # Password or MD5 hash
            "phones": urllib.quote(
                PokaYoke.check_phones(phones)
            ),  # Comma or semicolon spaced phone list
            "fmt": 3,  # Response format: 0 - string; 1 - integers; 2 - xml; 3 - json
            "translit": 1 if translit else 0,  # If 1 - transliting message
            "charset": "utf-8",  # Message charset: "windows-1251"|"utf-8"|"koi8-r"
            "cost": 3,  # Message cost in response: 0 - msg; 1 - cost; 2 - msg+cost, 3 - msg+cost+balance
        }

        self._check_account()

    def _get_link(self, **kwargs):
        """Returns get link"""
        params = self._params.copy()
        params.update(kwargs)
        url = self._BASE_URL.format(params=urllib.urlencode(params))

        return url

    def _request_callback(self, code, result, error):
        """Callback for async_get"""
        if code != 200:
            raise SMSCSenderError("RequestError [{}]: {}".format(code, error))
        else:
            try:
                data = json.loads(result)
            except ValueError:
                data = {"error_code": 0, "error": "JSON loads error: {}".format(result)}

            error_code = data.get("error_code")
            if error_code is not None:
                error = self._ERROR_CODES.get(error_code)
                if not error:
                    error = data.get("error", "Unknown error")
                raise SMSCSenderError(
                    "ResponseError [{}]: {}".format(error_code, error)
                )

    def _check_account(self):
        """Send test request to smsc server"""
        url = self._get_link(cost=1, mes=urllib.quote("Hello world!"))
        host.async_get(url, self._request_callback)

    def text(self, text, **kwargs):
        """Отправка текстового сообщения

        Args:
            text (:obj:`str`): Текст сообщения.
        """

        url = self._get_link(mes=text)

        host.async_get(url, self._request_callback)


class FtpUploadTracker:  # pylint: disable=R0903,C1001
    """Upload progress class"""

    size_written = 0.0
    last_shown_percent = 0

    def __init__(self, file_path, callback):
        self.total_size = os.path.getsize(BaseUtils.win_encode_path(file_path))
        self.file_path = file_path
        self.callback = callback

    # noinspection PyUnusedLocal
    def handle(self, *args):  # pylint: disable=W0613,C1001
        """Handler for storbinary

        See Also:
            https://docs.python.org/2/library/ftplib.html#ftplib.FTP.storbinary
        """
        self.size_written += 1024.0
        percent_complete = round((self.size_written / self.total_size) * 100)

        if self.last_shown_percent != percent_complete:
            self.last_shown_percent = percent_complete
            host.timeout(
                100, lambda: self.callback(self.file_path, int(percent_complete), "")
            )


class FTPSenderError(SenderError):
    """Raises with FTPSender errors"""

    pass


class FTPSender(Sender):  # pylint: disable=R0902
    """Класс для отправки файлов на ftp сервер

    При инициализации проверят подключение к ftp серверу. Файлы отправляет
    по очереди. Максимальный размер очереди можно изменить. Во время
    выполнения передает текущий прогресс отправки файла в callback функцию.

    Note:
        Помимо прогресса в функцию callback может вернуться код ошибки.
            - -1 Файл не существует.
            - -2 Ошибка отправки на ftp, файл будет повторно отправлен.
            - -3 Неизвестная ошибка.


    Args:
        host_ip (:obj:`str`): Адрес ftp сервера.
        port (:obj:`int`, optional): Порт ftp сервера. По умолчанию :obj:`port=21`
        user (:obj:`str`, optional): Имя пользователя. По умолчанию :obj:`"anonymous"`
        passwd (:obj:`str`, optional): Пароль пользователя. По умолчанию :obj:`passwd=""`
        work_dir (:obj:`str`, optional): Директория на сервре для сохранения файлов.
            По умолчанию :obj:`None`
        callback (:obj:`function`, optional): Callable function. По умолчанию :obj:`None`
        queue_maxlen (:obj:`int`, optional): Максимальная длина очереди на отправку.
            По умолчанию :obj:`queue_maxlen=1000`

    Examples:
        >>> # noinspection PyUnresolvedReferences
        >>> def callback(file_path, progress, error):
        ...     # Пример callback функции, которая отображает
        ...     # текущий прогресс в счетчике запуска скрипта
        ...     # Args:
        ...     #   file_path (str): Путь до файла
        ...     #   progress (int): Текущий прогресс передачи файла, %
        ...     #   error (str | Exception): Ошибка при отправке файла, если есть
        ...     host.stats()["run_count"] = progress
        ...     if error:
        ...         host.error(error)
        ...
        ...     if progress == 100:
        ...         host.timeout(3000, lambda: os.remove(BaseUtils.win_encode_path(file_path)))
        >>>
        >>> sender = FTPSender("172.20.0.10", 21, "trassir", "12345", work_dir="/test_dir/", callback=callback)
        >>> sender.files(r"D:/Shots/export_video.avi")
    """

    # noinspection SpellCheckingInspection,PyShadowingNames
    def __init__(  # pylint: disable=R0913
        self,
        host_ip,
        port=21,
        user="anonymous",
        passwd="",
        work_dir=None,
        callback=None,
        queue_maxlen=1000,
    ):
        super(FTPSender, self).__init__()
        self._host = host_ip
        self._port = port
        self._user = user
        self._passwd = passwd
        self._work_dir = work_dir

        self.queue = deque(maxlen=queue_maxlen)

        self._ftp = None

        if callback is None:
            callback = BaseUtils.do_nothing

        self.callback = callback

        self._work_now = False

        self._check_connection()

    def _check_connection(self):
        """Check if it possible to connect"""
        try:
            ftp = ftplib.FTP()
            ftp.connect(self._host, self._port, timeout=10)
            ftp.login(self._user, self._passwd)
        except ftplib.all_errors as err:
            raise FTPSenderError(err)
        if self._work_dir:
            try:
                ftp.cwd(self._work_dir)
            except ftplib.error_perm:
                ftp.mkd(self._work_dir)
                ftp.cwd(self._work_dir)

        ftp.quit()

    def _get_connection(self):
        """Connecting to ftp

        Returns:
            ftplib.FTP: Ftp object
        """
        try:
            ftp = ftplib.FTP()
            ftp.connect(self._host, self._port, timeout=10)
            ftp.login(self._user, self._passwd)
            if self._work_dir:
                try:
                    ftp.cwd(self._work_dir)
                except ftplib.error_perm:
                    ftp.mkd(self._work_dir)
                    ftp.cwd(self._work_dir)
            ftp.encoding = "utf-8"
            return ftp
        except ftplib.all_errors:
            pass

    def _close_connection(self):
        """Close ftp connection"""
        try:
            if self._ftp is not None:
                self._ftp.close()
        finally:
            self._ftp = None

    def _send_file(self, file_path, work_dir=None):
        """Storbinary file with self.ftp

        Args:
            file_path (str): Full file path
            work_dir (str): Work dir on ftp
        """
        if work_dir is not None:
            if self._work_dir:
                work_dir = os.path.normpath("{}/{}".format(self._work_dir, work_dir))
            try:
                self._ftp.cwd(work_dir)
            except ftplib.error_perm:
                self._ftp.mkd(work_dir)
                self._ftp.cwd(work_dir)

        file_name = os.path.basename(file_path)
        upload_tracker = FtpUploadTracker(file_path, self.callback)
        with open(BaseUtils.win_encode_path(file_path), "rb") as opened_file:
            self._ftp.storbinary(
                "STOR " + file_name, opened_file, 1024, upload_tracker.handle
            )

    @BaseUtils.run_as_thread
    def _sender(self):
        """Send files in queue"""
        if self.queue:
            if self._ftp is None:
                self._ftp = self._get_connection()

            if self._ftp:
                work_dir = None
                file_path = self.queue.popleft()

                if isinstance(file_path, tuple):
                    file_path, work_dir = file_path

                if BaseUtils.is_file_exists(BaseUtils.win_encode_path(file_path)):
                    try:
                        self._send_file(file_path, work_dir)

                    except ftplib.all_errors as err:
                        host.timeout(
                            100, lambda: self.callback(file_path, -2, error=err)
                        )
                        self.queue.append(file_path)
                        self._close_connection()

                    except Exception as err:  # pylint: disable=W0703
                        host.timeout(
                            100, lambda: self.callback(file_path, -3, error=err)
                        )

                else:
                    host.timeout(
                        100,
                        lambda: self.callback(file_path, -1, error="File not found"),
                    )

            host.timeout(500, self._sender)
        else:
            self._work_now = False
            self._close_connection()

    def files(self, file_paths, *args, **kwargs):  # pylint: disable=W0221,W0613,
        """Отправка файлов

        Note:
            Можно указать отдельный путь на ftp сервере для каждого файла.
            Для этого список файлов на отправку должен быть приведен к виду
            ``[(shot_path, ftp_path), ...]`` При этом так же будет учитываться
            глобальная папка :obj:`work_dir` заданная при инициализации класса.

        Args:
            file_paths (:obj:`str` | :obj:`list`): Путь до файла или список
                файлов для отправки
        """
        if not isinstance(file_paths, list):
            file_paths = [file_paths]

        self.queue.extend(file_paths)
        if not self._work_now:
            self._work_now = True
            self._sender()
