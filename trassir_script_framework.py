# -*- coding: utf-8 -*-
"""
<parameters>
    <company>AATrubilin</company>
    <title>trassir_script_framework</title>
    <version>0.6</version>
</parameters>
"""

# _SERVICE_VERSION = 0.62
tbot_service = """
    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
    pMFpe23kgpGocZbm5gk=
"""

import re
import os
import sys
import ssl
import time
import host
import json

import pickle
import base64
import ftplib
import urllib
import urllib2
import httplib
import logging
import threading
import subprocess

from Queue import Queue
from functools import wraps
from collections import deque
from xml.etree import ElementTree
from datetime import datetime, date, timedelta
from __builtin__ import object as py_object


"""import for tbot_service"""
# noinspection PyUnresolvedReferences
import mimetools, mimetypes, itertools

logger = logging.getLogger()


class ScriptError(Exception):
    """Base script exception"""

    pass


class HostLogHandler(logging.Handler):
    """ Trassir main log handler """

    def __init__(self, host_api=host):
        super(HostLogHandler, self).__init__()
        self._host_api = host_api

    def emit(self, record):
        msg = self.format(record)
        self._host_api.log_message(msg)


class PopupHandler(logging.Handler):
    """ Trassir popup handler """

    def __init__(self, host_api=host):
        super(PopupHandler, self).__init__()
        self._host_api = host_api
        self._popups = {
            "CRITICAL": host_api.error,
            "FATAL": host_api.error,
            "ERROR": host_api.error,
            "WARN": host_api.alert,
            "WARNING": host_api.alert,
            "INFO": host_api.message,
            "DEBUG": host_api.message,
            "NOTSET": host_api.message,
        }

    def emit(self, record):
        msg = self.format(record)
        popup = self._popups.get(record.levelname, self._host_api.message)
        popup(msg)


class MyFileHandler(logging.Handler):
    """ My file handler """

    def __init__(self, file_path, max_mbytes=10240):
        super(MyFileHandler, self).__init__()
        self._file_path = file_path
        self._max_mbytes = max_mbytes * 1024

    def _check_size(self):
        if not os.path.isfile(self._file_path):
            return
        if os.stat(self._file_path).st_size > self._max_mbytes:
            old_file_path = self._file_path + ".old"
            if os.path.isfile(old_file_path):
                os.remove(old_file_path)
            os.rename(self._file_path, old_file_path)

    def emit(self, record):
        self._check_size()
        msg = self.format(record)
        with open(self._file_path, "a") as log_file:
            log_file.write(msg + "\n")


class BaseUtils:
    """Base utils for your scripts"""

    _host_api = host
    _FOLDERS = {obj[1]: obj[3] for obj in host.objects_list("Folder")}
    _TEXT_FILE_EXTENSIONS = [".txt", ".csv", ".log"]
    _LPR_FLAG_BITS = {
        "LPR_UP": 0x00001,
        "LPR_DOWN": 0x00002,
        "LPR_BLACKLIST": 0x00004,
        "LPR_WHITELIST": 0x00008,
        "LPR_INFO": 0x00010,
        "LPR_FIRST_LANE": 0x01000,
        "LPR_SECOND_LANE": 0x02000,
        "LPR_THIRD_LANE": 0x04000,
        "LPR_EXT_DB_ERROR": 0x00020,
        "LPR_CORRECTED": 0x00040,
    }
    _IMAGE_EXT = [".png", ".jpg", ".jpeg", ".bmp"]
    _HTML_IMG_TEMPLATE = """<img src="data:image/png;base64,{img}" {attr}>"""

    _SCR_DEFAULT_NAMES = [
        "Yeni skript",
        "Unnamed Script",
        "უსახელო სკრიპტი",
        "Жаңа скрипт",
        "Script nou",
        "Новый скрипт",
        "Yeni skript dosyası",
        "Новий скрипт",
        "未命名脚本",
    ]

    def __init__(self):
        pass

    # noinspection PyUnusedLocal
    @staticmethod
    def do_nothing(*args, **kwargs):
        """Ничего не делает.

        Returns:
            :obj:`bool`: ``True``
        """
        return True

    @classmethod
    def run_as_thread_v2(cls, locked=False, daemon=True):
        """Декоратор для запуска функций в отдельном потоке.

        Args:
            locked (:obj:`bool`, optional): Если :obj:`True` - запускает поток с блокировкой
                доступа к ресурсам. По умолчанию :obj:`False`
            daemon (:obj:`bool`, optional): Устанавливает значение :obj:`threading.Thread.daemon`.
                По умолчанию :obj:`True`

        Examples:
            >>> import time
            >>>
            >>>
            >>> @BaseUtils.run_as_thread_v2()
            >>> def run_count_timer():
            >>>     time.sleep(1)
            >>>     host.stats()["run_count"] += 1
            >>>
            >>>
            >>> run_count_timer()
        """
        lock = threading.Lock()

        def wrapped(fn):
            @wraps(fn)
            def run(*args, **kwargs):
                def raise_exc(err):
                    # noinspection PyShadowingNames
                    args = list(err.args)
                    args[0] = "[{}]: {}".format(fn.__name__, args[0])
                    err.args = args
                    raise err

                def locked_fn(*args_, **kwargs_):
                    lock.acquire()
                    try:
                        return fn(*args_, **kwargs_)
                    except Exception as err:
                        cls._host_api.timeout(1, lambda: raise_exc(err))
                    finally:
                        lock.release()

                def unlocked_fn(*args_, **kwargs_):
                    try:
                        return fn(*args_, **kwargs_)
                    except Exception as err:
                        cls._host_api.timeout(1, lambda: raise_exc(err))

                t = threading.Thread(
                    target=locked_fn if locked else unlocked_fn,
                    args=args,
                    kwargs=kwargs,
                )
                t.daemon = daemon
                t.start()
                return t

            return run

        return wrapped

    @staticmethod
    def run_as_thread(fn):
        """Декоратор для запуска функций в отдельном потоке.

        Returns:
            :obj:`threading.Thread`: Функция в отдельном потоке

        Examples:
            >>> import time
            >>>
            >>>
            >>> @BaseUtils.run_as_thread
            >>> def run_count_timer():
            >>>     time.sleep(1)
            >>>     host.stats()["run_count"] += 1
            >>>
            >>>
            >>> run_count_timer()
        """

        @wraps(fn)
        def run(*args, **kwargs):
            t = threading.Thread(target=fn, args=args, kwargs=kwargs)
            t.daemon = True
            t.start()
            return t

        return run

    @staticmethod
    def catch_request_exceptions(func):
        """Catch request errors"""

        @wraps(func)
        def wrapped(self, *args, **kwargs):
            try:
                return func(self, *args, **kwargs)
            except urllib2.HTTPError as e:
                return e.code, "HTTPError: {}".format(e.code)
            except urllib2.URLError as e:
                return e.reason, "URLError: {}".format(e.reason)
            except httplib.HTTPException as e:
                return e, "HTTPException: {}".format(e)
            except ssl.SSLError as e:
                return e.errno, "SSLError: {}".format(e)

        return wrapped

    @staticmethod
    def win_encode_path(path):
        """Изменяет кодировку на ``"cp1251"`` для WinOS.

        Args:
            path (:obj:`str`): Путь до файла или папки

        Returns:
            :obj:`str`: Декодированый путь до файла или папки

        Examples:
            >>> path = r"D:\Shots\Скриншот.jpeg"
            >>> os.path.isfile(path)
            False
            >>> os.path.isfile(BaseUtils.win_encode_path(path))
            True
        """
        if os.name == "nt":
            try:
                path = path.decode("utf8")
            except UnicodeDecodeError:
                logger.warning("UnicodeDecodeError: {}".format(path), exc_info=True)
                pass

        return path

    @staticmethod
    def is_file_exists(file_path, tries=1):
        """Проверяет, существует ли файл.

        Проверка происходит в течении ``tries`` секунд.

        Warning:
            | Запускайте функцию только в отдельном потоке если ``tries > 1``
            | Вторая и последующие проверки производятся с ``time.sleep(1)``

        Args:
            file_path (:obj:`str`): Полный путь до файла
            tries (:obj:`int`, optional): Количество проверок. По умолчанию ``tries=1``

        Returns:
            :obj:`bool`: ``True`` if file exists, ``False`` otherwise

        Examples:
            >>> BaseUtils.is_file_exists("_t1server.settings")
            True
        """
        file_path_encoded = BaseUtils.win_encode_path(file_path)
        if os.path.isfile(file_path) or os.path.isfile(file_path_encoded):
            return True
        for x in xrange(tries - 1):
            time.sleep(1)
            if os.path.isfile(file_path) or os.path.isfile(file_path_encoded):
                return True
        return False

    @staticmethod
    def is_folder_exists(folder):
        """Проверяет существование папки и доступ на запись.

        Args:
            folder (:obj:`str`): Путь к папке.

        Raises:
            IOError: Если папка не существует

        Examples:
            >>> BaseUtils.is_folder_exists("/test_path")
            IOError: Folder '/test_path' is not exists
        """

        if not os.path.isdir(folder):
            raise IOError("Folder '{}' is not exists".format(folder))

        readme_file = os.path.join(folder, "readme.txt")
        with open(readme_file, "w") as f:
            f.write(
                "If you see this file - Trassir script have no access to remove it!"
            )
        os.remove(readme_file)

    @classmethod
    def is_template_exists(cls, template_name):
        """Проверяет существование шаблона

        Args:
            template_name (:obj:`str`): Имя шаблона

        Returns:
            :obj:`bool`: :obj:`True` если шаблон существует, иначе :obj:`False`
        """
        if template_name in [
            tmpl_.name for tmpl_ in cls._host_api.settings("templates").ls()
        ]:
            return True
        return False

    @classmethod
    def cat(cls, filepath, check_ext=True):
        """Выводит на отображение текстовую инфомрацию.

        Tip:
            - *WinOS*: открывает файл программой по умолчанию
            - *TrassirOS*: открывает файл в терминале с помощью утилиты `cat`

        Note:
            | Доступные расширения файлов: ``[".txt", ".csv", ".log"]``
            | Если открываете файл с другим расширением установите ``check_ext=False``

        Args:
            filepath (:obj:`str`): Полный путь до файла
            check_ext (:obj:`bool`, optional): Если ``True`` - проверяет расширение файла.
                По умолчанию ``True``

        Examples:
            >>> BaseUtils.cat("/home/trassir/ Trassir 3 License.txt")
        .. image:: images/base_utils.cat.png

        Raises:
            :class:`TypeError`: Если ``check_ext=True`` расширение файла нет в списке :obj:`_TEXT_FILE_EXTENSIONS`
        """

        if check_ext:
            _, ext = os.path.splitext(filepath)
            if ext not in cls._TEXT_FILE_EXTENSIONS:
                raise TypeError(
                    "Bad file extension: {}. To ignore this: set check_ext=False".format(
                        ext
                    )
                )

        if os.name == "nt":
            os.startfile(filepath)
        else:
            subprocess.Popen(
                [
                    "xterm -fg black -bg white -geometry 90x35 -fn "
                    "-misc-fixed-medium-r-normal--18-120-100-100-c-90-iso10646-1 -e bash -c \"cat '{}'; "
                    "read -n 1 -s -r -p '\n\nPress any key to exit'; exit\"".format(
                        filepath
                    )
                ],
                shell=True,
                close_fds=True,
            )

    @classmethod
    def _json_serializer(cls, data):
        """JSON serializer for objects not serializable by default"""
        if isinstance(data, (datetime, date)):
            return data.isoformat()

        elif isinstance(data, cls._host_api.ScriptHost.SE_Settings):
            return "settings('{}')".format(data.path)

        elif isinstance(data, cls._host_api.ScriptHost.SE_Object):
            return "object('{}')".format(data.guid)

        return type(data).__name__

    @classmethod
    def to_json(cls, data, **kwargs):
        """Сериализация объекта в JSON стрку

        Note:
            Не вызывает ошибку при сериализации объектов :obj:`datetime`,
            :obj:`date`, :obj:`SE_Settings`, :obj:`SE_Object`

        Args:
            data (:obj:`obj`): Объект для сериализации

        Returns:
            :obj:`str`: JSON строка

        Examples:
            >>> obj = {"now": datetime.now()}
            >>> json.dumps(obj)
            TypeError: datetime.datetime(2019, 4, 2, 18, 01, 33, 881000) is not JSON serializable
            >>> BaseUtils.to_json(obj, indent=None)
            '{"now": "2019-04-02T18:01:33.881000"}'
        """

        return json.dumps(data, default=cls._json_serializer, **kwargs)

    @staticmethod
    def ts_to_datetime(ts):
        """Конвертирует timestamp в :obj:`datetime` объект

        Args:
            ts (:obj:`int`): Timestamp

        Returns:
            :obj:`datetime`: Datetime объект
        """
        if ts > 1e10:
            ts_sec = int(ts / 1e6)
            ts_ms = int(ts - ts_sec * 1e6)
        else:
            ts_sec = int(ts)
            ts_ms = 0

        return datetime.fromtimestamp(ts_sec) + timedelta(microseconds=ts_ms)

    @classmethod
    def lpr_flags_decode(cls, flags):
        """Преобразует флаги события AutoTrassir

        Приводит флаги события человекочитаемый список

        Note:
            Список доступных флагов:

            - ``LPR_UP`` - Направление движения вверх
            - ``LPR_DOWN`` - Направление движения вниз

            - ``LPR_BLACKLIST`` - Номер в черном списке
            - ``LPR_WHITELIST`` - Номер в черном списке
            - ``LPR_INFO`` - Номер в информационном списке

            - ``LPR_FIRST_LANE`` - Автомобиль двигается по первой полосе
            - ``LPR_SECOND_LANE`` - Автомобиль двигается по второй полосе
            - ``LPR_THIRD_LANE`` - Автомобиль двигается по третей полосе

            - ``LPR_EXT_DB_ERROR`` - Ошибка во внешнем списке
            - ``LPR_CORRECTED`` - Номер исправлен оператором

        Args:
            flags (:obj:`int`): Биты LPR события. Как правило аргумент :obj:`ev.flags`
                события :obj:`SE_LprEvent` AutoTrassir. Например :obj:`536870917`

        Returns:
            List[:obj:`str`]: Список флагов

        Examples:
            >>> BaseUtils.lpr_flags_decode(536870917)
            ['LPR_UP', 'LPR_BLACKLIST']
        """
        return [bit for bit, code in cls._LPR_FLAG_BITS.iteritems() if (flags & code)]

    @classmethod
    def image_to_base64(cls, image):
        """Создает base64 из изображения

        Args:
            image (:obj:`str`): Путь к изображению или изображение

        Returns:
            :obj:`str`: Base64 image

        Examples:
            >>> BaseUtils.image_to_base64(r"manual\en\cloud-devices-16.png")
            'iVBORw0KGgoAAAANSUhEUgAAB1MAAAH0CAYAAABo5wRhAAAACXBIWXMAAC4jA...'
            >>> BaseUtils.image_to_base64(open(r"manual\en\cloud-devices-16.png", "rb").read())
            'iVBORw0KGgoAAAANSUhEUgAAB1MAAAH0CAYAAABo5wRhAAAACXBIWXMAAC4jA...'
        """
        _, ext = os.path.splitext(image)

        if ext.lower() in cls._IMAGE_EXT:
            image = cls.win_encode_path(image)
            if not BaseUtils.is_file_exists(image):
                return ""

            with open(image, "rb") as image_file:
                image = image_file.read()

        return base64.b64encode(image)

    @classmethod
    def base64_to_html_img(cls, image_base64, **kwargs):
        """Возвращает base64 изображение в `<img>` html теге

        Args:
            image_base64 (:obj:`str`): Base64 image
            **kwargs: HTML `<img>` tag attributes. Подробнее на `html.com
                <https://html.com/tags/img/#Attributes_of_img>`_

        Returns:
            :obj:`str`: html image

        Examples:
            >>> base64_image = BaseUtils.image_to_base64(r"manual\en\cloud-devices-16.png")
            >>> html_image = BaseUtils.base64_to_html_img(base64_image, width=280, height=75)
            >>> html_image
            '<img src="data:image/png;base64,iVBORw0KGgoAA...Jggg==" width="280" height="75">'
            >>> host.message(html_image)

                .. image:: images/popup_sender.image.png
        """
        html_img = cls._HTML_IMG_TEMPLATE.format(
            img=image_base64,
            attr=" ".join(
                '%s="%s"' % (key, value) for key, value in kwargs.iteritems()
            ),
        )
        return html_img

    @staticmethod
    def save_pkl(file_path, data):
        """Сохраняет данные в `.pkl` файл

        Args:
            file_path (:obj:`str`): Путь до файла
            data: Данные для сохранения

        Returns:
            :obj:`str`: Абсолютный путь до файла

        Examples:
            >>> data = {"key": "value"}
            >>> BaseUtils.save_pkl("saved_data.pkl", data)
            'D:\\DSSL\\Trassir-4.1-Client\\saved_data.pkl'

        """
        if not file_path.endswith(".pkl"):
            file_path = file_path + ".pkl"

        with open(file_path, "wb") as opened_file:
            pickle.dump(data, opened_file)

        return os.path.abspath(file_path)

    @staticmethod
    def load_pkl(file_path, default_type=dict):
        """Загружает данные из `.pkl` файла

        Args:
            file_path (:obj:`str`): Путь до файла
            default_type (optional):
                Тип данных, возвращаемый при неудачной загрузке данных из файла.
                По умолчанию :obj:`dict`

        Returns:
            Данные из файла или :obj:`default_type()`

        Examples:
            >>> BaseUtils.load_pkl("fake_saved_data.pkl")
            {}
            >>> BaseUtils.load_pkl("fake_saved_data.pkl", default_type=list)
            []
            >>> BaseUtils.load_pkl("fake_saved_data.pkl", default_type=int)
            0
            >>> BaseUtils.load_pkl("fake_saved_data.pkl", default_type=str)
            ''
            >>> BaseUtils.load_pkl("saved_data.pkl")
            {'key': 'value'}
        """

        if not file_path.endswith(".pkl"):
            file_path = file_path + ".pkl"

        data = default_type()

        if os.path.isfile(file_path):
            try:
                with open(file_path, "rb") as opened_file:
                    data = pickle.load(opened_file)
            except (EOFError, IndexError, ValueError, TypeError):
                """ dump file is empty or broken """

        return data

    @classmethod
    def get_object(cls, obj_id):
        """Возвращает объект Trassir, если он доступен, иначе ``None``

        Args:
            obj_id (:obj:`str`): Guid объекта или его имя

        Returns:
            :obj:`ScriptHost.SE_Object`: Объект Trassir или ``None``

        Examples:
            >>> obj = BaseUtils.get_object("EZJ4QnbC")
            >>> if obj is None:
            >>>     host.error("Object not found")
            >>> else:
            >>>     host.message("Object name is {0.name}".format(obj))
        """
        if not isinstance(obj_id, (str, unicode)):
            raise TypeError(
                "Expected str or unicode, got '{}'".format(type(obj_id).__name__)
            )
        obj = cls._host_api.object(obj_id)
        try:
            obj.name
        except EnvironmentError:
            """Object not found"""
            obj = None
        return obj

    @classmethod
    def get_object_name_by_guid(cls, guid):
        """Возвращает имя объекта Trassir по его guid

        Tip:
            Можно использовать:

            - guid объекта ``"CFsuNBzt"``
            - guid объекта + guid сервера ``"CFsuNBzt_pV4ggECb"``

        Args:
            guid (:obj:`str`): Guid объекта Trassir

        Returns:
            :obj:`str`: Имя объекта, если объект найден, иначе ``guid``

        Examples:
            >>> BaseUtils.get_object_name_by_guid("EZJ4QnbC")
            'AC-D2141IR3'
            >>> BaseUtils.get_object_name_by_guid("EZJ4QnbC-")
            'EZJ4QnbC-'
        """
        guid = guid.split("_", 1)[0]
        obj = cls.get_object(guid)
        if obj is None:
            name = guid
        else:
            name = obj.name
        return name

    @classmethod
    def get_full_guid(cls, obj_id):
        """Возвращает полный guid объекта

        Args:
            obj_id (:obj:`str`): Guid объекта или его имя

        Returns:
            :obj:`str`: Полный guid объекта
        """

        tr_obj = cls.get_object(obj_id)
        if tr_obj is not None:
            for obj in cls._host_api.objects_list(""):
                if tr_obj.guid == obj[1]:
                    return "{}_{}".format(obj[1], cls._FOLDERS.get(obj[3], obj[3]))

    @classmethod
    def get_operator_gui(cls):
        """Возвращает объект интерфейса оператора

        Returns:
            :obj:`OperatorGUI`: Объект интерфейса оператора

        Raises:
            ScriptError: Если не удается загрузить интерфейс

        Examples:
            Открыть интерфейс Trassir а мониторе №1

            >>> operator_gui = BaseUtils.get_operator_gui()
            >>> operator_gui.raise_monitor(1)
        """
        obj = cls.get_object("operatorgui_{}".format(cls._host_api.settings("").guid))
        if obj is None:
            raise ScriptError("Failed to load operator gui")
        return obj

    @classmethod
    def get_server_guid(cls):
        """Возвращает guid текущего сервра

        Returns:
            :obj:`str`: Guid сервера

        Examples:
            >>> BaseUtils.get_server_guid()
            'client'
        """
        return cls._host_api.settings("").guid

    @classmethod
    def get_script_name(cls):
        """Возвращает имя текущего скрипта

        Returns:
            :obj:`str`: Имя скрипта

        Examples:
            >>> BaseUtils.get_script_name()
            'Новый скрипт'
        """
        return cls._host_api.stats().parent()["name"] or __name__

    @classmethod
    def get_screenshot_folder(cls):
        """Возвращает путь до папки скриншотов

        При этом производит проверку папки методом
        :meth:`BaseUtils.is_folder_exists`

        Returns:

            :obj:`str`: Полный путь к папке скриншотов

        Examples:
            >>> BaseUtils.get_screenshot_folder()
            '/home/trassir/shots'
        """
        folder = cls._host_api.settings("system_wide_options")["screenshots_folder"]
        cls.is_folder_exists(folder)
        return folder

    @classmethod
    def get_logger(
        cls,
        name=None,
        host_log="WARNING",
        popup_log="ERROR",
        file_log=None,
        file_name=None,
    ):
        """Возвращает логгер с предустановленными хэндлерами

        Доступные хэндлеры:
            - *host_log*: Пишет сообщения в основной лог сервера _t1server.log
            - *popup_log*: Показывает всплывающие сообщения ``message/alert/error``
            - *file_log*: Пишет сообщения в отдельный файл в папку скриншотов

        Для каждого хэндлера можно установить разный уровень логирования

        По умолчанию ``host_log="WARNING"`` и ``popup_log="ERROR"``

        Note:
            Имя файла лога можно указать с расширение ".log" или без.

        See Also:
            `Logging levels на сайте docs.python.org
            <https://docs.python.org/2/library/logging.html#logging-levels>`_

        Args:
            name (:obj:`str`, optional): Имя логгера, должно быть уникальным для
                каждого скрипта. По умолчанию :obj:`None`, и равно guid скрипта.
            host_log (:obj:`str`, optional): Уровень логирования в основной лог.
                По умолчанию ``"WARNING"``
            popup_log (:obj:`str`, optional): Уровень логирования во всплывающих
                сообщениях. По умолчанию ``"ERROR"``
            file_log (:obj:`str`, optional): Уровень логирования в отдельный файл
                По умолчанию :obj:`None`
            file_name (:obj:`str`, optional): Имя файла для логирования.
                По умолчанию :obj:`None` и равно ``<имени скрипта>.log``

        Returns:
            :obj:`logging.logger`: Логгер

        Examples:
            >>> logger = BaseUtils.get_logger()
            >>> logger.warning("My warning message")
            >>> try:
            >>>     # noinspection PyUnresolvedReferences
            >>>     do_something()
            >>> except NameError:
            >>>     logger.error("Function is not defined", exc_info=True)
        """
        logger_ = logging.getLogger(name or __name__)
        logger_.setLevel("DEBUG")

        if logger_.handlers:
            for handler in logger_.handlers[:]:
                handler.close()
                logger_.removeHandler(handler)

        if host_log:
            host_handler = HostLogHandler()
            host_handler.setLevel(host_log)
            if name:
                host_formatter = logging.Formatter(
                    "[%(levelname)-8s] %(lineno)-4s <%(funcName)s> - %(name)s: %(message)s"
                )
            else:
                host_formatter = logging.Formatter(
                    "[%(levelname)-8s] %(lineno)-4s <%(funcName)s> - %(message)s"
                )
            host_handler.setFormatter(host_formatter)
            logger_.addHandler(host_handler)

        if popup_log:
            popup_handler = PopupHandler()
            popup_handler.setLevel(popup_log)
            popup_formatter = logging.Formatter(
                fmt="<b>[%(levelname)s]</b> Line: %(lineno)s<br><i>%(message).630s</i>"
            )
            popup_handler.setFormatter(popup_formatter)
            logger_.addHandler(popup_handler)

        if file_log:
            if file_name is None:
                file_name = cls.get_script_name()

            if not file_name.endswith(".log"):
                file_name = "{}.log".format(file_name)

            file_path = os.path.join(cls.get_screenshot_folder(), file_name)
            file_path = cls.win_encode_path(file_path)

            file_handler = MyFileHandler(file_path)
            file_handler.setLevel(file_log)
            if name:
                file_formatter = logging.Formatter(
                    fmt="%(asctime)s [%(levelname)-8s] %(lineno)-4s <%(funcName)s> - %(name)s: %(message)s",
                    datefmt="%Y/%m/%d %H:%M:%S",
                )
            else:
                file_formatter = logging.Formatter(
                    fmt="%(asctime)s [%(levelname)-8s] %(lineno)-4s <%(funcName)s> - %(message)s",
                    datefmt="%Y/%m/%d %H:%M:%S",
                )
            file_handler.setFormatter(file_formatter)
            logger_.addHandler(file_handler)

        return logger_

    @classmethod
    def set_script_name(cls, fmt=None, script_name=None):
        """Автоматически изменяет имя скрипта

        Новое имя скрипта создается на основе `параметров
        <https://www.dssl.ru/files/trassir/manual/ru/setup-script-parameters.html>`_
        скрипта. По желанию можно изменить шаблон имени. По умолчанию
        :obj:`"[{company}] {title} v{version}"`

        Note:
            Имя изменяется только если сейчас у скрипта стандартное имя,
            например :obj:`"Новый скрипт"` или :obj:`"Unnamed Script"` и др.

        Args:
            fmt (:obj:`str`, optional): Шаблон имени скрипта. По умолчанию :obj:`None`
            script_name (:obj:`str`, optional): Имя скрипта. Если не задано - парсит
                имя из параметров. По умолчанию :obj:`None`

        Examples:
            >>> BaseUtils.set_script_name()
            'AATrubilin - trassir_script_framework v0.4'

            >>> BaseUtils.set_script_name(fmt="{title}")
            'trassir_script_framework'
        """
        if cls._host_api.stats().parent()["name"] in cls._SCR_DEFAULT_NAMES:
            if script_name is None:
                try:
                    root = ElementTree.fromstring(__doc__)
                except ElementTree.ParseError:
                    root = None

                if root is None:
                    company, title, version = None, None, None
                else:
                    company = root.find("company") if root else None
                    title = root.find("title") if root else None
                    version = root.find("version") if root else None

                if fmt is None:
                    fmt = "[{company}] {title} v{version}"

                script_name = fmt.format(
                    company="DSSL" if company is None else company.text,
                    title="Script" if title is None else title.text,
                    version="0.1" if version is None else version.text,
                )

            cls._host_api.stats().parent()["name"] = script_name

            return script_name


class Worker(threading.Thread):
    """Thread executing tasks from a given tasks queue"""

    def __init__(self, tasks):
        super(Worker, self).__init__()
        alert("START WORKER")
        self.tasks = tasks
        self.daemon = True
        self.start()

    def run(self):
        while __name__ in sys.modules.keys():
            if not self.tasks.empty():
                func, args, kwargs = self.tasks.get(timeout=1)
                # noinspection PyBroadException
                try:
                    func(*args, **kwargs)
                except:
                    logger.exception("ThreadPool Worker error")
                finally:
                    self.tasks.task_done()


class ThreadPool:
    """Pool of threads consuming tasks from a queue"""

    def __init__(self, num_threads, host_api=host):
        self._host_api = host_api
        self.tasks = Queue()
        self.workers = [Worker(self.tasks) for _ in xrange(num_threads)]

    def add_task(self, func, *args, **kargs):
        """Add a task to the queue"""
        self.tasks.put((func, args, kargs))

    def wait_completion(self):
        """Wait for completion of all the tasks in the queue"""
        self.tasks.join()


class HTTPRequester(py_object):
    """Framework for urllib2

    See Also:
        https://docs.python.org/2/library/urllib2.html#urllib2.build_opener

    Args:
        opener (:obj:`urllib2.OpenerDirector`, optional): Обработчик запросов.
            По умолчанию :obj:`None`
        timeout (:obj:`int`, optional): Время ожидания запроса, в секундах.
            По умолчанию :obj:`timeout=10`

    Examples:
        Пример запроса к SDK Trassir

        >>> # Отключение проверки сертификата
        >>> context = ssl.create_default_context()
        >>> context.check_hostname = False
        >>> context.verify_mode = ssl.CERT_NONE
        >>>
        >>> handler = urllib2.HTTPSHandler(context=context)
        >>> opener = urllib2.build_opener(handler)
        >>>
        >>> requests = HTTPRequester(opener, timeout=20)
        >>> response = requests.get(
        >>>     "https://172.20.0.101:8080/login",
        >>>     params={"username": "Admin", "password": "12345"}
        >>> )
        >>>
        >>> response.code
        200
        >>> response.text
        '{\\n   "sid" : "T6LAAcxg",\\n   "success" : 1\\n}\\n'
        >>> response.json
        {u'success': 1, u'sid': u'T6LAAcxg'}
    """

    class Response(py_object):
        """Класс ответа от сервера

        Attributes:
            code (:obj:`str` | :obj:`int`): Код ответа сервера
            text (:obj:`str`): Текст ответа
            json (:obj:`dict` | :obj:`list`): Создает объект из json ответа
        """

        def __init__(self, *args):
            self.code, self.text = args

        @property
        def json(self):
            return json.loads(self.text)

    def __init__(self, opener=None, timeout=10):
        if opener is None:
            handler = urllib2.BaseHandler()
            opener = urllib2.build_opener(handler)
        self._opener = opener

        self.timeout = timeout

    @BaseUtils.catch_request_exceptions
    def _get_response(self, request):
        """Returns response

        Args:
            request (:obj:`urllib2.Request`): This class is an abstraction of a URL request
        """
        response = self._opener.open(request, timeout=self.timeout)
        return response.code, response.read()

    @staticmethod
    def _parse_params(**params):
        """Params get string params

        Args:
            **params (dict): Keyword arguments

        Returns:
            str: params string
        """
        return "&".join(
            "{key}={value}".format(key=key, value=value)
            for key, value in params.iteritems()
        )

    @staticmethod
    def _prepare_headers(headers):
        """Prepare headers for request"""
        if headers is None:
            headers = {}

        if "User-Agent" not in headers:
            headers["User-Agent"] = "TrassirScript"
        return headers

    def get(self, url, params=None, headers=None):
        """Создает GET запрос по указанному :obj:`url`

        Args:
            url (:obj:`str`): Url для запроса
            params (:obj:`dict`, optional): Параметры GET запроса
            headers (:obj:`dict`, optional): Заголовки запроса

        Examples:
            >>> requests = HTTPRequester()
            >>> response = requests.get(
            >>>     "http://httpbin.org/get",
            >>>     params={"PARAMETER": "TEST"},
            >>> )
            >>> response.code
            200
            >>> response.text
            '{\\n  "args": {\\n    "PARAMETER": "TEST"\\n  }, \\n ...'
            >>> response.json
            {u'args': {u'PARAMETER': u'TEST'}, ...}

        Returns:
            :class:`HTTPRequester.Response`: Response instance
        """
        if params is not None:
            url += "?{params}".format(params=self._parse_params(**params))

        headers = self._prepare_headers(headers)

        request = urllib2.Request(url, headers=headers)
        response = self._get_response(request)
        return self.Response(*response)

    def post(self, url, data=None, headers=None):
        """Создает POST запрос по указанному :obj:`url`

        Args:
            url (:obj:`str`): Url для запроса
            data (:obj:`dict`, optional): Данные POST запроса
            headers (:obj:`dict`, optional): Заголовки запроса

        Examples:
            >>> requests = HTTPRequester()
            >>> response = requests.post(
            >>>     "http://httpbin.org/post",
            >>>     data={"PARAMETER": "TEST"},
            >>>     headers={"Content-Type": "application/json"},
            >>> )
            >>> response.code
            200
            >>> response.text
            '{\\n  "args": {\\n    "PARAMETER": "TEST"\\n  }, \\n ...'
            >>> response.json
            {u'args': {u'PARAMETER': u'TEST'}, ...}

        Returns:
            :class:`HTTPRequester.Response`: Response instance
        """
        if data is None:
            data = {}

        if isinstance(data, dict):
            data = urllib.urlencode(data)

        headers = self._prepare_headers(headers)

        request = urllib2.Request(url, data=data, headers=headers)
        response = self._get_response(request)
        return self.Response(*response)


class ScriptObject(host.TrassirObject, py_object):
    """Создает объект для генерации событий

    Args:
        name (:obj:`str`, optional): Имя объекта. По умолчанию :obj:`None`
        guid (:obj:`str`, optional): Guid объекта. По умолчанию :obj:`None`
        parent (:obj:`str`, optional): Guid родительского объекта. По умолчанию :obj:`None`

    Note:
        - Имя объекта по умолчанию - :meth:`BaseUtils.get_script_name`
        - Guid объекта по умолчанию строится по шаблноу ``"{script_guid}_object"``
        - Guid родительского объекта по умолчанию -
          :meth:`BaseUtils.get_server_guid`

    Examples:
        >>> # Создаем объект
        >>> scr_obj = ScriptObject()

        >>> # Проверяем текущее состояние объекта
        >>> scr_obj.health
        'OK'

        >>> # Установить флаг возле объекта
        >>> scr_obj.check_me = True

        >>> # Сгенерировать событие с текстом
        >>> scr_obj.fire_event_v2("New event")
    """

    def __init__(self, name=None, guid=None, parent=None, host_api=host):
        super(ScriptObject, self).__init__("Script")

        self._host_api = host_api
        scr_parent = host_api.stats().parent()

        self._name = name or BaseUtils.get_script_name()
        self.set_name(self._name)

        self._guid = guid or "{}-object".format(scr_parent.guid)
        self.set_guid(self._guid)

        self._parent = parent or BaseUtils.get_server_guid()
        self.set_parent(self._parent)

        self._folder = ""

        self._health = "OK"
        self._check_me = True

        self.set_initial_state([self._health, self._check_me])

        host_api.object_add(self)

    @property
    def health(self):
        """:obj:`"OK"` | :obj:`"Error"`: Состояние объекта"""
        return self._health

    @health.setter
    def health(self, value):
        if value in ["OK", "Error"]:
            self.set_state([value, self._check_me])
            self._health = value
        else:
            raise ValueError("Expected 'OK' or 'Error', got '{}'".format(value))

    @property
    def check_me(self):
        """:obj:`bool`: Флаг ``check_me`` объекта"""
        return self._check_me

    @check_me.setter
    def check_me(self, value):
        if isinstance(value, bool) or value in [1, 0]:
            value = 1 - value
            self.set_state([self._health, value])
            self._check_me = value
        else:
            raise ValueError("Expected bool or 1|0, got '{}'".format(value))

    @property
    def name(self):
        """:obj:`str`: Имя объекта"""
        return self._name

    @name.setter
    def name(self, value):
        if isinstance(value, str):
            self.set_name(value)
            self._name = value
        else:
            raise ValueError("Expected str, got {}".format(type(value).__name__))

    @property
    def folder(self):
        """:obj:`str`: Папка объекта"""
        return self._folder

    @folder.setter
    def folder(self, value):
        if not value:
            raise ValueError("Object guid can't be empty")

        if isinstance(value, str):
            if self._folder:
                self.change_folder(value)
            else:
                self.set_folder(value)
            self._folder = value
        else:
            raise ValueError("Expected str, got {}".format(type(value).__name__))

    def fire_event_v2(self, message, channel="", data=""):
        """Создает событие в Trassir

        Args:
            message (:obj:`str`): Сообщение события (``p1``)
            channel (:obj:`str`, optional): Ассоциированный с событием канал (``p2``)
            data (:obj:`str`, optional): Дополнительные данные (``p3``)
        """
        if not isinstance(data, str):
            data = BaseUtils.to_json(data, indent=None)

        self.fire_event("Script: %1", message, channel, data)


class ShotSaverError(ScriptError):
    """Base ShotSaver Exception"""

    pass


class ShotSaver(py_object):
    # noinspection PyUnresolvedReferences
    """Класс для сохранения скриншотов

        Args:
            shot_awaiting_time (:obj:`int`, optional): Время ожидания скриншота, с. По умолчанию :obj:`5`.
            tries_to_make_shot (:obj:`int`, optional): Кол-во попыток сохранить скриншот.
                Если в течении времени `shot_awaiting_time` скриншот не был сохранен - производится
                следующая попытка сохранить скриншот. По умолчанию :obj:`2`
            pool_size (:obj:`int`): Размер пула. По умолчанию :obj:`10`

        Attributes:
            pool_size (:obj:`int`): Размер пула. По умолчанию :obj:`10`
            pool_queue_size (:obj:`int`): Размер текущей очереди в пуле.

        Examples:

            >>> ss = ShotSaver()
            >>> # Смена папки сохранения скриншотов по умолчанию
            >>> ss.screenshots_folder
            '/home/trassir/shots'
            >>> ss.screenshots_folder += "/my_shots"
            >>> ss.screenshots_folder
            '/home/trassir/shots/my_shots'
            >>>
            >>> # Сохранение скриншота с канала ``"e80kgBLh_pV4ggECb"``
            >>> ss.shot("e80kgBLh_pV4ggECb")
            '/home/trassir/shots/AC-D2141IR3 Склад (2019.04.03 15-58-26).jpg'
        """

    _SHOT_NAME_TEMPLATE = (
        "{name} (%Y.%m.%d %H-%M-%S).jpg"
    )  # Template for shot file name

    def __init__(self, shot_awaiting_time=5, tries_to_make_shot=2, pool_size=10, host_api=host):
        self._shot_awaiting_time = shot_awaiting_time
        self._tries_to_make_shot = tries_to_make_shot
        self._thread_pool = None
        self._pool_size = pool_size

        self._host_api = host_api
        self._screenshots_folder = BaseUtils.get_screenshot_folder()

    @property
    def pool_size(self):
        return self._pool_size

    @pool_size.setter
    def pool_size(self, value):
        if self._thread_pool is None:
            self._pool_size = value
        else:
            raise RuntimeError("You can't change pool size when workers created")

    @property
    def pool_queue_size(self):
        if self._thread_pool is None:
            return -1
        else:
            return self._thread_pool.tasks.qsize()

    @property
    def screenshots_folder(self):
        """:obj:`str`: Папка для сохранения скриншотов по умолчанию

        Устанавливает новый путь по умолчанию для сохранения скриншотов,
        если папка не существует - создает папку. Или возвращает текущий
        путь для сохранения скриншотов.

        Note:
            По молчанию :obj:`screenshots_folder`  =
            :meth:`BaseUtils.get_screenshot_folder`

        Raises:
            OSError: Если возникает ошибка при создании папки
        """
        return self._screenshots_folder

    @screenshots_folder.setter
    def screenshots_folder(self, folder):
        if not os.path.isdir(folder):
            try:
                os.makedirs(folder)
            except OSError as err:
                raise OSError("Can't make dir '{}': {}".format(folder, err))

        self._screenshots_folder = folder

    def shot(self, channel_full_guid, dt=None, file_name=None, file_path=None):
        """Делает скриншот с указанного канала

        Note:
            По умолчанию:

            - :obj:`dt=datetime.now()`
            - :obj:`file_name="{name} (%Y.%m.%d %H-%M-%S).jpg"`, где ``{name}`` - имя канала

        Args:
            channel_full_guid (:obj:`str`): Полный guid анала. Например: ``"CFsuNBzt_pV4ggECb"``
            dt (:obj:`datetime.datetime`, optional): :obj:`datetime.datetime` для скриншота.
                По умолчанию :obj:`None`
            file_name (:obj:`str`, optional): Имя файла с расширением. По умолчанию :obj:`None`
            file_path (:obj:`str`, optional): Путь для сохранения скриншота. По умолчанию :obj:`None`

        Returns:
            :obj:`str`: Полный путь до скриншота

        Raises:
            ValueError: Если в guid канала отсутствует guid сервера
            TypeError: Если ``isinstance(dt, (datetime, date)) is False``

        Examples:
            >>> ss = ShotSaver()
            >>> ss.shot("e80kgBLh_pV4ggECb")
            '/home/trassir/shots/AC-D2141IR3 Склад (2019.04.03 15-58-26).jpg'
        """
        logger.debug(
            "ShotSaver.shot({channel_full_guid}, dt={dt}, file_name={file_name}, file_path={file_path})".format(
                channel_full_guid=repr(channel_full_guid),
                dt=repr(dt),
                file_name=repr(file_name),
                file_path=repr(file_path),
            )
        )
        if "_" not in channel_full_guid:
            raise ValueError(
                "Expected full channel guid, got {}".format(channel_full_guid)
            )

        if dt is None:
            ts = "0"
            dt = datetime.now()
        else:
            if not isinstance(dt, (datetime, date)):
                raise TypeError("Expected datetime, got {}".format(type(dt).__name__))
            ts = dt.strftime("%Y%m%d_%H%M%S")

        if file_name is None:
            file_name = dt.strftime(
                self._SHOT_NAME_TEMPLATE.format(
                    name=BaseUtils.get_object_name_by_guid(channel_full_guid)
                )
            )
        if file_path is None:
            file_path = self.screenshots_folder

        self._host_api.screenshot_v2_figures(
            channel_full_guid, file_name, file_path, ts
        )

        return os.path.join(file_path, file_name)

    def _async_shot(
        self, channel_full_guid, dt=None, file_name=None, file_path=None, callback=None
    ):
        """Вызывает ``callback`` после сохнанения скриншота

        * Метод работает в отдельном потоке
        * Вызывает функцию :meth:`ShotSaver.shot`
        * Ждет выполнения функции :meth:`BaseUtils.check_file` ``tries=10``
        * Вызвает ``callback`` функцию

        Args:
            channel_full_guid (:obj:`str`): Полный guid канала. Например: ``"CFsuNBzt_pV4ggECb"``
            dt (:obj:`datetime.datetime`, optional): :obj:`datetime.datetime` для скриншота.
                По умолчанию :obj:`None`
            file_name (:obj:`str`, optional): Имя файла с расширением. По умолчанию :obj:`None`
            file_path (:obj:`str`, optional): Путь для сохранения скриншота. По умолчанию :obj:`None`
            callback (:obj:`function`): Callable function
        """
        if callback is None:
            callback = BaseUtils.do_nothing

        shot_file = ""
        for _ in xrange(self._tries_to_make_shot):
            shot_file = self.shot(
                channel_full_guid, dt=dt, file_name=file_name, file_path=file_path
            )
            if BaseUtils.is_file_exists(
                BaseUtils.win_encode_path(shot_file), self._shot_awaiting_time
            ):
                self._host_api.timeout(100, lambda: callback(True, shot_file))
                break
        else:
            self._host_api.timeout(100, lambda: callback(False, shot_file))

    @BaseUtils.run_as_thread
    def async_shot(
        self, channel_full_guid, dt=None, file_name=None, file_path=None, callback=None
    ):
        """async_shot(channel_full_guid, dt=None, file_name=None, file_path=None, callback=None)
        Вызывает ``callback`` после сохнанения скриншота

        * Метод работает в отдельном потоке
        * Вызывает функцию :meth:`ShotSaver.shot`
        * Ждет выполнения функции :meth:`BaseUtils.check_file` ``tries=10``
        * Вызвает ``callback`` функцию

        Args:
            channel_full_guid (:obj:`str`): Полный guid канала. Например: ``"CFsuNBzt_pV4ggECb"``
            dt (:obj:`datetime.datetime`, optional): :obj:`datetime.datetime` для скриншота.
                По умолчанию :obj:`None`
            file_name (:obj:`str`, optional): Имя файла с расширением. По умолчанию :obj:`None`
            file_path (:obj:`str`, optional): Путь для сохранения скриншота. По умолчанию :obj:`None`
            callback (:obj:`function`, optional): Функциюя, которая вызывается после сохранения скриншота.
                В качестве аргументов должна принимать `success`, `shot_path`. По умолчанию :obj:`None`

        Returns:
            :obj:`threading.Thread`: Thread object

        Examples:
            >>> # noinspection PyUnresolvedReferences
            >>> def callback(success, shot_path):
            >>>     # Пример callback функции
            >>>     # Args:
            >>>     #     success (bool): True если скриншот успешно сохранен, иначе False
            >>>     #     shot_path (str): Полный путь до скриншота
            >>>     if success:
            >>>         host.message("Скриншот успешно сохранен<br>%s" % shot_path)
            >>>     else:
            >>>         host.error("Ошибка сохранения скриншота <br>%s" % shot_path)
            >>>
            >>> ss = ShotSaver()
            >>> ss.async_shot("e80kgBLh_pV4ggECb", callback=callback)
        """
        self._async_shot(
            channel_full_guid,
            dt=dt,
            file_name=file_name,
            file_path=file_path,
            callback=callback,
        )

    @BaseUtils.run_as_thread
    def _pool_awaiting(self):
        self._thread_pool.wait_completion()

    # noinspection PyIncorrectDocstring
    def pool_shot(self, *args, **kwargs):
        """pool_shot(channel_full_guid, dt=None, file_name=None, file_path=None, callback=None)
        Сохраняет скриншоты в пуле.

        Одновременно в работе не более :obj:`Saver.pool_size` задач.

        Warnings:
            Данный метод создает :obj:`Saver.pool_size` доп. потоков.
            Потоки удаляются при отключении скрипта.

        Args:
            channel_full_guid (:obj:`str`): Полный guid канала. Например: ``"CFsuNBzt_pV4ggECb"``
            dt (:obj:`datetime.datetime`, optional): :obj:`datetime.datetime` для скриншота.
                По умолчанию :obj:`None`
            file_name (:obj:`str`, optional): Имя файла с расширением. По умолчанию :obj:`None`
            file_path (:obj:`str`, optional): Путь для сохранения скриншота. По умолчанию :obj:`None`
            callback (:obj:`function`, optional): Функциюя, которая вызывается после сохранения скриншота.
                В качестве аргументов должна принимать `success`, `shot_path`. По умолчанию :obj:`None`

        Examples:

            >>> ss = ShotSaver()
            >>> ss.pool_size = 2
            >>>
            >>> ss.pool_shot("e80kgBLh_pV4ggECb")
            >>> ss.pool_shot("e80kgBLh_pV4ggECb")
            >>> ss.pool_shot("e80kgBLh_pV4ggECb")
            >>> ss.pool_shot("e80kgBLh_pV4ggECb")
            >>>
            >>> ss.pool_queue_size
            4
        """
        if self._thread_pool is None:
            self._thread_pool = ThreadPool(self._pool_size)

        self._thread_pool.add_task(self._async_shot, *args, **kwargs)


class VideoExporterError(ScriptError):
    """Base ShotSaver Exception"""

    pass


class VideoExporter(py_object):
    """Класс для экспорта видео

    Examples:
        Смена папки экспорта видео по умолчанию

        >>> ss = VideoExporter()
        >>> ss.export_folder
        '/home/trassir/shots'
        >>> ss.export_folder += "/my_videos"
        >>> ss.export_folder
        '/home/trassir/shots/my_videos'

        | Экспорт видео с вызовом ``callback`` функции после выполнения.
        | Начало экспорта - 120 секунд назад, продолжительность 60 сек.

        >>> # noinspection PyUnresolvedReferences
        >>> def callback(success, file_path, channel_full_guid):
        >>>     # Пример callback функции
        >>>     # Args:
        >>>     #     success (bool): True если видео экспортировано успешно, иначе False
        >>>     #     file_path (str): Полный путь до видеофайла
        >>>     #     channel_full_guid (str) : Полный guid канала
        >>>     if success:
        >>>         host.message("Экспорт успешно завершен<br>%s" % file_path)
        >>>     else:
        >>>         host.error("Ошибка экспорта<br>%s" % file_path)

        >>> ss = VideoExporter()
        >>> dt_start = datetime.now() - timedelta(seconds=120)
        >>> ss.export(callback, "e80kgBLh_pV4ggECb", dt_start)
    """

    _EXPORTED_VIDEO_NAME_TEMPLATE = (
        "{name} ({dt_start} - {dt_end}){sub}.avi"
    )  # Template for shot file name

    def __init__(self, host_api=host):
        self._host_api = host_api
        self._export_folder = BaseUtils.get_screenshot_folder()
        self._now_exporting = False
        self._queue = deque()
        self._default_prebuffer = host_api.settings("archive")["prebuffer"] + 2

    @property
    def export_folder(self):
        """:obj:`str`: Папка для экспорта видео по умолчанию

        Устанавливает новый путь по умолчанию для экспорта видео,
        если папка не существует - создает папку. Или возвращает текущий
        путь для экспорта видео.

        Note:
            По молчанию ``export_folder`` = :meth:`BaseUtils.get_screenshot_folder`

        Raises:
            OSError: Если возникает ошибка при создании папки
        """
        return self._export_folder

    @export_folder.setter
    def export_folder(self, folder):
        if not os.path.isdir(folder):
            try:
                os.makedirs(folder)
            except OSError as err:
                raise OSError("Can't make dir '{}': {}".format(folder, err))

        self._export_folder = folder

    def _get_prebuffer(self, server_guid, dt_end):
        """Get prebuffer delay

        Args:
            server_guid (str): Full channel guid include server guid

        Returns:
            int: Prebuffer delay
        """
        setting_path = "/{}/archive".format(server_guid)

        try:
            prebuffer = self._host_api.settings(setting_path)["prebuffer"] + 2
        except KeyError:
            prebuffer = self._default_prebuffer

        wait_dt_end = (int(time.mktime(dt_end.timetuple())) + prebuffer) * 1000000

        return "%.0f" % wait_dt_end

    def clear_complete_tasks(self):
        for task in self._host_api.archive_export_tasks_get():
            if task["state"] != 1:
                self._host_api.archive_export_task_cancel(
                    task["id"],  # task id from archive_export_tasks_get
                    -1,  # -1 - do not wait for result, 0 - wait forever, > 0 - wait timeout_sec seconds
                    BaseUtils.do_nothing,  # callback_success
                    BaseUtils.do_nothing,  # callback_error
                )

    def _check_queue(self):
        self._host_api.timeout(10, self.clear_complete_tasks)
        if self._queue:
            args, kwargs = self._queue.popleft()
            self._export(*args, **kwargs)

    def _export_checker(self, status, callback, file_path, channel_full_guid):
        if status == 1:
            return
        elif status in [0, 2]:
            """Export failed"""
            self._host_api.timeout(
                100, lambda: callback(False, file_path, channel_full_guid)
            )
        else:
            """Export success"""
            self._host_api.timeout(
                100, lambda: callback(True, file_path, channel_full_guid)
            )

        self._now_exporting = False
        self._check_queue()

    def _export(
        self,
        channel_full_guid,
        dt_start,
        dt_end=None,
        duration=60,
        prefer_substream=False,
        file_name=None,
        file_path=None,
        callback=None,
    ):
        """Exporting file

        Call callback(success: bool, file_path: str, channel_full_guid: str)
        when export finished, and clear tasks in trassir main control panel

        Note:
            Export task adding only when previous task finished
            You can set dt_start, dt_end, or dt_start, duration for export
            if dt_end is None: dt_end = dt_start + timedelta(seconds=duration)

        Args:
            channel_full_guid (str): Full channel guid; example: "CFsuNBzt_pV4ggECb"
            dt_start (datetime): datetime instance for export start
            dt_end (datetime, optional): datetime instance for export end; default: None
            duration (int, optional): Export duration (dt_start + duration seconds) if dt_end is None; default: 10
            prefer_substream (bool, optional): If True - export substream; default: False
            file_name (str, optional): File name with extension; default: _EXPORTED_VIDEO_NAME_TEMPLATE
            file_path (str, optional): Path to save shot; default: screenshots_folder
            callback (function, optional): Function that calling when export finished
        """

        if "_" not in channel_full_guid:
            raise ValueError(
                "Expected full channel guid, got {}".format(channel_full_guid)
            )

        if not isinstance(dt_start, (datetime, date)):
            raise TypeError("Expected datetime, got {}".format(type(dt_start).__name__))

        if dt_end:
            if not isinstance(dt_end, (datetime, date)):
                raise TypeError(
                    "Expected datetime, got {}".format(type(dt_end).__name__)
                )
        else:
            dt_end = dt_start + timedelta(seconds=duration)

        ts_start = "%.0f" % (time.mktime(dt_start.timetuple()) * 1000000)
        ts_end = "%.0f" % (time.mktime(dt_end.timetuple()) * 1000000)

        channel_guid, server_guid = channel_full_guid.split("_")

        options = {
            "prefer_substream": prefer_substream,
            "postponed_until_ts": self._get_prebuffer(server_guid, dt_end),
        }

        if file_name is None:
            file_name = self._EXPORTED_VIDEO_NAME_TEMPLATE.format(
                name=BaseUtils.get_object_name_by_guid(channel_guid),
                dt_start=dt_start.strftime("%Y.%m.%d %H-%M-%S"),
                dt_end=dt_end.strftime("%Y.%m.%d %H-%M-%S"),
                sub="_sub" if prefer_substream else "",
            )

        if file_path is None:
            file_path = self.export_folder

        exporting_path = os.path.join(file_path, file_name)

        if callback is None:
            callback = BaseUtils.do_nothing

        self._now_exporting = True

        def checker(status):
            self._export_checker(status, callback, exporting_path, channel_full_guid)

        self._host_api.archive_export(
            server_guid,
            channel_guid,
            exporting_path,
            ts_start,
            ts_end,
            options,
            checker,
        )

    def export(
        self,
        channel_full_guid,
        dt_start,
        dt_end=None,
        duration=60,
        prefer_substream=False,
        file_name=None,
        file_path=None,
        callback=None,
    ):
        """Запускает экспорт или добавляет задачу экспорта в очередь.

        После завершения экспорта вызывает ``callback`` функцию
        а также очищает список задач экспорта в панеле управления Trassir.

        Note:
            Задача экспорта добавляется только после завершения предыдущей.

        Tip:
            - Вы можете задать время начала и окончания экспорта
              ``dt_start``, ``dt_end``.
            - Или можно задать время начала экспорта ``dt_start`` и
              продолжительность экспорта (в сек.) ``duration``. По умолчнию
              ``duration=60``.
            - Если ``dt_end=None`` фунция использует ``duration`` для вычисления
              времени окончания ``dt_end = dt_start + timedelta(seconds=duration)``.

        Args:
            channel_full_guid (:obj:`str`): Полный guid канала. Например: ``"CFsuNBzt_pV4ggECb"``
            dt_start (:obj:`datetime.datetime`): :obj:`datetime.datetime` начала экспорта
            dt_end (:obj:`datetime.datetime`, optional): :obj:`datetime.datetime` окончания экспорта.
                По умолчанию :obj:`None`
            duration (:obj:`int`, optional): Продолжительность экспорта, в секундах. Используется если
                ``dt_end is None``. По умолчанию ``60``
            prefer_substream (:obj:`bool`, optional): Если ``True`` - Экспортирует субпоток.
                По умолчанию ``False``
            file_name (:obj:`str`, optional): Имя экспортируемого файла. По умолчанию :obj:`None`
            file_path (:obj:`str`, optional): Путь для экспорта. По умолчанию :obj:`None`
            callback (:obj:`function`, optional): Функция, которая вызывается после завершения экспорта.
                По умолчанию :obj:`None`
        """

        args = (channel_full_guid, dt_start)
        kwargs = {
            "dt_end": dt_end,
            "duration": duration,
            "prefer_substream": prefer_substream,
            "file_name": file_name,
            "file_path": file_path,
            "callback": callback,
        }
        if self._now_exporting:
            self._queue.append((args, kwargs))
        else:
            self._export(*args, **kwargs)


class TemplateError(ScriptError):
    """Raised by Template class"""

    pass


class GUITemplate(py_object):
    """Класс для работы с шаблонами Trassir

    При инициализации находит существующий шаблон по имени или создает новый.

    Note:
        Если вручную создать два или большее шаблона с одинаковыми именами
        данный класс выберет первый попавшийся шаблон с заданным именем.

    Warning:
            Работа с контентом шаблона может привести к падениям трассира.
            Используйте данный класс на свой страх и риск!

    Tip:
        Для понимания, как формируется контент отредактируйте любой шаблон
        вручную и посмотрите что получится в скрытых параметрах трассира
        (активируются нажатием клавиши F4 в настройках трассира)
        `Настройки/Шабоны/<Имя шаблона>/content`

        Ниже предсталвены некоторые примеры шаблонов

        - Вывод одного канала ``S0tE8nfg_Or3QZu4D``
          :obj:`gui7(DEWARP_SETTINGS,zwVj07w0,dewarp(),1,S0tE8nfg_Or3QZu4D)`
        - Вывод шаблона 4х4 с каналами двумя ``Kpid6EC0_Or3QZu4D``, ``ZRtXLrgu_Or3QZu4D``
          :obj:`gui7(DEWARP_SETTINGS,zwVj07w0,dewarp(),4,Kpid6EC0_Or3QZu4D,ZRtXLrgu_Or3QZu4D,,)`
        - Вывод шаблон с минибраузером и ссылкой на https://www.google.com/
          :obj:`minibrowser(0,htmltab(,https://www.google.com/))`

    Args:
        template_name (:obj:`str`): Имя шаблон

    Examples:
        >>> # Создаем шаблон с именем "New template" и получаем его guid
        >>> template = Template("New template")
        >>> template.guid
        'Y2YFAkeZ'


        >>> # Устанавливаем на шаблон минибраузер с ссылкой на google
        >>> template.content = "minibrowser(0,htmltab(,https://www.google.com/))"

        >>> # Изменяем имя шаблона на "Google search"
        >>> template.name = "Google search"

        >>> # Открываем шаблон на первом мониторе
        >>> template.show(1)
    """

    _DEFAULT_TEMPLATE = ""

    def __init__(self, template_name, host_api=host):
        self._name = template_name
        self._host_api = host_api
        self._operator_gui = BaseUtils.get_operator_gui()
        try:
            self._guid, self._template_settings = self._find_template_guid(
                template_name
            )
        except KeyError:
            self._guid, self._template_settings = self._init_template(template_name)

    def _find_template_guid(self, name):
        """Find template guid by name

        Args:
            name (str) : Template name

        Raises:
            KeyError if can't find template
        """
        templates = self._host_api.settings("templates")
        for template_ in templates.ls():
            if name == template_.name:
                return (
                    template_.guid,
                    self._host_api.settings("templates/{}".format(template_.guid)),
                )
        raise KeyError

    def _init_template(self, name):
        """Create new template

        Args:
            name (str) : Template name
        """
        self._host_api.object(self._host_api.settings("").guid + "T").create_template(
            name, self._DEFAULT_TEMPLATE
        )
        try:
            return self._find_template_guid(name)
        except KeyError:
            raise TemplateError("Failed to create template {}".format(self._name))

    @property
    def guid(self):
        """:obj:`str`: Guid шаблона"""
        return self._guid

    @guid.setter
    def guid(self, value):
        raise RuntimeError("You can't change object guid")

    @property
    def name(self):
        """:obj:`str`: Имя шаблона"""
        return self._name

    @name.setter
    def name(self, value):
        if isinstance(value, str):
            self._name = value
            self._template_settings["name"] = value
        else:
            raise TypeError("Expected str, got {}".format(type(value).__name__))

    @property
    def content(self):
        """:obj:`str`: Контент шаблона"""
        return self._template_settings["content"]

    @content.setter
    def content(self, value):
        if isinstance(value, str):
            self._template_settings["content"] = value
        else:
            raise TypeError("Expected str, got {}".format(type(value).__name__))

    def delete(self):
        """Удаляет шаблон"""
        obj = BaseUtils.get_object(self.guid)
        if obj is None:
            raise TemplateError("Template object not found!")

        obj.delete_template()

    def show(self, monitor=1):
        """Открывает шаблон на указаном мониторе

        Args:
            monitor (:obj:`int`, optional): Номер монитора. По умолчанию ``monitor=1``
        """
        self._operator_gui.show(self.guid, monitor)


class TrObject(py_object):
    """Вспомогательный класс для работы с объектами Trassir

    Attributes:
        obj (:obj:`SE_Object`): Объект trassir :obj:`object('{guid}')` или :obj:`None`
        obj_methods (List[:obj:`str`]): Список методов объекта :attr:`TrObject.obj`
        name (:obj:`str`): Имя объекта или его guid
        guid (:obj:`str`): Guid объекта
        full_guid (:obj:`str`): Полный guid :obj:`{guid объекта}_{guid сервера}`
            или :obj:`None`
        type (:obj:`str`): Тип объекта, например :obj:`"RemoteServer"`, :obj:`"Channel"`,
            :obj:`"Grabber"`, :obj:`"User"`, и др.
        path (:obj:`str`): Путь в настройках или :obj:`None`
        parent (:obj:`str`): Guid родительского объекта или :obj:`None`
        server (:obj:`str`): Guid сервера или :obj:`None`
        settings (:obj:`SE_Settings`): Объект настроек ``settings('{path}')`` или :obj:`None`

    Raises:
        TypeError: Если неправильные параметры объекта
        ValueError: Если в имени объекта есть запятые
    """

    obj, name, guid, full_guid, type = None, None, None, None, None
    path, parent, server, settings = None, None, None, None

    def __init__(self, obj, host_api=host):
        self._host_api = host_api

        if isinstance(obj, host_api.ScriptHost.SE_Settings):
            self._load_from_settings(obj)
        elif isinstance(obj, tuple):
            if len(obj) == 4:
                self._load_from_tuple(obj)
            else:
                raise TypeError(
                    "Expected tuple(name, guid, type, parent), got tuple'{}'".format(
                        obj
                    )
                )
        else:
            raise TypeError("Unexpected object type '{}'".format(type(obj).__name__))

    @staticmethod
    def _check_object_name(object_name):
        """Check if object name hasn't got commas

        Args:
            object_name (str):

        Returns:
            str: object_name.strip()

        Raises:
            ValueError: If "," found in object name
        """
        if "," in object_name:
            raise ValueError(
                "Please, rename object '{}' without commas".format(object_name)
            )
        return object_name.strip()

    @staticmethod
    def _parse_server_from_path(path):
        """Parse server guid from full path

        Args:
            path (str): Full Trassir settings path;
                example: '/pV4ggECb/_persons/n68LOBhG' returns 'pV4ggECb'
        """
        try:
            server = path.split("/", 2)[1]
        except IndexError:
            server = None

        return server

    def _find_server_guid_for_object(self, object_guid):
        """Find server guid for object

        Args:
            object_guid (str): Object guid

        Returns:
            str: Server guid if server found
            None: If server not found
        """
        all_objects = {
            obj[1]: {"name": obj[0], "guid": obj[1], "type": obj[2], "parent": obj[3]}
            for obj in self._host_api.objects_list("")
        }

        def get_parent(child_guid):
            child = all_objects.get(child_guid, None)
            if child:
                if child["type"] == "Server":
                    return child["guid"]
                else:
                    return get_parent(child["parent"])
            else:
                return None

        return get_parent(object_guid)

    def _get_object_methods(self):
        """Get object methods"""
        if self.obj:
            return [method for method in dir(self.obj) if not method.startswith("__")]
        else:
            return []

    def _load_from_settings(self, obj):
        """Preparing attributes from SE_Settings object"""
        self.obj = BaseUtils.get_object(obj.guid)
        self.obj_methods = self._get_object_methods()

        try:
            obj_name = obj.name
        except KeyError:
            obj_name = obj.guid

        self.name = self._check_object_name(obj_name)
        self.guid = obj.guid
        self.type = obj.type
        self.path = obj.path
        self.server = self._parse_server_from_path(obj.path)
        self.settings = obj

        if self.server and self.server != self.guid:
            self.full_guid = "{0.guid}_{0.server}".format(self)

    def _load_from_tuple(self, obj):
        """Preparing attributes from tuple object"""
        self.obj = BaseUtils.get_object(obj[1])
        self.obj_methods = self._get_object_methods()
        self.name = self._check_object_name(obj[0])
        self.guid = obj[1]
        self.type = obj[2]
        self.parent = obj[3]
        self.server = self._find_server_guid_for_object(obj[1])

        if self.server and self.server != self.guid:
            self.full_guid = "{0.guid}_{0.server}".format(self)

    def __repr__(self):
        return "TrObject('{}')".format(self.name)

    def __str__(self):
        return "{self.type}: {self.name} ({self.guid})".format(self=self)


class ParameterError(ScriptError):
    """Ошибка в параметрах скрипта"""

    pass


class BasicObject(py_object):
    """"""

    def __init__(self, host_api=host):
        self._host_api = host_api
        self.this_server_guid = BaseUtils.get_server_guid()

    class UniqueNameError(ScriptError):
        """Имя объекта не уникально"""

        pass

    class ObjectsNotFoundError(ScriptError):
        """Не найдены объекты с заданными именами"""

        pass

    def _check_unique_name(self, objects, object_names):
        """Check if all objects name are unique

        Args:
            objects (list): Objects list from _get_objects_from_settings

        Raises:
            UniqueNameError: If some object name is not uniques
        """
        unique_names = []
        for obj in objects:
            if obj.name in object_names:
                if obj.name not in unique_names:
                    unique_names.append(obj.name)
                else:
                    raise self.UniqueNameError(
                        "Найдено несколько объектов {obj.type} с одинаковым именем '{obj.name}'! "
                        "Задайте уникальные имена".format(obj=obj)
                    )

    @staticmethod
    def _objects_str_to_list(objects):
        """Split object names if objects is str and strip each name

        Args:
            objects (str|list): Trassir object names in comma spaced string or list

        Returns:
            list: Stripped Trassir object names

        Raises:
            ScriptError: If object name selected more than once
        """
        if isinstance(objects, str):
            objects = objects.split(",")

        names = []
        for name in objects:
            strip_name = name.strip()
            if strip_name in names:
                raise ParameterError("Объект '{}' выбран несколько раз".format(name))
            names.append(strip_name)

        return names

    def _filter_objects_by_name(self, objects, object_names):
        """Filter object by names

        Args:
            objects (list): TrObject objects list
            object_names (str|list): Trassir object names in comma spaced string or list

        Raises:
            ObjectsNotFoundError: If len(object_name) != len(filtered_object)
        """
        object_names = self._objects_str_to_list(object_names)

        self._check_unique_name(objects, object_names)

        filtered_object = [obj for obj in objects if obj.name in object_names]

        if len(filtered_object) != len(object_names):
            channels_not_found = set(object_names) - set(
                obj.name for obj in filtered_object
            )

            try:
                object_type = objects[0].type
            except IndexError:
                object_type = "Unknown"

            raise self.ObjectsNotFoundError(
                "Не найдены объекты {object_type}: {names}".format(
                    object_type=object_type,
                    names=", ".join(name for name in channels_not_found),
                )
            )

        return filtered_object


class ObjectFromSetting(BasicObject):
    """"""

    def __init__(self):
        super(ObjectFromSetting, self).__init__()

    def _load_objects_from_settings(self, settings_path, obj_type, sub_condition=None):
        """Load objects from Trassir settings

        Args:
            settings_path (:obj:`str`): Trassir settings path. Example ``"scripts"``.
                Click F4 in the Trassir settings window to show hidden parameters.
            obj_type (:obj:`str` | :obj:`list`): Loading object type. Example ``"EmailAccount"``
            sub_condition (function, optional): Function with SE_Settings as argument to filter objects

        Returns:
            list: TrObject objects list
                Example [TrObject(...), TrObject(...), ...]
        """
        try:
            settings = self._host_api.settings(settings_path)
        except KeyError:
            settings = None

        objects = []
        if settings is not None:
            if isinstance(obj_type, str):
                obj_type = [obj_type]

            if sub_condition is None:
                sub_condition = BaseUtils.do_nothing

            for obj in settings.ls():
                if obj.type in obj_type:
                    if sub_condition(obj):
                        objects.append(TrObject(obj))
        return objects

    def _get_objects_from_settings(
        self,
        settings_path,
        object_type,
        object_names=None,
        server_guid=None,
        ban_empty_result=False,
        sub_condition=None,
    ):
        """Check if objects exists and returns list from _load_objects_from_settings

        Note:
             If object_names is not None - checking if all object names are unique

        Args:
            settings_path (:obj:`str`): Trassir settings path. Example ``"scripts"``.
                Click F4 in the Trassir settings window to show hidden parameters.
            object_type (:obj:`str` | :obj:`list`): Loading object type. Example ``"EmailAccount"``
            object_names (:obj:`str` | :obj:`list`, optional): Comma spaced string or
                list of object names. Default :obj:`None`
            server_guid (:obj:`str` | :obj:`list`, optional): Server guid. Default :obj:`None`
            ban_empty_result (:obj:`bool`, optional): If True - raise error if no one object found
            sub_condition (:obj:`func`, optional) : Function with SE_Settings as argument to filter objects

        Returns:
            list: Trassir list from _load_objects_from_settings

        Raises:
            ObjectsNotFoundError: If can't find channel
        """
        if object_names == "":
            raise ParameterError("'{}' не выбраны".format(object_type))

        if server_guid is None:
            server_guid = self.this_server_guid

        if isinstance(server_guid, str):
            server_guid = [server_guid]

        objects = []

        for guid in server_guid:
            objects += self._load_objects_from_settings(
                settings_path.format(server_guid=guid), object_type, sub_condition
            )

        if ban_empty_result and not objects:
            raise self.ObjectsNotFoundError(
                "Не найдено ниодного объекта '{}'".format(object_type)
            )

        if object_names is None:
            return objects

        else:
            return self._filter_objects_by_name(objects, object_names)


class Servers(ObjectFromSetting):
    """Класс для работы с серверами

    Examples:
        >>> srvs = Servers()
        >>> local_srv = srvs.get_local()
        [TrObject('Клиент')]
        >>> # Првоерим "Здоровье" локального сервера
        >>> local_srv[0].obj.state("server_health")
        'Health Problem'
    """

    def __init__(self):
        super(Servers, self).__init__()

    def get_local(self):
        """Возвращает локальный сервер (на котором запущен скрипт)

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._load_objects_from_settings("/", ["Client", "LocalServer"])

    def get_remote(self):
        """Возвращает список удаленных серверов

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._load_objects_from_settings("/", "RemoteServer")

    def get_all(self):
        """Возвращает список всех доступных серверов

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._load_objects_from_settings(
            "/", ["Client", "LocalServer", "RemoteServer"]
        )


class Channels(ObjectFromSetting):
    """Класс для работы с каналами

    See Also:
        `Каналы - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-channels-folder.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> channels = Channels()
        >>> selected_channels = channels.get_enabled("AC-D2121IR3W 2,AC-D9141IR2 1")
        >>> selected_channels
        [TrObject('AC-D2121IR3W 2'), TrObject('AC-D9141IR2 1')]
        >>>
        >>> # Включим ручную запись на выбранных каналах
        >>> for channel in selected_channels:
        >>>     channel.obj.manual_record_start()
        >>>
        >>> # Или добавим к имени канала его guid
        >>> for channel in selected_channels:
        >>>     channel.settings["name"] += " ({})".format(channel.guid)
    """

    def __init__(self, server_guid=None):
        super(Channels, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных каналов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            not_zombie = 1 - sett["archive_zombie_flag"]
            if not_zombie:
                try:
                    return self._host_api.settings(sett.cd("info")["grabber_path"])[
                        "grabber_enabled"
                    ]
                except KeyError:
                    return 0
            return 0

        return self._get_objects_from_settings(
            "/{server_guid}/channels",
            "Channel",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных каналов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            zombie = sett["archive_zombie_flag"]
            if not zombie:
                try:
                    return (
                        1
                        - self._host_api.settings(sett.cd("info")["grabber_path"])[
                            "grabber_enabled"
                        ]
                    )
                except KeyError:
                    return 1
            return 1

        return self._get_objects_from_settings(
            "/{server_guid}/channels",
            "Channel",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех каналов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/channels",
            "Channel",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Devices(ObjectFromSetting):
    """Класс для работы с ip устройствами

    See Also:
        `IP-устройства - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-ip-cameras-folder.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> devices = Devices()
        >>> enabled_devices = devices.get_enabled()
        >>> enabled_devices
        [TrObject('AC-D2121IR3W'), TrObject('AC-D5123IR32'), ...]
        >>>
        >>> # Перезагрузим все устройства
        >>> for dev in enabled_devices:
        >>>     dev.settings["reboot"] = 1
    """

    def __init__(self, server_guid=None):
        super(Devices, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных устройств

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["grabber_enabled"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/ip_cameras",
            "Grabber",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных устройств

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["grabber_enabled"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/ip_cameras",
            "Grabber",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех устройств

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/ip_cameras",
            "Grabber",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Scripts(ObjectFromSetting):
    """Класс для работы со скриптами

    See Also:
        `Скрипты - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-script-feature.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> scripts = Scripts()
        >>> all_scripts = scripts.get_all()
        >>> all_scripts
        [TrObject('Новый скрипт'), TrObject('HDD Health Monitor'), TrObject('Password Reminder')]
        >>>
        >>> # Отключим все скрипты
        >>> for script in all_scripts:
        >>>     script.settings["enable"] = 0
    """

    def __init__(self, server_guid=None):
        super(Scripts, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных скриптов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["enable"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Script",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных скриптов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["enable"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Script",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех скриптов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Script",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Rules(ObjectFromSetting):
    """Класс для работы с правилами

    See Also:
        `Правила - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-rule.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> rules = Rules()
        >>> all_rules = rules.get_all()
        >>> all_rules
        [TrObject('!Rule'), TrObject('NEW RULE'), TrObject('Новое правило')]
        >>>
        >>> # Отключим все правила
        >>> for rule in all_rules:
        >>>     rule.settings["enable"] = 0
    """

    def __init__(self, server_guid=None):
        super(Rules, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных правил

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["enable"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Rule",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных правил

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["enable"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Rule",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех правил

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен. По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Rule",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Schedules(ObjectFromSetting):
    """Класс для работы с расписаниями

    See Also:
        `Расписания - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-schedule.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> schedules = Schedules()
        >>> my_schedule = schedules.get_enabled("!Schedule")[0]
        >>> my_schedule.obj.state("color")
        'Red'
    """

    def __init__(self, server_guid=None):
        super(Schedules, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных расписаний

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["enable"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Schedule",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных расписаний

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["enable"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Schedule",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех расписаний

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "Schedule",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class TemplateLoops(ObjectFromSetting):
    """Класс для работы с циклическими просмотрами шаблонов

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> tmplate_loops = TemplateLoops()
        >>> tmplate_loops.get_all()
        [TrObject('Новый циклический просмотр')]
    """

    def __init__(self, server_guid=None):
        super(TemplateLoops, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных циклических просмотров шаблонов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["enable"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "TemplateLoop",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных циклических просмотров шаблонов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["enable"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "TemplateLoop",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех циклических просмотров шаблонов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "TemplateLoop",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class EmailAccounts(ObjectFromSetting):
    """Класс для работы с E-Mail аккаунтами

    See Also:
        `Добавление учетной записи e-mail - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-email-account.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> email_accounts = EmailAccounts()
        >>> email_accounts.get_all()
        [TrObject('Новая учетная запись e-mail'), TrObject('MyAccount')]
    """

    def __init__(self, server_guid=None):
        super(EmailAccounts, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_all(self, names=None):
        """Возвращает список всех E-Mail аккаунтов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/scripts",
            "EmailAccount",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class NetworkNodes(ObjectFromSetting):
    """Класс для работы с сетевыми подключениями

    See Also:
        `Сеть - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-network-folder.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> network_nodes = NetworkNodes("client")
        >>> network_nodes.get_enabled()
        [TrObject('QuattroStationPro (172.20.0.101)'), TrObject('NSK-HD-01 (127.0.0.1)')]
    """

    def __init__(self, server_guid=None):
        super(NetworkNodes, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных сетевых подключений

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["should_be_connected"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/network",
            "NetworkNode",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных сетевых подключений

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["should_be_connected"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/network",
            "NetworkNode",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех сетевых подключений

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/network",
            "NetworkNode",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class PosTerminals(ObjectFromSetting):
    """Класс для работы с POS Терминалами

    See Also:
        `Настройка POS-терминалов - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-pos-terminals-folder.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> pos_terminals = PosTerminals()
        >>> pos_terminals.get_disabled()
        [TrObject('Касса (1)')]
    """

    def __init__(self, server_guid=None):
        super(PosTerminals, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_enabled(self, names=None):
        """Возвращает список активных POS Терминалов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return sett["pos_enable"]
            except KeyError:
                return 0

        return self._get_objects_from_settings(
            "/{server_guid}/pos_folder2/terminals",
            "PosTerminal",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_disabled(self, names=None):
        """Возвращает список неактивных POS Терминалов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        def sub_condition(sett):
            try:
                return 1 - sett["pos_enable"]
            except KeyError:
                return 1

        return self._get_objects_from_settings(
            "/{server_guid}/pos_folder2/terminals",
            "PosTerminal",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )

    def get_all(self, names=None):
        """Возвращает список всех POS Терминалов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        return self._get_objects_from_settings(
            "/{server_guid}/pos_folder2/terminals",
            "PosTerminal",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Users(ObjectFromSetting):
    """Класс для работы с пользователями и их группами.

    See Also:
        `Пользователи - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-users-folder.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> users = Users()
        >>> users.get_groups()
        [TrObject('TEST')]
    """

    def __init__(self, server_guid=None):
        super(Users, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_groups(self, names=None):
        """Возвращает список групп пользователей

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_settings(
            "/{server_guid}/users",
            "Group",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_users(self, names=None):
        """Возвращает список пользователей

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_settings(
            "/{server_guid}/users",
            "User",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_users_by_groups(self, group_names):
        """Возвращает список пользователей из указанных групп

        Args:
            group_names (:obj:`str` | :obj:`list`): :obj:`str` - имена групп,
                разделенные запятыми или :obj:`list` - список имен.

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        if group_names is None:
            groups = [""]
        else:
            groups = [group.guid for group in self.get_groups(names=group_names)]

        def sub_condition(sett):
            return sett["group"] in groups

        return self._get_objects_from_settings(
            "/{server_guid}/users",
            "User",
            object_names=None,
            server_guid=self.server_guid,
            sub_condition=sub_condition,
        )


class Templates(ObjectFromSetting):
    """Класс для работы с существующими шаблонами.

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> templates = Templates(BaseUtils.get_server_guid())
        >>> templates.get_all()
        [TrObject('Parking'), TrObject('FR'), TrObject('AT'), TrObject('AD+')]
    """

    def __init__(self, server_guid=None):
        super(Templates, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_all(self, names=None):
        """Возвращает список шаблонов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_settings(
            "/{server_guid}/templates",
            "Template",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Persons(ObjectFromSetting):
    """Класс для работы с персонами и их папками.

    See Also:
        `Персоны - Руководство пользователя Trassir
        <https://www.dssl.ru/files/trassir/manual/ru/setup-persons-folder.html>`_

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
            >>> persons = Persons()
            >>> persons.get_folders()
            [TrObject('Мошенники'), TrObject('DSSL'), TrObject('persons')]
            >>> persons.get_persons()
            [
                {
                    'name': 'Leonardo',
                    'guid': 'cJuJYAha',
                    'gender': 0,
                    'birth_date': '1980-01-01',
                    'comment': 'Comment',
                    'contact_info': 'Contact info',
                    'folder_guid': 'n68LOBhG',
                    'image': <image, str>,
                    'image_guid': 'gBHZ2vpz',
                    'effective_rights': 0,
                },
                ...
            ]
            >>> persons.get_person_by_guid("cJuJYAha")
            {
                'name': 'Leonardo',
                'guid': 'cJuJYAha',
                'gender': 0,
                'birth_date': '1980-01-01',
                'comment': 'Comment',
                'contact_info': 'Contact info',
                'folder_guid': 'n68LOBhG',
                'image': <image, str>,
                'image_guid': 'gBHZ2vpz',
                'effective_rights': 0,
            }
    """

    _PERSONS_UPDATE_TIMEOUT = 10 * 60  # Time in sec between update _persons dict

    def __init__(self, server_guid=None):
        super(Persons, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        if isinstance(server_guid, str):
            server_guid = [server_guid]

        self.server_guid = server_guid

        self._persons = None

    def _update_persons_dict(self, timeout=10):
        """Updating self._persons dict"""
        persons = self.get_persons(timeout=timeout)
        by_guid, by_name = {}, {}
        for person in persons:
            by_guid[person["guid"]] = person
            by_name[person["name"]] = person

        self._persons = {
            "update_ts": int(time.time()),
            "by_guid": by_guid,
            "by_name": by_name,
        }

    def _check_loaded_persons(self, timeout=10):
        """This method check if self._persons dict is need to be updated"""
        ts_now = int(time.time())

        if (
            self._persons is None
            or (ts_now - self._persons["update_ts"]) > self._PERSONS_UPDATE_TIMEOUT
        ):
            self._update_persons_dict(timeout=timeout)

    def get_folders(self, names=None):
        """Возвращает список папок персон

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        try:
            folders = self._get_objects_from_settings(
                "/{server_guid}/persons",
                "PersonsSubFolder",
                object_names=names,
                server_guid=self.server_guid,
            )

            if names is None or "persons" in names:
                for guid in self.server_guid:
                    try:
                        settings = self._host_api.settings("/{}/persons".format(guid))
                    except KeyError:
                        continue

                    folders.append(TrObject(settings))

        except self.ObjectsNotFoundError as err:
            folders = []
            names = self._objects_str_to_list(names)

            if names is None or "persons" in names:
                for guid in self.server_guid:
                    try:
                        settings = self._host_api.settings("/{}/persons".format(guid))
                    except KeyError:
                        continue

                    folders.append(TrObject(settings))

            if not folders:
                raise err

        return folders

    def get_persons(self, folder_names=None, timeout=10):
        """Возвращает список персон

        Note:
            Данный метод работает только с локальной БД.

        Args:
            folder_names (:obj:`str` | List[:obj:`str`], optional): :obj:`str` -
                названия папок персон, разделенные запятыми или :obj:`list` -
                список папок персон. По умолчанию :obj:`None`
            timeout (:obj:`int`, optional): Макс. время запроса к БД.
                По умолчанию ``timeout=10``

        Returns:
            List[:obj:`dict`]: Список персон - если персоны найдены

        Raises:
            EnvironmentError: Если произошла ошибка при запросе в БД.
            TrassirError: Если в данной сборке Trassir нет метода :obj:`host.service_persons_get`
        """
        tmp_server_guid = self.server_guid[:]
        self.server_guid = [self.this_server_guid]
        persons_folders = self.get_folders(names=folder_names)
        self.server_guid = tmp_server_guid[:]

        try:
            persons = self._host_api.service_persons_get(
                [folder.guid for folder in persons_folders], True, 0, 0, timeout
            )
        except AttributeError:
            raise TrassirError(
                "Данный функционал не поддерживается вашей сборкой Trassir. "
                "Попробуйте обновить ПО."
            )

        if isinstance(persons, str):
            raise EnvironmentError(persons)

        return persons

    def get_person_by_guid(self, person_guid, timeout=10):
        """Возвращает информацию о персоне по его guid

        Note:
            Для уменьшения кол-ва запросов к БД - метод создает локальную
            копию всех персон при первом запросе и обновляет ее вместе
            с последующими запросами не чаще чем 1 раз в 10 минут.

        Args:
            person_guid (:obj:`str`): Guid персоны
            timeout (:obj:`int`, optional): Макс. время запроса к БД.
                По умолчанию ``timeout=10``

        Returns:
            :obj:`dict`: Даные о персоне или :obj:`None` если персона не найдена
        """
        self._check_loaded_persons(timeout=timeout)
        return self._persons["by_guid"].get(person_guid)

    def get_person_by_name(self, person_name, timeout=10):
        """Возвращает информацию о персоне по его имени

        Note:
            Для уменьшения кол-ва запросов к БД - метод создает локальную
            копию всех персон при первом запросе и обновляет ее вместе
            с последующими запросами не чаще чем 1 раз в 10 минут.

        Args:
            person_name (:obj:`str`): Имя персоны
            timeout (:obj:`int`, optional): Макс. время запроса к БД.
                По умолчанию ``timeout=10``

        Returns:
            :obj:`dict`: Даные о персоне или :obj:`None` если персона не найдена
        """
        self._check_loaded_persons(timeout=timeout)
        return self._persons["by_name"].get(person_name)


class ObjectFromList(BasicObject):
    """"""

    def __init__(self):
        super(ObjectFromList, self).__init__()

    def _load_objects_from_list(self, obj_type, sub_condition=None):
        """Load objects from Trassir objects_list method

        Args:
            obj_type (str | list): Loading object type; example: "EmailAccount"
            sub_condition (function, optional): Function with SE_Settings as argument to filter objects

        Returns:
            list: TrObject objects list
                Example [TrObject(...), TrObject(...), ...]
        """
        if sub_condition is None:
            sub_condition = BaseUtils.do_nothing

        objects = []
        for obj in self._host_api.objects_list(obj_type):
            if sub_condition(obj):
                objects.append(TrObject(obj))

        return objects

    def _get_objects_from_list(
        self,
        object_type,
        object_names=None,
        server_guid=None,
        ban_empty_result=False,
        sub_condition=None,
    ):
        """Check if objects exists and returns list from _load_objects_from_settings

        Note:
             If object_names is not None - checking if all object names are unique

        Args:
            object_type (str|list): Loading object type; example: "EmailAccount"
            object_names (str|list, optional): Comma spaced string or list of object names; default: None
            server_guid (str|list, optional): Server guids; default: None
            ban_empty_result (bool, optional): If True - raise ObjectsNotFoundError if no one object found
            sub_condition (func, optional) : Function with SE_Settings as argument to filter objects

        Returns:
            list: Trassir list from _load_objects_from_settings

        Raises:
            ObjectsNotFoundError: If can't find channel
        """
        if object_names == "":
            raise ParameterError("'{}' не выбраны".format(object_type))

        if server_guid is None:
            server_guid = self.this_server_guid
        else:
            if isinstance(server_guid, str):
                server_guid = [server_guid]

        objects = self._load_objects_from_list(object_type, sub_condition)

        objects = [obj for obj in objects if obj.server in server_guid]

        if ban_empty_result and not objects:
            raise self.ObjectsNotFoundError(
                "Не найдено ниодного объекта '{}'".format(object_type)
            )

        if object_names is None:
            return objects

        else:
            return self._filter_objects_by_name(objects, object_names)

    def _zone_type(self, zone_obj):
        """Возвращает тип зоны для объекта

        Args:
            zone_obj (:obj:`SE_Object`): Объект trassir ``object('{guid}')``

        Returns:
            :obj:`str`: Тип объекта
            :obj:`None`: Если тип зоны неизвестен
        """

        if not isinstance(zone_obj, self._host_api.ScriptHost.SE_Object):
            raise TypeError(
                "Expected SE_Object, got '{}'".format(type(zone_obj).__name__)
            )

        try:
            guid = zone_obj.guid
            channel, server = zone_obj.associated_channel.split("_")
        except (AttributeError, ValueError):
            return None

        try:
            zones_dir = self._host_api.settings(
                "/{}/channels/{}/people_zones".format(server, channel)
            )
            for i in xrange(16):
                if zones_dir["zone%02d_guid" % i] == guid:
                    func_type = zones_dir["zone%02d_func_type" % i]
                    if isinstance(func_type, int):
                        return (
                            ["Queue", "Workplace"][func_type]
                            if func_type in range(2)
                            else "Queue"
                        )
                    else:
                        return func_type
        except KeyError:
            "not a queue or workplace"

        try:
            zones_dir = self._host_api.settings(
                "/{}/channels/{}/workplace_zones".format(server, channel)
            )
            for i in xrange(16):
                if zones_dir["zone%02d_guid" % i] == guid:
                    return "Workplace"
        except KeyError:
            "not a workplace"

        try:
            zones_dir = settings("/%s/channels/%s/deep_people" % (server, channel))
            for i in xrange(16):
                if zones_dir["zone%02d_guid" % i] == guid:
                    if zones_dir["zone%02d_type" % i] in ["border", "border_swapped"]:
                        return "Border"
                    else:
                        return "Queue"
        except KeyError:
            "not a deep people queue"


class GPIO(ObjectFromList):
    """Класс для работы с тревожными входами/выходами

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> gpio = GPIO()
        >>> gpio_door = gpio.get_inputs("Door")[0]
        >>> gpio_door.obj.state("gpio_input_level")
        'Input Low (Normal High)'
        >>> gpio_light = gpio.get_outputs("Light")[0]
        >>> gpio_light.obj.set_output_high()
    """

    def __init__(self, server_guid=None):
        super(GPIO, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_inputs(self, names=None):
        """Возвращает список тревожных входов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "GPIO Input",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_outputs(self, names=None):
        """Возвращает список тревожных выходов

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "GPIO Output",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Zones(ObjectFromList):
    """Класс для работы с зонами

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> zones = Zones()
        >>> zones.get_queues("Касса 1")[0].obj.state("zone_queue")
        '5+'
    """

    def __init__(self, server_guid=None):
        super(Zones, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_people(self, names=None):
        """Возвращает список PeopleZones

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "PeopleZone",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_simt(self, names=None):
        """Возвращает список зон SIMT

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "SIMT Zone",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_workplaces(self, names=None):
        """Возвращает список рабочих зон

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        people_zones = self.get_people(names=names)

        return [
            zone
            for zone in people_zones
            if self._zone_type(zone.obj) in ["Workplace", "Рабочее место"]
        ]

    def get_queues(self, names=None):
        """Возвращает список зон очередей

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        people_zones = self.get_people(names=names)

        return [
            zone
            for zone in people_zones
            if self._zone_type(zone.obj) in ["", "Queue", "Очередь"]
        ]

    def get_shelves(self, names=None):
        """Возвращает список зон полок

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "Shelf",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class Borders(ObjectFromList):
    """Класс для работы с линиями пересечения

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.

    Examples:
        >>> borders = Borders()
        >>> borders.get_simt()
        [TrObject('DBOP')]
        >>> borders.get_all()
        [TrObject('Вход в офис'), TrObject('DBOP')]
    """

    def __init__(self, server_guid=None):
        super(Borders, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_head(self, names=None):
        """Возвращает список HeadBorders

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "HeadBorder",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_people(self, names=None):
        """Возвращает список PeopleBorders

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "PeopleBorder",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_simt(self, names=None):
        """Возвращает список SIMT Borders

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "SIMT Border",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

    def get_deep_people(self, names=None):
        """Возвращает список DeepPeopleBorders

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        people_zones = self._get_objects_from_list(
            "PeopleZone",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )

        return [zone for zone in people_zones if self._zone_type(zone.obj) == "Border"]

    def get_all(self, names=None):
        """Возвращает список всех линий пересечения

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """
        all_borders = (
            self.get_head()
            + self.get_people()
            + self.get_simt()
            + self.get_deep_people()
        )

        if names is None:
            return all_borders
        else:
            return self._filter_objects_by_name(all_borders, names)


class Sigur(ObjectFromList):
    """Класс для работы со СКУД Sigur

    Args:
        server_guid (:obj:`str` | List[:obj:`str`], optional): Guid сервера или список guid.
            По умолчанию :obj:`None`, что соотвествует всем доступным серверам.
    """

    def __init__(self, server_guid=None):
        super(Sigur, self).__init__()
        if server_guid is None:
            server_guid = [srv.guid for srv in Servers().get_all()]

        self.server_guid = server_guid

    def get_access_points(self, names=None):
        """Возвращает список точек доступа

        Args:
            names (:obj:`str` | :obj:`list`, optional): :obj:`str` - имена,
                разделенные запятыми или :obj:`list` - список имен.
                По умолчанию :obj:`None`

        Returns:
            List[:class:`TrObject`]: Список объектов
        """

        return self._get_objects_from_list(
            "Access Point",
            object_names=names,
            server_guid=self.server_guid,
            sub_condition=None,
        )


class TrassirError(ScriptError):
    """Exception if bad trassir version"""

    pass


class PokaYoke(py_object):
    """Класс для защиты от дурака

    Позволяет блокировать запуск скрипта на ПО, где это
    не предусмотрено (например, на клиенте или TOS).
    А также производить некоторые другие проверки.
    """

    _EMAIL_REGEXP = re.compile(
        r"[^@]+@[^@]+\.[^@]+"
    )  # Default regex to check emails list
    _PHONE_REGEXP = re.compile(r"[^\d,;]")  # Default regex to check phone list

    _host_api = host

    def __init__(self):
        pass

    @staticmethod
    def ban_tos():
        """Блокирует запуск скрипта на `Trassir OS`

        Raises:
            OSError: Если скрипт запускается на `Trassir OS`

        Examples:
            >>> PokaYoke.ban_tos()
            OSError: Скрипт недоступен для TrassirOS
        """
        if os.name != "nt":
            raise OSError("Скрипт недоступен для TrassirOS")

    @staticmethod
    def ban_win():
        """Блокирует запуск скрипта на `Windows OS`

        Raises:
            OSError: Если скрипт запускается на `Windows OS`

        Examples:
            >>> PokaYoke.ban_win()
            OSError: Скрипт недоступен для WindowsOS
        """
        if os.name == "nt":
            raise OSError("Скрипт недоступен для WindowsOS")

    @staticmethod
    def ban_client():
        """Блокирует запуск скрипта на `Trassir Client`

        Raises:
            TrassirError: Если скрипт запускается на `Trassir Client`

        Examples:
            >>> PokaYoke.ban_client()
            TrassirError: Скрипт недоступен для клиентской версии Trassir
        """
        if BaseUtils.get_server_guid() == "client":
            raise TrassirError("Скрипт недоступен для клиентской версии Trassir")

    @classmethod
    def ban_daemon(cls):
        """Блокирует запуск скрипта на сервре Trassir, который запущен как служба

        Raises:
            TrassirError: Если скрипт запускается на сервре Trassir,
                который запущен как служба

        Examples:
            >>> PokaYoke.ban_daemon()
            TrassirError: Скрипт недоступен для Trassir запущенным как служба
        """
        if cls._host_api.settings("system_wide_options")["daemon"]:
            raise TrassirError("Скрипт недоступен для Trassir запущенным как служба")

    @staticmethod
    def check_email_account(account_name):
        """Проверяет существование E-Mail аккаунта

        Args:
            account_name (:obj:`str`): Имя E-Mail аккаунта

        Returns:
             List[:class:`TrObject`]: Список объектов

        Raises:
            ParameterError: Если аккаунт не выбран
            ObjectsNotFoundError: Если аккаунт не найден

        Examples:
            >>> PokaYoke.check_email_account("")
            ParameterError: 'EmailAccount' не выбраны
            >>> PokaYoke.check_email_account("YourAccount")
            ObjectsNotFoundError: Не найдены объекты EmailAccount: YourAccount
            >>> PokaYoke.check_email_account("MyAccount")
            [TrObject('MyAccount')]
        """
        e_accounts = EmailAccounts(BaseUtils.get_server_guid())
        return e_accounts.get_all(account_name)

    @classmethod
    def parse_emails(cls, mailing_list, regex=None):
        """Парсит email дреса из строки

        Каждый email проверяется с помощью regex ``r"[^@]+@[^@]+\.[^@]+"``.

        Args:
            mailing_list (:obj:`str`): Список email адресов, разделенный запятыми
            regex (:obj:`SRE_Pattern`, optional): Новый regex шаблон для проверки.
                По умолчанию :obj:`None`

        Returns:
            List[:obj:`str`]: Список адресов

        Raises:
            ParameterError: Если найден невалидный email

        Examples:
            >>> PokaYoke.parse_emails("a.trubilil!dssl.ru,support@dssl.ru")
            ParameterError: Email 'a.trubilil!dssl.ru' is not valid!
            >>>
            >>> PokaYoke.parse_emails("a.trubilil@dssl.ru,support@dssl.ru")
            ['a.trubilil@dssl.ru', 'support@dssl.ru']
        """
        mailing_list = mailing_list.replace(" ", "")

        if not mailing_list:
            raise ParameterError("No emails to send!")

        if regex is None:
            regex = cls._EMAIL_REGEXP
        else:
            if not isinstance(regex, cls._EMAIL_REGEXP.__class__):
                raise TypeError(
                    "Expected re.compile, got '{}'".format(type(regex).__name__)
                )

        if isinstance(mailing_list, str):
            mailing_list = mailing_list.split(",")

        mailing_list = [mail.strip() for mail in mailing_list]

        for mail in mailing_list:
            if not regex.match(mail):
                raise ParameterError("Email '{}' is not valid!".format(mail))

        return mailing_list

    @classmethod
    def check_phones(cls, phones, regex=None):
        """Проверяет строку на валидность телефонных номеров

        Строка проверяется с помощью regex ``r"[^\d,;]"``.

        Args:
            phones (:obj:`str`): Список телефонов, разделенный запятыми или точкой с запятой
            regex (:obj:`SRE_Pattern`, optional): Новый regex шаблон для проверки.
                По умолчанию :obj:`None`

        Returns:
            :obj:`str`: Список номеров телефона

        Raises:
            ParameterError: Если найден невалидный номер телефона

        Examples:
            >>> PokaYoke.check_phones("79999999999,78888888888A")
            ParameterError: Bad chars in phone list: `A`
            >>>
            >>> PokaYoke.check_phones("a.trubilil@dssl.ru,support@dssl.ru")
            '79999999999,78888888888'
        """
        phones = phones.replace(" ", "")

        if not phones:
            raise ParameterError("No phones!")

        if regex is None:
            regex = cls._PHONE_REGEXP
        else:
            if not isinstance(regex, cls._PHONE_REGEXP.__class__):
                raise TypeError(
                    "Expected re.compile, got '{}'".format(type(regex).__name__)
                )
        bad_chars = regex.findall(phones)
        if bad_chars:
            raise ParameterError(
                "Bad chars in phone list: `{}`".format(", ".join(bad_chars))
            )

        return phones


class SenderError(Exception):
    """Base Sender Exception"""

    pass


class Sender(py_object):
    _HTML_IMG_TEMPLATE = """<img src="data:image/png;base64,{img}" {attr}>"""

    def __init__(self, host_api=host):
        self._host_api = host_api

    @staticmethod
    def _get_base64(image_path):
        """Returns base64 image

        Args:
            image_path (str): Image full path
        """
        image_path = BaseUtils.win_encode_path(image_path)
        if os.path.isfile(image_path):
            with open(image_path, "rb") as image_file:
                return base64.b64encode(image_file.read())

    @staticmethod
    def _get_html_img(image_base64, **kwargs):
        """Returns html img

        Args:
            image_base64 (str): Base64 image
        """
        return BaseUtils.base64_to_html_img(image_base64, **kwargs)

    def text(self, text):
        """Send text

        Args:
            text (str): Text message
        """
        pass

    def image(self, image_path, text=""):
        """Send image and optional text

        Args:
            image_path (str): Image path
            text (str, optional): Text message; default: ""
        """
        pass

    def files(self, file_paths, text=""):
        """Send file or list of files

        Args:
            file_paths (str|list): File path or list of paths
            text (str, optional): Text message; default: ""
        """
        pass


class PopupSender(Sender):
    """Класс для показа всплывающих окон в правом нижнем углу экрана

    Args:
        width (:obj:`int`, optional): Ширина изображения, px.
            По умолчанию :obj:`width=400`

    Examples:
        >>> sender = PopupSender(300)
        >>> sender.text("Hello World!")

            .. image:: images/popup_sender.text.png

        >>> sender.image(r"manual\en\cloud-devices-16.png")

            .. image:: images/popup_sender.image.png
    """

    def __init__(self, width=400):
        super(PopupSender, self).__init__()
        self._attr = {"width": width}

    def text(self, text, popup_type="message"):
        """Показывает текст во всплывающем окне

        Вызывает один из методов Trassir :obj:`host.alert`,
        :obj:`host.message` или :obj:`host.error` с текстом

        Args:
            text (:obj:`str`): Текст сообщения
            popup_type (:obj:`"message"` | :obj:`"alert"` | :obj:`"error"`, optional)
                Тип сообщения. По умолчанию :obj:`"message"`
        """

        if popup_type == "alert":
            self._host_api.alert(text)
        elif popup_type == "error":
            self._host_api.error(text)
        else:
            self._host_api.message(text)

    def image(self, image_path, text="", popup_type=None):
        """Показывает изображение во всплывающем окне

        Args:
            image_path (:obj:`str`): Полный путь до изображения
            text (:obj:`str`, optional): Текст сообщения. По умолчанию :obj:`""`
            popup_type (:obj:`"message"` | :obj:`"alert"` | :obj:`"error"`, optional)
                Тип сообщения. По умолчанию :obj:`"message"`
        """
        image_base64 = self._get_base64(image_path)

        if not image_base64:
            self.text("<b>File not found</b><br>{}".format(image_path), popup_type)
            return

        html_image = BaseUtils.base64_to_html_img(image_base64, **self._attr)

        html = "{image}"
        if text:
            html = "<b>{text}</b><br>{image}"

        self.text(html.format(text=text, image=html_image), popup_type)


class PopupWithBtnSender(Sender):
    """Класс для показа всплывающих окон с кнопкой `Оk`

    Note:
        | Для закрытия окна необходимо нажать кнопку `Ok` в течении 60 сек.
        | После 60 сек окно закрывается автоматически.

    Args:
        width (:obj:`int`, optional): Ширина изображения, px.
            По умолчанию :obj:`width=800`

    Examples:
        >>> sender = PopupWithBtnSender()
        >>> sender.text("Hello World!")

            .. image:: images/popup_with_btn_sender.text.png

        >>> sender.image(r"manual\en\cloud-devices-16.png")

            .. image:: images/popup_with_btn_sender.image.png
    """

    def __init__(self, width=800):
        super(PopupWithBtnSender, self).__init__()
        self._attr = {"width": width}

    def text(self, text):
        """Показывает текст во всплывающем окне

        Вызывает метод Trassir :obj:`host.question` с текстом

        Args:
            text (:obj:`str`): Текст сообщения
        """
        self._host_api.question(
            "<pre>{}</pre>".format(text), "Ok", BaseUtils.do_nothing
        )

    def image(self, image_path, text=""):
        """Показывает изображение во всплывающем окне

        Args:
            image_path (:obj:`str`): Полный путь до изображения
            text (:obj:`str`, optional): Текст сообщения. По умолчанию :obj:`""`
        """
        image_base64 = self._get_base64(image_path)

        if not image_base64:
            self.text("<b>File not found</b><br>{}".format(image_path))
            return

        html_image = BaseUtils.base64_to_html_img(image_base64, **self._attr)

        html = "{image}"
        if text:
            html = "<b>{text}</b><br>{image}"

        self.text(html.format(text=text, image=html_image))


class EmailSender(Sender):
    """Класс для отправки уведомлений, изображений и файлов на почту

    Note:
        По умолчанию тема сообщений соответствует шаблону
        ``{server_name} -> {script_name}``

    Tip:
        При отправке изображения с текстом предпочтительней использовать метод
        :meth:`EmailSender.image` с необязательным аргументом :obj:`text` чем
        :meth:`EmailSender.text` с необазательным аргументом :obj:`attachments`

    Args:
        account (:obj:`str`): E-Mail аккаунт trassir. Проверяется
            методом :meth:`PokaYoke.check_email_account`
        mailing_list (:obj:`str`): Список email адресов для отправки писем
            разделенный запятыми. Проверяется и парсится в список методом
            :meth:`PokaYoke.parse_emails`
        subject (:obj:`str`, optional): Общая тема для сообщений.
            По умолчанию :obj:`None`
        max_size (:obj:`int`, optional): Максимальный размер вложения, байт.
            По умолчанию 25 * 1024 * 1024

    Examples:
        >>> sender = EmailSender("MyAccount", "my_mail@google.com")
        >>> sender.text("Hello World!")

            .. image:: images/email_sender.text.png

        >>> sender.image(r"manual\en\cloud-devices-16.png")

            .. image:: images/email_sender.image.png

        >>> sender.files([r"manual\en\cloud.html", r"manual\en\cloud.png"])

            .. image:: images/email_sender.files.png
    """

    def __init__(self, account, mailing_list, subject=None, max_size=None):
        super(EmailSender, self).__init__()

        PokaYoke.check_email_account(account)

        self.max_size = max_size or 25 * 1024 * 1024

        self._account = account
        self._mailing_list = PokaYoke.parse_emails(mailing_list)

        self._subject_default = subject or self._generate_subject()

        logger.info(
            "EmailSender({}, {}, subject={}, max_size={})".format(
                repr(account),
                repr(mailing_list),
                repr(self._subject_default),
                repr(self.max_size),
            )
        )

    def _generate_subject(self):
        """Returns `server name` -> `script name`"""
        subject = "{server_name} -> {script_name}".format(
            server_name=self._host_api.settings("").name or "Client",
            script_name=self._host_api.stats().parent()["name"],
        )
        return subject

    def _group_files_by_max_size(self, file_paths, max_size):
        """Split files to groups. Size of each group is less then max_size

        Args:
            file_paths (list): List of files
            max_size (int): Max group size, bytes
        """
        group = []
        cur_size = 0
        for idx, file_path in enumerate(file_paths):
            file_size = os.stat(BaseUtils.win_encode_path(file_path)).st_size
            if not cur_size or (cur_size + file_size) < max_size:
                cur_size += file_size
                group.append(file_path)
            else:
                break
        else:
            return [group]

        return [group] + self._group_files_by_max_size(file_paths[idx:], max_size)

    def text(self, text, subject=None, attachments=None):
        """Отправка текстового сообщения

        Args:
            text (:obj:`str`): Текст сообщения
            subject (:obj:`str`, optional): Новая тема сообщения.
                По умолчанию :obj:`None`
            attachments (:obj:`list`, optional): Список вложений.
                По умолчанию :obj:`None`
        """
        if attachments is None:
            attachments = []
        self._host_api.send_mail_from_account(
            self._account,
            self._mailing_list,
            subject or self._subject_default,
            text,
            attachments,
        )

    def image(self, image_path, text="", subject=None):
        """Отправка изображения

        Args:
            image_path (:obj:`str`): Полный путь до изображения
            text (:obj:`str`, optional): Текст сообщения.
                По умолчанию :obj:`""`
            subject (:obj:`str`, optional): Новая тема сообщения.
                По умолчанию :obj:`None`
        """
        self.files([image_path], text=text, subject=subject)

    def files(self, file_paths, text="", subject=None, callback=None):
        """Отправка файлов

        Note:
            Если отправляется несколько файлов они могут быть разделены на
            несколько сообщений, основываясь на максимальном размере вложений.

        Args:
            file_paths (:obj:`str` | :obj:`list`): Путь до файла или список
                файлов для отправки
            text (:obj:`str`, optional): Текст сообщения.
                По умолчанию :obj:`""`
            subject (:obj:`str`, optional): Новая тема сообщения.
                По умолчанию :obj:`None`
            callback (:obj:`function`, optional): Функция, которая вызывается после
                отправки частей
        """
        logger.debug(
            "EmailSender.files({}, text={})".format(repr(file_paths), repr(text))
        )
        if isinstance(file_paths, str):
            file_paths = [file_paths]

        if callback is None:
            callback = BaseUtils.do_nothing

        files_to_send = []
        for path in file_paths:
            if BaseUtils.is_file_exists(path):
                files_to_send.append(path)
            else:
                text += "\nFile not found: {}".format(path)

        file_groups = self._group_files_by_max_size(files_to_send, self.max_size)

        for grouped_files in file_groups:
            logger.debug(
                "EmailSender.files: grouped_files: {}".format(repr(grouped_files))
            )
            self.text(text, subject=subject, attachments=grouped_files)
            callback(grouped_files)


class TelegramSender(Sender):
    """Работа с телеграм ботом `@trassirbot <https://t.me/trassirbot>`_

    Warnings:
        | Cкрипт должен быть запущен на **сервере** Trassir.
        | На Клиенте скрипт вызовет ошибку ``ServerKeyError``

    Args:
        telegram_ids (:obj:`str`): Id пользователей, через запятую.

    Examples:
        >>> # Можно указать id для рассылки при инициализации
        >>> # класса, для всех уведомлений
        >>> sender = TelegramSender("123456789")
        >>> sender.text("Hello World!")

            .. image:: images/telegram_sender.text.png

        >>> sender.image(r"manual\en\cloud-devices-16.png")

            .. image:: images/telegram_sender.image.png

        >>> sender.files([r"manual\en\cloud.html", r"manual\en\cloud.png"])

            .. image:: images/telegram_sender.files.png

        >>> # Или можно опередовать telegram id при вызове методов
        >>> sender = TelegramSender()
        >>> sender.text("Hello World!", tg_users=[123456789])

            .. image:: images/telegram_sender.text.png

        >>> sender.image(r"manual\en\cloud-devices-16.png", tg_users=[123456789])

            .. image:: images/telegram_sender.image.png

        >>> sender.files([r"manual\en\cloud.html", r"manual\en\cloud.png"], tg_users=[123456789])

            .. image:: images/telegram_sender.files.png
    """

    def __init__(self, telegram_ids=None):
        super(TelegramSender, self).__init__()
        self._host_api.exec_encoded(tbot_service)
        self._tbot_api = TBotAPI()
        if telegram_ids is not None:
            self.telegram_ids = TBotAPI.prepare_users(telegram_ids)
        else:
            self.telegram_ids = None

    def text(self, text, tg_users=None):
        """Отправка текстового сообщения

        Args:
            text (:obj:`str`): Текст сообщения.
            tg_users (List[:obj:`int`], optional): Список id пользователей
                telegram для отправки отдельных сообщений. По умолчанию :obj:`None`
        """
        if tg_users is None:
            tg_users = self.telegram_ids

        self._tbot_api.send_message(tg_users, text)

    def image(self, image_path, text="", tg_users=None, remove=False):
        """Отправка изображения

        Args:
            image_path (:obj:`str`): Полный путь до изображения
            text (:obj:`str`, optional): Текст сообщения.
                По умолчанию :obj:`""`
            tg_users (List[:obj:`int`], optional): Список id пользователей
                telegram для отправки отдельных сообщений. По умолчанию :obj:`None`
            remove (bool, optional): Удалить файл после отправки или нет. По умолчанию :obj:`False`
        """
        if not os.path.isfile(image_path):
            self.text("Image not found: {}".format(image_path))
            return

        if tg_users is None:
            tg_users = self.telegram_ids

        self._tbot_api.send_image(tg_users, image_path, caption=text, remove=remove)

    def files(self, file_paths, text="", tg_users=None, remove=False):
        """Отправка файлов

        Args:
            file_paths (:obj:`str` | :obj:`list`): Путь до файла или список
                файлов для отправки
            text (:obj:`str`, optional): Текст сообщения.
                По умолчанию :obj:`""`
            tg_users (List[:obj:`int`], optional): Список id пользователей
                telegram для отправки отдельных сообщений. По умолчанию :obj:`None`
            remove (bool, optional): Удалить файл после отправки или нет. По умолчанию :obj:`False`
        """

        if tg_users is None:
            tg_users = self.telegram_ids

        if isinstance(file_paths, str):
            file_paths = [file_paths]

        if text and len(file_paths) == 1:
            self.text(text, tg_users=tg_users)
            text = ""

        files_not_found_text = ""
        for path in file_paths:
            if os.path.isfile(BaseUtils.win_encode_path(path)):
                self._tbot_api.send_document(
                    tg_users, path, caption=text, remove=remove
                )
            else:
                files_not_found_text += "\nFile not found: {}".format(path)

        if files_not_found_text:
            self.text(files_not_found_text, tg_users=tg_users)


class SMSCSenderError(SenderError):
    """Raises with SMSCSender errors"""

    pass


class SMSCSender(Sender):
    """Класс для отправки сообщений с помощью сервиса smsc.ru

    See Also:
        `https://smsc.ru/api/http/ <https://smsc.ru/api/http/>`_

    Note:
        | Номера проверяются методом
          :meth:`PokaYoke.check_phones`
        | Также при первом запуске скрипт проверяет данные авторизации

    Warnings:
        | По умолчанию сервис smsc.ru отправляет сообщения от своего имени *SMSC.RU.*
          При этом отправка на номера Мегафон/Йота **недоступна** т.к. имя *SMSC.RU*
          заблокировано оператором.
        |
        | Мы настоятельно **НЕ** рекомендуем использовать стандартное имя *SMSC.RU.*
        |
        | Для отправки смс от вашего буквенного имени необходимо его
          создать в разделе - https://smsc.ru/senders/ и зарегистрировать для
          операторов в колонке Действия по кнопке Изменить (после заключения договора
          согласно инструкции - https://smsc.ru/contract/info/ ) а также приложить
          гарантийное письмо на МТС в личный кабинет http://smsc.ru/documents/ и
          отправить на почту inna@smsc.ru

    Args:
        login (:obj:`str`): SMSC Логин
        password (:obj:`str`): SMSC Пароль
        phones (:obj:`str`): Список номеров для отправки смс резделенный
            запятыми или точкой с запятой
        translit(:obj:`bool`, optional): Переводить сообщение в
            транслит. По умолчанию :obj:`True`

    Raises:
        SMSCSenderError: При любых ошибках с отправкой сообщения

    Examples:
        >>> sender = SMSCSender("login", "password", "79999999999")
        >>> sender.text("Hello World!")

            .. image:: images/smsc_sender.text.png
    """

    _BASE_URL = "https://smsc.ru/sys/send.php?{params}"
    _ERROR_CODES = {
        1: "URL Params error",
        2: "Invalid login or password",
        3: "Not enough money",
        4: "Your IP is temporary blocked. More info: https://smsc.ru/faq/99",
        5: "Bad date format",
        6: "Message is denied (by text or sender name)",
        7: "Bad phone format",
        8: "Can't send message to this number",
        9: "Too many requests",
    }

    def __init__(self, login, password, phones, translit=True):
        super(SMSCSender, self).__init__()
        if not login:
            raise SMSCSenderError("Empty login")
        if not password:
            raise SMSCSenderError("Empty password")

        self._params = {
            "login": urllib.quote(login),  # Login
            "psw": urllib.quote(password),  # Password or MD5 hash
            "phones": urllib.quote(
                PokaYoke.check_phones(phones)
            ),  # Comma or semicolon spaced phone list
            "fmt": 3,  # Response format: 0 - string; 1 - integers; 2 - xml; 3 - json
            "translit": 1 if translit else 0,  # If 1 - transliting message
            "charset": "utf-8",  # Message charset: "windows-1251"|"utf-8"|"koi8-r"
            "cost": 3,  # Message cost in response: 0 - msg; 1 - cost; 2 - msg+cost, 3 - msg+cost+balance
        }

        self._check_account()

    def _get_link(self, **kwargs):
        """Returns get link"""
        params = self._params.copy()
        params.update(kwargs)
        url = self._BASE_URL.format(params=urllib.urlencode(params))

        return url

    def _request_callback(self, code, result, error):
        """Callback for async_get"""
        if code != 200:
            raise SMSCSenderError("RequestError [{}]: {}".format(code, error))
        else:
            try:
                data = json.loads(result)
            except ValueError:
                data = {"error_code": 0, "error": "JSON loads error: {}".format(result)}

            error_code = data.get("error_code")
            if error_code is not None:
                error = self._ERROR_CODES.get(error_code)
                if not error:
                    error = data.get("error", "Unknown error")
                raise SMSCSenderError(
                    "ResponseError [{}]: {}".format(error_code, error)
                )

    def _check_account(self):
        """Send test request to smsc server"""
        url = self._get_link(cost=1, mes=urllib.quote("Hello world!"))
        self._host_api.async_get(url, self._request_callback)

    def text(self, text):
        """Отправка текстового сообщения

        Args:
            text (:obj:`str`): Текст сообщения.
        """

        url = self._get_link(mes=text)

        self._host_api.async_get(url, self._request_callback)


class FtpUploadTracker:
    """Upload progress class"""

    size_written = 0.0
    last_shown_percent = 0

    def __init__(self, file_path, callback, host_api=host):
        self._host_api = host_api
        self.total_size = os.path.getsize(BaseUtils.win_encode_path(file_path))
        self.file_path = file_path
        self.callback = callback

    # noinspection PyUnusedLocal
    def handle(self, block):
        """Handler for storbinary

        See Also:
            https://docs.python.org/2/library/ftplib.html#ftplib.FTP.storbinary
        """
        self.size_written += 1024.0
        percent_complete = round((self.size_written / self.total_size) * 100)

        if self.last_shown_percent != percent_complete:
            self.last_shown_percent = percent_complete
            self._host_api.timeout(
                100, lambda: self.callback(self.file_path, int(percent_complete), "")
            )


class FTPSenderError(SenderError):
    """Raises with FTPSender errors"""

    pass


class FTPSender(Sender):
    """Класс для отправки файлов на ftp сервер

    При инициализации проверят подключение к ftp серверу. Файлы отправляет
    по очереди. Максимальный размер очереди можно изменить. Во время
    выполнения передает текущий прогресс отправки файла в callback функцию.

    Note:
        Помимо прогресса в функцию callback может вернуться код ошибки.
            - -1 Файл не существует.
            - -2 Ошибка отправки на ftp, файл будет повторно отправлен.
            - -3 Неизвестная ошибка.


    Args:
        host (:obj:`str`): Адрес ftp сервера.
        port (:obj:`int`, optional): Порт ftp сервера. По умолчанию :obj:`port=21`
        user (:obj:`str`, optional): Имя пользователя. По умолчанию :obj:`"anonymous"`
        passwd (:obj:`str`, optional): Пароль пользователя. По умолчанию :obj:`passwd=""`
        work_dir (:obj:`str`, optional): Директория на сервре для сохранения файлов.
            По умолчанию :obj:`None`
        callback (:obj:`function`, optional): Callable function. По умолчанию :obj:`None`
        queue_maxlen (:obj:`int`, optional): Максимальная длина очереди на отправку.
            По умолчанию :obj:`queue_maxlen=1000`

    Examples:
        >>> # noinspection PyUnresolvedReferences
        >>> def callback(file_path, progress, error):
        >>>     # Пример callback функции, которая отображает
        >>>     # текущий прогресс в счетчике запуска скрипта
        >>>     # Args:
        >>>     #   file_path (str): Путь до файла
        >>>     #   progress (int): Текущий прогресс передачи файла, %
        >>>     #   error (str | Exception): Ошибка при отправке файла, если есть
        >>>     host.stats()["run_count"] = progress
        >>>     if error:
        >>>         host.error(error)
        >>>
        >>>     if progress == 100:
        >>>         host.timeout(3000, lambda: os.remove(BaseUtils.win_encode_path(file_path)))
        >>>
        >>> sender = FTPSender("172.20.0.10", 21, "trassir", "12345", work_dir="/test_dir/", callback=callback)
        >>> sender.files(r"D:\Shots\export_video.avi")
    """

    # noinspection SpellCheckingInspection,PyShadowingNames
    def __init__(
        self,
        host,
        port=21,
        user="anonymous",
        passwd="",
        work_dir=None,
        callback=None,
        queue_maxlen=1000,
    ):
        super(FTPSender, self).__init__()
        self._host = host
        self._port = port
        self._user = user
        self._passwd = passwd
        self._work_dir = work_dir

        self.queue = deque(maxlen=queue_maxlen)

        self._ftp = None

        if callback is None:
            callback = BaseUtils.do_nothing

        self.callback = callback

        self._work_now = False

        self._check_connection()

    def _check_connection(self):
        """Check if it possible to connect"""
        try:
            ftp = ftplib.FTP()
            ftp.connect(self._host, self._port, timeout=10)
            ftp.login(self._user, self._passwd)
        except ftplib.all_errors as err:
            raise FTPSenderError(err)
        if self._work_dir:
            try:
                ftp.cwd(self._work_dir)
            except ftplib.error_perm:
                ftp.mkd(self._work_dir)
                ftp.cwd(self._work_dir)

        ftp.quit()

    def _get_connection(self):
        """Connecting to ftp

        Returns:
            ftplib.FTP: Ftp object
        """
        try:
            ftp = ftplib.FTP()
            ftp.connect(self._host, self._port, timeout=10)
            ftp.login(self._user, self._passwd)
            if self._work_dir:
                try:
                    ftp.cwd(self._work_dir)
                except ftplib.error_perm:
                    ftp.mkd(self._work_dir)
                    ftp.cwd(self._work_dir)
            ftp.encoding = "utf-8"
            return ftp
        except ftplib.all_errors:
            return

    def _close_connection(self):
        """Close ftp connection"""
        try:
            if self._ftp is not None:
                self._ftp.close()
        finally:
            self._ftp = None

    def _send_file(self, file_path, work_dir=None):
        """Storbinary file with self.ftp

        Args:
            file_path (str): Full file path
            work_dir (str): Work dir on ftp
        """
        if work_dir is not None:
            if self._work_dir:
                work_dir = os.path.normpath("{}/{}".format(self._work_dir, work_dir))
            try:
                self._ftp.cwd(work_dir)
            except ftplib.error_perm:
                self._ftp.mkd(work_dir)
                self._ftp.cwd(work_dir)

        file_name = os.path.basename(file_path)
        upload_tracker = FtpUploadTracker(file_path, self.callback)
        with open(BaseUtils.win_encode_path(file_path), "rb") as opened_file:
            self._ftp.storbinary(
                "STOR " + file_name, opened_file, 1024, upload_tracker.handle
            )

    @BaseUtils.run_as_thread
    def _sender(self):
        """Send files in queue"""
        if self.queue:
            if self._ftp is None:
                self._ftp = self._get_connection()

            if self._ftp:
                work_dir = None
                file_path = self.queue.popleft()

                if isinstance(file_path, tuple):
                    file_path, work_dir = file_path

                if BaseUtils.is_file_exists(BaseUtils.win_encode_path(file_path)):
                    try:
                        self._send_file(file_path, work_dir)

                    except ftplib.all_errors as err:
                        self._host_api.timeout(
                            100, lambda: self.callback(file_path, -2, error=err)
                        )
                        self.queue.append(file_path)
                        self._close_connection()

                    except Exception as err:
                        self._host_api.timeout(
                            100, lambda: self.callback(file_path, -3, error=err)
                        )

                else:
                    self._host_api.timeout(
                        100,
                        lambda: self.callback(file_path, -1, error="File not found"),
                    )

            self._host_api.timeout(500, self._sender)
        else:
            self._work_now = False
            self._close_connection()

    def files(self, file_paths, *args):
        """Отправка файлов

        Note:
            Можно указать отдельный путь на ftp сервере для каждого файла.
            Для этого список файлов на отправку должен быть приведен к виду
            ``[(shot_path, ftp_path), ...]`` При этом так же будет учитываться
            глобальная папка :obj:`work_dir` заданная при инициализации класса.

        Args:
            file_paths (:obj:`str` | :obj:`list`): Путь до файла или список
                файлов для отправки
        """
        if not isinstance(file_paths, list):
            file_paths = [file_paths]

        self.queue.extend(file_paths)
        if not self._work_now:
            self._work_now = True
            self._sender()
